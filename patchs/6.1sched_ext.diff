diff --git a/android/abi_gki_aarch64_oplus b/android/abi_gki_aarch64_oplus
index 38514a3c7c618..059bdae89e766 100755
--- a/android/abi_gki_aarch64_oplus
+++ b/android/abi_gki_aarch64_oplus
@@ -153,6 +153,10 @@
   radix_tree_replace_slot
   _raw_write_trylock
   reciprocal_value
+  slim_for_app
+  task_is_scx
+  non_ext_task
+  __scx_ops_enabled
   register_tcf_proto_ops
   regulator_map_voltage_linear_range
   remove_proc_subtree
@@ -318,6 +322,12 @@
   __traceiter_android_vh_shrink_slab_bypass
   __traceiter_android_vh_si_mem_available_adjust
   __traceiter_android_vh_si_meminfo_adjust
+  __traceiter_android_vh_tick_nohz_idle_stop_tick
+  __traceiter_android_vh_hmbird_update_load
+  __traceiter_android_vh_hmbird_init_task
+  __traceiter_android_vh_hmbird_update_load_enable
+  __traceiter_android_vh_get_util
+  __traceiter_android_vh_shrink_node_memcgs
   __traceiter_android_vh_sync_txn_recvd
   __traceiter_android_vh_task_blocks_on_rtmutex
   __traceiter_android_vh_test_clear_look_around_ref
@@ -362,6 +372,32 @@
   __traceiter_android_rvh_kswapd_shrink_node
   __traceiter_android_rvh_perform_reclaim
   __tracepoint_android_rvh_do_madvise_bypass
+  __traceiter_android_vh_tune_swappiness
+  __traceiter_android_vh_test_clear_look_around_ref
+  __traceiter_android_vh_alloc_pages_reclaim_bypass
+  __traceiter_android_vh_free_unref_page_bypass
+  __traceiter_android_vh_kvmalloc_node_use_vmalloc
+  __traceiter_android_vh_should_alloc_pages_retry
+  __traceiter_android_vh_unreserve_highatomic_bypass
+  __traceiter_android_vh_rmqueue_bulk_bypass
+  __traceiter_android_vh_tune_mmap_readaround
+  __traceiter_android_vh_ra_tuning_max_page
+  __traceiter_android_vh_binder_find_desc
+  __traceiter_android_vh_binder_set_desc_bit
+  __traceiter_android_vh_binder_desc_init
+  __traceiter_android_vh_alloc_oem_binder_struct
+  __traceiter_android_vh_binder_transaction_received
+  __traceiter_android_vh_free_oem_binder_struct
+  __traceiter_android_vh_binder_special_task
+  __traceiter_android_vh_binder_free_buf
+  __traceiter_android_vh_binder_buffer_release
+  __traceiter_android_vh_copy_process
+  __traceiter_android_vh_scx_select_cpu_dfl
+  __traceiter_android_vh_scx_update_task_scale_time
+  __traceiter_android_vh_check_preempt_curr_scx
+  __traceiter_android_vh_task_fits_cpu_scx
+  __traceiter_android_vh_scx_cpu_exclusive
+  __traceiter_android_vh_scx_consume_dsq_allowed
   __tracepoint_android_rvh_post_init_entity_util_avg
   __tracepoint_android_rvh_rtmutex_force_update
   __tracepoint_android_rvh_set_cpus_allowed_comm
@@ -475,6 +511,19 @@
   __tracepoint_android_vh_save_vmalloc_stack
   __tracepoint_android_vh_sched_move_task
   __tracepoint_android_rvh_sched_setaffinity
+  __tracepoint_android_vh_rwsem_wake_finish
+  __tracepoint_android_vh_adjust_alloc_flags
+  __tracepoint_android_vh_adjust_kvmalloc_flags
+  __tracepoint_android_vh_alloc_pages_slowpath
+  __tracepoint_android_vh_sched_stat_runtime_rt
+  __tracepoint_android_vh_tick_nohz_idle_stop_tick
+  __tracepoint_android_vh_hmbird_update_load
+  __tracepoint_android_vh_hmbird_init_task
+  __tracepoint_android_vh_hmbird_update_load_enable
+  __tracepoint_android_vh_get_util
+  __tracepoint_android_vh_shrink_node_memcgs
+  __tracepoint_android_vh_sync_txn_recvd
+  __tracepoint_android_vh_tune_swappiness
   __tracepoint_android_vh_set_tsk_need_resched_lazy
   __tracepoint_android_vh_sched_setaffinity_early
   __tracepoint_android_vh_sched_stat_runtime_rt
@@ -529,6 +578,22 @@
   __tracepoint_android_rvh_perform_reclaim
   folio_total_mapcount
   page_mapping
+  __tracepoint_android_vh_binder_find_desc
+  __tracepoint_android_vh_binder_set_desc_bit
+  __tracepoint_android_vh_binder_desc_init
+  __tracepoint_android_vh_alloc_oem_binder_struct
+  __tracepoint_android_vh_binder_transaction_received
+  __tracepoint_android_vh_free_oem_binder_struct
+  __tracepoint_android_vh_binder_special_task
+  __tracepoint_android_vh_binder_free_buf
+  __tracepoint_android_vh_binder_buffer_release
+  __tracepoint_android_vh_copy_process
+  __tracepoint_android_vh_scx_select_cpu_dfl
+  __tracepoint_android_vh_scx_update_task_scale_time
+  __tracepoint_android_vh_check_preempt_curr_scx
+  __tracepoint_android_vh_task_fits_cpu_scx
+  __tracepoint_android_vh_scx_cpu_exclusive
+  __tracepoint_android_vh_scx_consume_dsq_allowed
   __trace_puts
   truncate_inode_pages
   try_to_del_timer_sync
@@ -1038,3 +1103,7 @@
   contpte_ptep_get
   contpte_ptep_set_access_flags
   __ptep_set_access_flags
+  scx_sched_rq_stats
+  scx_irq_work_lastq_ws
+  ext_module_loaded
+  hmbird_dir
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index f93980c09d7f3..47db6a98dbef7 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -1587,3 +1587,4 @@ CONFIG_CORESIGHT_STM=m
 CONFIG_CORESIGHT_CPU_DEBUG=m
 CONFIG_CORESIGHT_CTI=m
 CONFIG_MEMTEST=y
+CONFIG_HMBIRD_SCHED=y
diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index 71b501afca517..5c8c34cbccdf7 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -10,8 +10,7 @@ CONFIG_BPF_JIT_ALWAYS_ON=y
 # CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
 CONFIG_BPF_LSM=y
 CONFIG_PREEMPT=y
-CONFIG_SLIM_SCHED=y
-CONFIG_SCHED_CLASS_EXT=y
+CONFIG_HMBIRD_SCHED=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_TASKSTATS=y
 CONFIG_TASK_DELAY_ACCT=y
diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
old mode 100755
new mode 100644
index 4bd028fa75006..72b55fe122ce0
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -510,6 +510,9 @@ static int msm_drm_init(struct device *dev, const struct drm_driver *drv)
 		}
 
 		sched_set_fifo(ev_thread->worker->task);
+#ifdef CONFIG_HMBIRD_SCHED
+		sched_set_sched_prop(ev_thread->worker->task, SCHED_PROP_DEADLINE_LEVEL3);
+#endif
 	}
 
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
old mode 100755
new mode 100644
diff --git a/include/linux/sched.h b/include/linux/sched.h
index ba49d7bd2b674..8e12f479ed6dd 100755
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -75,6 +75,10 @@ struct user_event_mm;
 
 #include <linux/sched/ext.h>
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include <linux/sched/ext.h>
+#endif
+
 /*
  * Task state bitmask. NOTE! These bits are also
  * encoded in fs/proc/array.c: get_task_state().
@@ -1523,9 +1527,9 @@ struct task_struct {
 	 */
 	struct callback_head		l1d_flush_kill;
 #endif
-#ifdef CONFIG_SLIM_SCHED
+#ifdef CONFIG_HMBIRD_SCHED
 	ANDROID_KABI_USE(1, unsigned long sched_prop);
-	ANDROID_KABI_USE(2, struct sched_ext_entity *scx);
+	ANDROID_KABI_USE(2, struct sched_ext_entity	*scx;);
 #else
 	ANDROID_KABI_RESERVE(1);
 	ANDROID_KABI_RESERVE(2);
@@ -1933,6 +1937,54 @@ static inline int task_nice(const struct task_struct *p)
 	return PRIO_TO_NICE((p)->static_prio);
 }
 
+#ifdef CONFIG_HMBIRD_SCHED
+#define SCHED_PROP_DEADLINE_MASK (0xFF) /* deadline for ext sched class */
+#define SCHED_PROP_DEADLINE_LEVEL1 (1)  /* 1ms for user-aware audio tasks */
+#define SCHED_PROP_DEADLINE_LEVEL2 (2)  /* 2ms for user-aware touch tasks */
+#define SCHED_PROP_DEADLINE_LEVEL3 (3)  /* 4ms for user aware dispaly tasks */
+#define SCHED_PROP_DEADLINE_LEVEL4 (4)  /* 6ms */
+#define SCHED_PROP_DEADLINE_LEVEL5 (5)  /* 8ms */
+#define SCHED_PROP_DEADLINE_LEVEL6 (6)  /* 16ms */
+#define SCHED_PROP_DEADLINE_LEVEL7 (7)  /* 32ms */
+#define SCHED_PROP_DEADLINE_LEVEL8 (8)  /* 64ms */
+#define SCHED_PROP_DEADLINE_LEVEL9 (9)  /* 128ms */
+#define SCHED_EXT_DSQ_TYPE_PERIOD		(0) /* period dsq of scx */
+#define SCHED_EXT_DSQ_TYPE_NON_PERIOD	(1) /* non period dsq of scx */
+static inline long sched_prop_get_deadline_dsq_id(struct task_struct *p)
+{
+	return (p->scx->sched_prop & SCHED_PROP_DEADLINE_MASK) - 1;
+}
+
+#define SCHED_PROP_TOP_THREAD_SHIFT (8)
+#define SCHED_PROP_TOP_THREAD_MASK  (0xf << SCHED_PROP_TOP_THREAD_SHIFT)
+static inline int sched_prop_get_top_thread_id(struct task_struct *p)
+{
+	return (p->scx->sched_prop & SCHED_PROP_TOP_THREAD_MASK) >> SCHED_PROP_TOP_THREAD_SHIFT;
+}
+
+static inline int sched_set_sched_prop(struct task_struct *p, unsigned long sp)
+{
+	if (NULL == p->scx)
+		return 0;
+
+	p->scx->sched_prop = sp;
+	return 0;
+}
+
+static inline unsigned long sched_get_sched_prop(struct task_struct *p)
+{
+	return p->scx->sched_prop;
+}
+
+/* For why we choose (MAX_RT_PRIO / 2), see sched_set_fifo(). */
+static inline bool reject_change_to_scx(struct task_struct *p, int prio)
+{
+	int sp_dl = p->scx->sched_prop & SCHED_PROP_DEADLINE_MASK;
+
+	return (prio < (MAX_RT_PRIO >> 1)) && (sp_dl < SCHED_PROP_DEADLINE_LEVEL3);
+}
+bool task_is_scx(struct task_struct *p);
+#endif
 
 extern int can_nice(const struct task_struct *p, const int nice);
 extern int task_curr(const struct task_struct *p);
diff --git a/include/linux/sched/ext.h b/include/linux/sched/ext.h
index b737a00c1373c..c28fc977401a3 100755
--- a/include/linux/sched/ext.h
+++ b/include/linux/sched/ext.h
@@ -9,17 +9,19 @@
 #ifndef _LINUX_SCHED_EXT_H
 #define _LINUX_SCHED_EXT_H
 
-#ifdef CONFIG_SCHED_CLASS_EXT
-
 #include <linux/llist.h>
 
+extern atomic_t non_ext_task;
+extern atomic_t __scx_ops_enabled;
+#define scx_enabled()           atomic_read(&__scx_ops_enabled)
+
 enum scx_consts {
 	SCX_OPS_NAME_LEN	= 128,
 	SCX_EXIT_REASON_LEN	= 128,
 	SCX_EXIT_BT_LEN		= 64,
 	SCX_EXIT_MSG_LEN	= 1024,
 
-	SCX_SLICE_DFL		= 20 * NSEC_PER_MSEC,
+	SCX_SLICE_DFL		= 1 * NSEC_PER_MSEC,
 	SCX_SLICE_INF		= U64_MAX,	/* infinite, implies nohz */
 };
 
@@ -64,22 +66,6 @@ enum scx_exit_type {
 	SCX_EXIT_ERROR_STALL,	/* watchdog detected stalled runnable tasks */
 };
 
-/*
- * scx_exit_info is passed to ops.exit() to describe why the BPF scheduler is
- * being disabled.
- */
-struct scx_exit_info {
-	/* %SCX_EXIT_* - broad category of the exit reason */
-	enum scx_exit_type	type;
-	/* textual representation of the above */
-	char			reason[SCX_EXIT_REASON_LEN];
-	/* number of entries in the backtrace */
-	u32			bt_len;
-	/* backtrace if exiting due to an error */
-	unsigned long		bt[SCX_EXIT_BT_LEN];
-	/* extra message */
-	char			msg[SCX_EXIT_MSG_LEN];
-};
 
 /* sched_ext_ops.flags */
 enum scx_ops_flags {
@@ -120,382 +106,15 @@ enum scx_ops_flags {
 				  SCX_OPS_CGROUP_KNOB_WEIGHT,
 };
 
-/* argument container for ops.enable() and friends */
-struct scx_enable_args {
-};
-
-/* argument container for ops->cgroup_init() */
-struct scx_cgroup_init_args {
-	/* the weight of the cgroup [1..10000] */
-	u32			weight;
-};
-
 enum scx_cpu_preempt_reason {
 	/* next task is being scheduled by &sched_class_rt */
-        SCX_CPU_PREEMPT_RT,
+	SCX_CPU_PREEMPT_RT,
 	/* next task is being scheduled by &sched_class_dl */
-        SCX_CPU_PREEMPT_DL,
+	SCX_CPU_PREEMPT_DL,
 	/* next task is being scheduled by &sched_class_stop */
-        SCX_CPU_PREEMPT_STOP,
+	SCX_CPU_PREEMPT_STOP,
 	/* unknown reason for SCX being preempted */
-        SCX_CPU_PREEMPT_UNKNOWN,
-};
-
-/*
- * Argument container for ops->cpu_acquire(). Currently empty, but may be
- * expanded in the future.
- */
-struct scx_cpu_acquire_args {};
-
-/* argument container for ops->cpu_release() */
-struct scx_cpu_release_args {
-	/* the reason the CPU was preempted */
-	enum scx_cpu_preempt_reason reason;
-
-	/* the task that's going to be scheduled on the CPU */
-	struct task_struct *task;
-};
-
-/**
- * struct sched_ext_ops - Operation table for BPF scheduler implementation
- *
- * Userland can implement an arbitrary scheduling policy by implementing and
- * loading operations in this table.
- */
-struct sched_ext_ops {
-	/**
-	 * select_cpu - Pick the target CPU for a task which is being woken up
-	 * @p: task being woken up
-	 * @prev_cpu: the cpu @p was on before sleeping
-	 * @wake_flags: SCX_WAKE_*
-	 *
-	 * Decision made here isn't final. @p may be moved to any CPU while it
-	 * is getting dispatched for execution later. However, as @p is not on
-	 * the rq at this point, getting the eventual execution CPU right here
-	 * saves a small bit of overhead down the line.
-	 *
-	 * If an idle CPU is returned, the CPU is kicked and will try to
-	 * dispatch. While an explicit custom mechanism can be added,
-	 * select_cpu() serves as the default way to wake up idle CPUs.
-	 */
-	s32 (*select_cpu)(struct task_struct *p, s32 prev_cpu, u64 wake_flags);
-
-	/**
-	 * enqueue - Enqueue a task on the BPF scheduler
-	 * @p: task being enqueued
-	 * @enq_flags: %SCX_ENQ_*
-	 *
-	 * @p is ready to run. Dispatch directly by calling scx_bpf_dispatch()
-	 * or enqueue on the BPF scheduler. If not directly dispatched, the bpf
-	 * scheduler owns @p and if it fails to dispatch @p, the task will
-	 * stall.
-	 */
-	void (*enqueue)(struct task_struct *p, u64 enq_flags);
-
-	/**
-	 * dequeue - Remove a task from the BPF scheduler
-	 * @p: task being dequeued
-	 * @deq_flags: %SCX_DEQ_*
-	 *
-	 * Remove @p from the BPF scheduler. This is usually called to isolate
-	 * the task while updating its scheduling properties (e.g. priority).
-	 *
-	 * The ext core keeps track of whether the BPF side owns a given task or
-	 * not and can gracefully ignore spurious dispatches from BPF side,
-	 * which makes it safe to not implement this method. However, depending
-	 * on the scheduling logic, this can lead to confusing behaviors - e.g.
-	 * scheduling position not being updated across a priority change.
-	 */
-	void (*dequeue)(struct task_struct *p, u64 deq_flags);
-
-	/**
-	 * dispatch - Dispatch tasks from the BPF scheduler and/or consume DSQs
-	 * @cpu: CPU to dispatch tasks for
-	 * @prev: previous task being switched out
-	 *
-	 * Called when a CPU's local dsq is empty. The operation should dispatch
-	 * one or more tasks from the BPF scheduler into the DSQs using
-	 * scx_bpf_dispatch() and/or consume user DSQs into the local DSQ using
-	 * scx_bpf_consume().
-	 *
-	 * The maximum number of times scx_bpf_dispatch() can be called without
-	 * an intervening scx_bpf_consume() is specified by
-	 * ops.dispatch_max_batch. See the comments on top of the two functions
-	 * for more details.
-	 *
-	 * When not %NULL, @prev is an SCX task with its slice depleted. If
-	 * @prev is still runnable as indicated by set %SCX_TASK_QUEUED in
-	 * @prev->scx.flags, it is not enqueued yet and will be enqueued after
-	 * ops.dispatch() returns. To keep executing @prev, return without
-	 * dispatching or consuming any tasks. Also see %SCX_OPS_ENQ_LAST.
-	 */
-	void (*dispatch)(s32 cpu, struct task_struct *prev);
-
-	/**
-	 * runnable - A task is becoming runnable on its associated CPU
-	 * @p: task becoming runnable
-	 * @enq_flags: %SCX_ENQ_*
-	 *
-	 * This and the following three functions can be used to track a task's
-	 * execution state transitions. A task becomes ->runnable() on a CPU,
-	 * and then goes through one or more ->running() and ->stopping() pairs
-	 * as it runs on the CPU, and eventually becomes ->quiescent() when it's
-	 * done running on the CPU.
-	 *
-	 * @p is becoming runnable on the CPU because it's
-	 *
-	 * - waking up (%SCX_ENQ_WAKEUP)
-	 * - being moved from another CPU
-	 * - being restored after temporarily taken off the queue for an
-	 *   attribute change.
-	 *
-	 * This and ->enqueue() are related but not coupled. This operation
-	 * notifies @p's state transition and may not be followed by ->enqueue()
-	 * e.g. when @p is being dispatched to a remote CPU. Likewise, a task
-	 * may be ->enqueue()'d without being preceded by this operation e.g.
-	 * after exhausting its slice.
-	 */
-	void (*runnable)(struct task_struct *p, u64 enq_flags);
-
-	/**
-	 * running - A task is starting to run on its associated CPU
-	 * @p: task starting to run
-	 *
-	 * See ->runnable() for explanation on the task state notifiers.
-	 */
-	void (*running)(struct task_struct *p);
-
-	/**
-	 * stopping - A task is stopping execution
-	 * @p: task stopping to run
-	 * @runnable: is task @p still runnable?
-	 *
-	 * See ->runnable() for explanation on the task state notifiers. If
-	 * !@runnable, ->quiescent() will be invoked after this operation
-	 * returns.
-	 */
-	void (*stopping)(struct task_struct *p, bool runnable);
-
-	/**
-	 * quiescent - A task is becoming not runnable on its associated CPU
-	 * @p: task becoming not runnable
-	 * @deq_flags: %SCX_DEQ_*
-	 *
-	 * See ->runnable() for explanation on the task state notifiers.
-	 *
-	 * @p is becoming quiescent on the CPU because it's
-	 *
-	 * - sleeping (%SCX_DEQ_SLEEP)
-	 * - being moved to another CPU
-	 * - being temporarily taken off the queue for an attribute change
-	 *   (%SCX_DEQ_SAVE)
-	 *
-	 * This and ->dequeue() are related but not coupled. This operation
-	 * notifies @p's state transition and may not be preceded by ->dequeue()
-	 * e.g. when @p is being dispatched to a remote CPU.
-	 */
-	void (*quiescent)(struct task_struct *p, u64 deq_flags);
-
-	/**
-	 * yield - Yield CPU
-	 * @from: yielding task
-	 * @to: optional yield target task
-	 *
-	 * If @to is NULL, @from is yielding the CPU to other runnable tasks.
-	 * The BPF scheduler should ensure that other available tasks are
-	 * dispatched before the yielding task. Return value is ignored in this
-	 * case.
-	 *
-	 * If @to is not-NULL, @from wants to yield the CPU to @to. If the bpf
-	 * scheduler can implement the request, return %true; otherwise, %false.
-	 */
-	bool (*yield)(struct task_struct *from, struct task_struct *to);
-
-	/**
-	 * core_sched_before - Task ordering for core-sched
-	 * @a: task A
-	 * @b: task B
-	 *
-	 * Used by core-sched to determine the ordering between two tasks. See
-	 * Documentation/admin-guide/hw-vuln/core-scheduling.rst for details on
-	 * core-sched.
-	 *
-	 * Both @a and @b are runnable and may or may not currently be queued on
-	 * the BPF scheduler. Should return %true if @a should run before @b.
-	 * %false if there's no required ordering or @b should run before @a.
-	 *
-	 * If not specified, the default is ordering them according to when they
-	 * became runnable.
-	 */
-	bool (*core_sched_before)(struct task_struct *a,struct task_struct *b);
-
-	/**
-	 * set_weight - Set task weight
-	 * @p: task to set weight for
-	 * @weight: new eight [1..10000]
-	 *
-	 * Update @p's weight to @weight.
-	 */
-	void (*set_weight)(struct task_struct *p, u32 weight);
-
-	/**
-	 * set_cpumask - Set CPU affinity
-	 * @p: task to set CPU affinity for
-	 * @cpumask: cpumask of cpus that @p can run on
-	 *
-	 * Update @p's CPU affinity to @cpumask.
-	 */
-	void (*set_cpumask)(struct task_struct *p, struct cpumask *cpumask);
-
-	/**
-	 * update_idle - Update the idle state of a CPU
-	 * @cpu: CPU to udpate the idle state for
-	 * @idle: whether entering or exiting the idle state
-	 *
-	 * This operation is called when @rq's CPU goes or leaves the idle
-	 * state. By default, implementing this operation disables the built-in
-	 * idle CPU tracking and the following helpers become unavailable:
-	 *
-	 * - scx_bpf_select_cpu_dfl()
-	 * - scx_bpf_test_and_clear_cpu_idle()
-	 * - scx_bpf_pick_idle_cpu()
-	 * - scx_bpf_any_idle_cpu()
-	 *
-	 * The user also must implement ops.select_cpu() as the default
-	 * implementation relies on scx_bpf_select_cpu_dfl().
-	 *
-	 * If you keep the built-in idle tracking, specify the
-	 * %SCX_OPS_KEEP_BUILTIN_IDLE flag.
-	 */
-	void (*update_idle)(s32 cpu, bool idle);
-
-	/**
-	 * cpu_acquire - A CPU is becoming available to the BPF scheduler
-	 * @cpu: The CPU being acquired by the BPF scheduler.
-	 * @args: Acquire arguments, see the struct definition.
-	 *
-	 * A CPU that was previously released from the BPF scheduler is now once
-	 * again under its control.
-	 */
-	void (*cpu_acquire)(s32 cpu, struct scx_cpu_acquire_args *args);
-
-	/**
-	 * cpu_release - A CPU is taken away from the BPF scheduler
-	 * @cpu: The CPU being released by the BPF scheduler.
-	 * @args: Release arguments, see the struct definition.
-	 *
-	 * The specified CPU is no longer under the control of the BPF
-	 * scheduler. This could be because it was preempted by a higher
-	 * priority sched_class, though there may be other reasons as well. The
-	 * caller should consult @args->reason to determine the cause.
-	 */
-	void (*cpu_release)(s32 cpu, struct scx_cpu_release_args *args);
-
-	/**
-	 * cpu_online - A CPU became online
-	 * @cpu: CPU which just came up
-	 *
-	 * @cpu just came online. @cpu doesn't call ops.enqueue() or run tasks
-	 * associated with other CPUs beforehand.
-	 */
-	void (*cpu_online)(s32 cpu);
-
-	/**
-	 * cpu_offline - A CPU is going offline
-	 * @cpu: CPU which is going offline
-	 *
-	 * @cpu is going offline. @cpu doesn't call ops.enqueue() or run tasks
-	 * associated with other CPUs afterwards.
-	 */
-	void (*cpu_offline)(s32 cpu);
-
-	/**
-	 * prep_enable - Prepare to enable BPF scheduling for a task
-	 * @p: task to prepare BPF scheduling for
-	 * @args: enable arguments, see the struct definition
-	 *
-	 * Either we're loading a BPF scheduler or a new task is being forked.
-	 * Prepare BPF scheduling for @p. This operation may block and can be
-	 * used for allocations.
-	 *
-	 * Return 0 for success, -errno for failure. An error return while
-	 * loading will abort loading of the BPF scheduler. During a fork, will
-	 * abort the specific fork.
-	 */
-	s32 (*prep_enable)(struct task_struct *p, struct scx_enable_args *args);
-
-	/**
-	 * enable - Enable BPF scheduling for a task
-	 * @p: task to enable BPF scheduling for
-	 * @args: enable arguments, see the struct definition
-	 *
-	 * Enable @p for BPF scheduling. @p is now in the cgroup specified for
-	 * the preceding prep_enable() and will start running soon.
-	 */
-	void (*enable)(struct task_struct *p, struct scx_enable_args *args);
-
-	/**
-	 * cancel_enable - Cancel prep_enable()
-	 * @p: task being canceled
-	 * @args: enable arguments, see the struct definition
-	 *
-	 * @p was prep_enable()'d but failed before reaching enable(). Undo the
-	 * preparation.
-	 */
-	void (*cancel_enable)(struct task_struct *p,
-			      struct scx_enable_args *args);
-
-	/**
-	 * disable - Disable BPF scheduling for a task
-	 * @p: task to disable BPF scheduling for
-	 *
-	 * @p is exiting, leaving SCX or the BPF scheduler is being unloaded.
-	 * Disable BPF scheduling for @p.
-	 */
-	void (*disable)(struct task_struct *p);
-
-	/*
-	 * All online ops must come before ops.init().
-	 */
-
-	/**
-	 * init - Initialize the BPF scheduler
-	 */
-	s32 (*init)(void);
-
-	/**
-	 * exit - Clean up after the BPF scheduler
-	 * @info: Exit info
-	 */
-	void (*exit)(struct scx_exit_info *info);
-
-	/**
-	 * dispatch_max_batch - Max nr of tasks that dispatch() can dispatch
-	 */
-	u32 dispatch_max_batch;
-
-	/**
-	 * flags - %SCX_OPS_* flags
-	 */
-	u64 flags;
-
-	/**
-	 * timeout_ms - The maximum amount of time, in milliseconds, that a
-	 * runnable task should be able to wait before being scheduled. The
-	 * maximum timeout may not exceed the default timeout of 30 seconds.
-	 *
-	 * Defaults to the maximum allowed timeout value of 30 seconds.
-	 */
-	u32 timeout_ms;
-
-	/**
-	 * name - BPF scheduler's name
-	 *
-	 * Must be a non-zero valid BPF object name including only isalnum(),
-	 * '_' and '.' chars. Shows up in kernel.sched_ext_ops sysctl while the
-	 * BPF scheduler is enabled.
-	 */
-	char name[SCX_OPS_NAME_LEN];
+	SCX_CPU_PREEMPT_UNKNOWN,
 };
 
 /*
@@ -510,6 +129,8 @@ struct scx_dispatch_q {
 	u64			id;
 	struct llist_node	free_node;
 	struct rcu_head		rcu;
+	u64                     last_consume_at;
+	bool                    is_timeout;
 };
 
 /* scx_entity.flags */
@@ -532,31 +153,6 @@ enum scx_ent_dsq_flags {
 	SCX_TASK_DSQ_ON_PRIQ	= 1 << 0, /* task is queued on the priority queue of a dsq */
 };
 
-/*
- * Mask bits for scx_entity.kf_mask. Not all kfuncs can be called from
- * everywhere and the following bits track which kfunc sets are currently
- * allowed for %current. This simple per-task tracking works because SCX ops
- * nest in a limited way. BPF will likely implement a way to allow and disallow
- * kfuncs depending on the calling context which will replace this manual
- * mechanism. See scx_kf_allow().
- */
-enum scx_kf_mask {
-	SCX_KF_UNLOCKED		= 0,	  /* not sleepable, not rq locked */
-	/* all non-sleepables may be nested inside INIT and SLEEPABLE */
-	SCX_KF_INIT		= 1 << 0, /* running ops.init() */
-	SCX_KF_SLEEPABLE	= 1 << 1, /* other sleepable init operations */
-	/* ENQUEUE and DISPATCH may be nested inside CPU_RELEASE */
-	SCX_KF_CPU_RELEASE	= 1 << 2, /* ops.cpu_release() */
-	/* ops.dequeue (in REST) may be nested inside DISPATCH */
-	SCX_KF_DISPATCH		= 1 << 3, /* ops.dispatch() */
-	SCX_KF_ENQUEUE		= 1 << 4, /* ops.enqueue() */
-	SCX_KF_REST		= 1 << 5, /* other rq-locked operations */
-
-	__SCX_KF_RQ_LOCKED	= SCX_KF_CPU_RELEASE | SCX_KF_DISPATCH |
-				  SCX_KF_ENQUEUE | SCX_KF_REST,
-	__SCX_KF_TERMINAL	= SCX_KF_ENQUEUE | SCX_KF_REST,
-};
-
 #define RAVG_HIST_SIZE 5
 struct scx_sched_task_stats {
 	u64				mark_start;
@@ -571,7 +167,6 @@ struct scx_sched_task_stats {
 };
 
 
-
 /*
  * The following is embedded in task_struct and contains all fields necessary
  * for a task to be scheduled by SCX.
@@ -592,9 +187,6 @@ struct sched_ext_entity {
 	struct task_struct	*kf_tasks[2];	/* see SCX_CALL_OP_TASK() */
 	atomic64_t		ops_state;
 	unsigned long		runnable_at;
-#ifdef CONFIG_SCHED_CORE
-	u64			core_sched_at;	/* see scx_prio_less() */
-#endif
 
 	/* BPF scheduler modifiable fields */
 
@@ -620,7 +212,7 @@ struct sched_ext_entity {
 	u64			dsq_vtime;
 
 	/*
-	 * If set, reject future sched_setscheduler(2) calls updating the policy
+	 * If set, reject future set scheduler calls updating the policy
 	 * to %SCHED_EXT with -%EACCES.
 	 *
 	 * If set from ops.prep_enable() and the task's policy is already
@@ -634,14 +226,12 @@ struct sched_ext_entity {
 	/* cold fields */
 	struct list_head	tasks_node;
 	struct task_struct	*task;
+	unsigned long		sched_prop;
 	struct scx_sched_task_stats sts;
+	unsigned long           running_at;
+	int                     gdsq_idx;
 };
 
 void sched_ext_free(struct task_struct *p);
 
-#else	/* !CONFIG_SCHED_CLASS_EXT */
-
-static inline void sched_ext_free(struct task_struct *p) {}
-
-#endif	/* CONFIG_SCHED_CLASS_EXT */
 #endif	/* _LINUX_SCHED_EXT_H */
diff --git a/include/trace/hooks/sched.h b/include/trace/hooks/sched.h
index a6ba5d0ae5eee..4a83e0699267a 100755
--- a/include/trace/hooks/sched.h
+++ b/include/trace/hooks/sched.h
@@ -411,6 +411,22 @@ DECLARE_HOOK(android_vh_map_util_freq,
 		unsigned long cap, unsigned long *next_freq, struct cpufreq_policy *policy,
 		bool *need_freq_update),
 	TP_ARGS(util, freq, cap, next_freq, policy, need_freq_update));
+DECLARE_HOOK(android_vh_hmbird_update_load,
+	TP_PROTO(struct task_struct *p, struct rq *rq, int event, u64 wallclock),
+	TP_ARGS(p, rq, event, wallclock));
+
+DECLARE_HOOK(android_vh_hmbird_init_task,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p));
+
+DECLARE_HOOK(android_vh_hmbird_update_load_enable,
+	TP_PROTO(bool enable),
+	TP_ARGS(enable));
+
+/* get task or cpu's util based on the provided parameters. */
+DECLARE_HOOK(android_vh_get_util,
+	TP_PROTO(int cpu, struct task_struct *p, u64 *util),
+	TP_ARGS(cpu, p, util));
 
 struct cgroup_subsys_state;
 DECLARE_HOOK(android_vh_sched_move_task,
@@ -484,6 +500,30 @@ DECLARE_HOOK(android_vh_set_task_comm,
 	TP_PROTO(struct task_struct *p),
 	TP_ARGS(p));
 
+DECLARE_HOOK(android_vh_scx_select_cpu_dfl,
+	TP_PROTO(struct task_struct *p, s32 *cpu),
+	TP_ARGS(p, cpu));
+
+DECLARE_HOOK(android_vh_scx_update_task_scale_time,
+	TP_PROTO(struct task_struct *p, u16 *demand_scale),
+	TP_ARGS(p, demand_scale));
+
+DECLARE_HOOK(android_vh_check_preempt_curr_scx,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int wake_flags, int *check_result),
+	TP_ARGS(rq, p, wake_flags, check_result));
+
+DECLARE_HOOK(android_vh_task_fits_cpu_scx,
+	TP_PROTO(struct task_struct *p, int cpu, int *fitable),
+	TP_ARGS(p, cpu, fitable));
+
+DECLARE_HOOK(android_vh_scx_cpu_exclusive,
+	TP_PROTO(int cpu, int *exclusive),
+	TP_ARGS(cpu, exclusive));
+
+DECLARE_HOOK(android_vh_scx_consume_dsq_allowed,
+	TP_PROTO(struct rq *rq, struct rq_flags *rf, int dsq_type, int *allowed),
+	TP_ARGS(rq, rf, dsq_type, allowed));
+
 #endif /* _TRACE_HOOK_SCHED_H */
 /* This part must be outside protection */
 #include <trace/define_trace.h>
diff --git a/include/uapi/linux/sched.h b/include/uapi/linux/sched.h
old mode 100755
new mode 100644
diff --git a/init/init_task.c b/init/init_task.c
old mode 100755
new mode 100644
index 69a046388995d..adb7042fd9239
--- a/init/init_task.c
+++ b/init/init_task.c
@@ -103,7 +103,7 @@ struct task_struct init_task
 #ifdef CONFIG_CGROUP_SCHED
 	.sched_task_group = &root_task_group,
 #endif
-#ifdef CONFIG_SLIM_SCHED
+#ifdef CONFIG_HMBIRD_SCHED
 	.scx		= NULL,
 #endif
 	.ptraced	= LIST_HEAD_INIT(init_task.ptraced),
diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index cf22ef6107b81..b131d5662b483 100755
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -133,12 +133,8 @@ config SCHED_CORE
 	  which is the likely usage by Linux distributions, there should
 	  be no measurable impact on performance.
 
-config SLIM_SCHED
-	bool "slim sched"
-	default n
-config SCHED_CLASS_EXT
-	bool "Extensible Scheduling Class"
-	depends on BPF_SYSCALL && BPF_JIT
+config HMBIRD_SCHED
+	bool "hmbird Scheduling Class(base on ext scheduler)"
 	help
 	  This option enables a new scheduler class sched_ext (SCX), which
 	  allows scheduling policies to be implemented as BPF programs to
@@ -159,3 +155,10 @@ config SCHED_CLASS_EXT
 	  similar to struct sched_class.
 
 	  See Documentation/scheduler/sched-ext.rst for more details.
+
+config DYNAMIC_WALT_SUPPORT
+	bool "Dynamic WALT Support for Extensible Scheduling Class"
+	depends on HMBIRD_SCHED
+	default n
+	help
+	  Enable dynamic WALT support for Extensible Scheduling Class.
diff --git a/kernel/bpf/bpf_struct_ops_types.h b/kernel/bpf/bpf_struct_ops_types.h
index 3618769d853d0..5678a9ddf8178 100644
--- a/kernel/bpf/bpf_struct_ops_types.h
+++ b/kernel/bpf/bpf_struct_ops_types.h
@@ -9,8 +9,4 @@ BPF_STRUCT_OPS_TYPE(bpf_dummy_ops)
 #include <net/tcp.h>
 BPF_STRUCT_OPS_TYPE(tcp_congestion_ops)
 #endif
-#ifdef CONFIG_SCHED_CLASS_EXT
-#include <linux/sched/ext.h>
-BPF_STRUCT_OPS_TYPE(sched_ext_ops)
-#endif
 #endif
diff --git a/kernel/fork.c b/kernel/fork.c
old mode 100755
new mode 100644
diff --git a/kernel/sched/build_policy.c b/kernel/sched/build_policy.c
old mode 100755
new mode 100644
index 657be1a5829d9..1807cc8754e9a
--- a/kernel/sched/build_policy.c
+++ b/kernel/sched/build_policy.c
@@ -54,11 +54,11 @@
 #include "cputime.c"
 #include "deadline.c"
 
-#ifdef CONFIG_SCHED_CLASS_EXT
+#include "hmbird_export.c"
+#ifdef CONFIG_HMBIRD_SCHED
+#include "slim_sysctl.c"
 # include "ext.c"
 # include "hmbird_sched_proc_main.c"
 #endif
 
-#ifdef CONFIG_SLIM_SCHED
-# include "slim_sysctl.c"
-#endif
+
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 25d5703df9924..82ed241d89715 100755
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -96,6 +96,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include "slim.h"
+#endif
+
 #include <trace/hooks/sched.h>
 #include <trace/hooks/cgroup.h>
 #include <trace/hooks/dtask.h>
@@ -183,11 +187,10 @@ static inline int __task_prio(const struct task_struct *p)
 	if (p->sched_class == &idle_sched_class)
 		return MAX_RT_PRIO + NICE_WIDTH; /* 140 */
 
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 	if (p->sched_class == &ext_sched_class)
 		return MAX_RT_PRIO + MAX_NICE + 1; /* 120, squash ext */
 #endif
-
 	return MAX_RT_PRIO + MAX_NICE; /* 119, squash fair */
 }
 
@@ -217,7 +220,7 @@ static inline bool prio_less(const struct task_struct *a,
 	if (pa == MAX_RT_PRIO + MAX_NICE)	/* fair */
 		return cfs_prio_less(a, b, in_fi);
 
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 	if (pa == MAX_RT_PRIO + MAX_NICE + 1)	/* ext */
 		return scx_prio_less(a, b, in_fi);
 #endif
@@ -1279,13 +1282,26 @@ bool sched_can_stop_tick(struct rq *rq)
 	if (fifo_nr_running)
 		return true;
 
+#ifdef CONFIG_HMBIRD_SCHED
+	/*
+	 * If there are no DL,RR/FIFO tasks, there must only be CFS or SCX tasks
+	 * left. For CFS, if there's more than one we need the tick for
+	 * involuntary preemption. For SCX, ask.
+	 */
+	if (!scx_enabled() && rq->nr_running > 1)
+		return false;
+
+	if (scx_enabled() && !scx_can_stop_tick(rq))
+		return false;
+#else
 	/*
 	 * If there are no DL,RR/FIFO tasks, there must only be CFS or SCX tasks
 	 * left. For CFS, if there's more than one we need the tick for
 	 * involuntary preemption. For SCX, ask.
 	 */
-	if (!scx_switched_all() && rq->nr_running > 1)
+	if (!scx_enabled() && rq->nr_running > 1)
 		return false;
+#endif
 
 	if (scx_enabled() && !scx_can_stop_tick(rq))
 		return false;
@@ -2222,6 +2238,7 @@ void deactivate_task(struct rq *rq, struct task_struct *p, int flags)
 }
 EXPORT_SYMBOL_GPL(deactivate_task);
 
+#ifdef CONFIG_HMBIRD_SCHED
 struct sched_change_guard
 sched_change_guard_init(struct rq *rq, struct task_struct *p, int flags)
 {
@@ -2255,6 +2272,7 @@ void sched_change_guard_fini(struct sched_change_guard *cg, int flags)
 		set_next_task(cg->rq, cg->p);
 	cg->done = true;
 }
+#endif
 
 static inline int __normal_prio(int policy, int rt_prio, int nice)
 {
@@ -3772,7 +3790,11 @@ int select_task_rq(struct task_struct *p, int cpu, int wake_flags)
 	 * [ this allows ->select_task() to simply return task_cpu(p) and
 	 *   not worry about this generic constraint ]
 	 */
+#ifdef CONFIG_HMBIRD_SCHED
+	if (unlikely(!is_cpu_allowed(p, cpu)) && (p->sched_class != &ext_sched_class))
+#else
 	if (unlikely(!is_cpu_allowed(p, cpu)))
+#endif
 		cpu = select_fallback_rq(task_cpu(p), p);
 
 	return cpu;
@@ -4938,7 +4960,7 @@ int sched_fork(unsigned long clone_flags, struct task_struct *p)
 	if (dl_prio(p->prio)) {
 		ret = -EAGAIN;
 		goto out_cancel;
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 	} else if (task_on_scx(p)) {
 		p->sched_class = &ext_sched_class;
 #endif
@@ -5002,16 +5024,19 @@ int sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs)
 	return scx_fork(p);
 }
 
+#ifdef CONFIG_HMBIRD_SCHED
 void sched_cancel_fork(struct task_struct *p)
 {
 	scx_cancel_fork(p);
 }
+#endif
 
 void sched_post_fork(struct task_struct *p)
 {
 	uclamp_post_fork(p);
-
+#ifdef CONFIG_HMBIRD_SCHED
 	scx_post_fork(p);
+#endif
 }
 
 unsigned long to_ratio(u64 period, u64 runtime)
@@ -5875,18 +5900,23 @@ void scheduler_tick(void)
 
 	if (sched_feat(LATENCY_WARN) && resched_latency)
 		resched_latency_warn(cpu, resched_latency);
-
+#ifdef CONFIG_HMBIRD_SCHED
 	scx_notify_sched_tick();
+#endif
 	perf_event_task_tick();
 
 	if (curr->flags & PF_WQ_WORKER)
 		wq_worker_tick(curr);
 
 #ifdef CONFIG_SMP
-	if (!scx_switched_all()) {
+#ifdef CONFIG_HMBIRD_SCHED
+	if (!scx_enabled()) {
+#endif
 		rq->idle_balance = idle_cpu(cpu);
 		trigger_load_balance(rq);
+#ifdef CONFIG_HMBIRD_SCHED
 	}
+#endif
 #endif
 	trace_android_vh_scheduler_tick(rq);
 
@@ -6191,7 +6221,11 @@ static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,
 	 * We can terminate the balance pass as soon as we know there is
 	 * a runnable task of @class priority or higher.
 	 */
+#ifdef CONFIG_HMBIRD_SCHED
 	for_balance_class_range(class, prev->sched_class, &idle_sched_class) {
+#else
+	for_class_range(class, prev->sched_class, &idle_sched_class) {
+#endif
 		if (class->balance(rq, prev, rf))
 			break;
 	}
@@ -6237,6 +6271,7 @@ __pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 restart:
 	put_prev_task_balance(rq, prev, rf);
 
+#ifdef CONFIG_HMBIRD_SCHED
 	for_each_active_class(class) {
 		p = class->pick_next_task(rq);
 		if (p) {
@@ -6244,6 +6279,15 @@ __pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 			return p;
 		}
 	}
+#else
+	for_each_class(class) {
+		p = class->pick_next_task(rq);
+		if (p) {
+			scx_notify_pick_next_task(rq, p, class);
+			return p;
+		}
+	}
+#endif
 
 	BUG(); /* The idle class should always have a runnable task. */
 }
@@ -6271,8 +6315,11 @@ static inline struct task_struct *pick_task(struct rq *rq)
 {
 	const struct sched_class *class;
 	struct task_struct *p;
-
+#ifdef CONFIG_HMBIRD_SCHED
 	for_each_active_class(class) {
+#else
+	for_each_class(class) {
+#endif
 		p = class->pick_task(rq);
 		if (p)
 			return p;
@@ -7246,22 +7293,29 @@ EXPORT_SYMBOL(default_wake_function);
 
 void __setscheduler_prio(struct task_struct *p, int prio)
 {
-	/*
-	 * After switching all rt and fair class to ext,
-	 * stop class is switched to ext class too. Just
-	 * skip it. */
+#ifdef CONFIG_HMBIRD_SCHED
+	bool on_scx = task_on_scx(p);
+
 	if (p->sched_class == &stop_sched_class)
-		;/* do nothing */
+		;
 	else if (dl_prio(prio))
 		p->sched_class = &dl_sched_class;
-#ifdef CONFIG_SCHED_CLASS_EXT
-	else if (task_on_scx(p))
+	else if (rt_prio(prio) && on_scx && !reject_change_to_scx(p, prio))
 		p->sched_class = &ext_sched_class;
-#endif
 	else if (rt_prio(prio))
 		p->sched_class = &rt_sched_class;
+	else if (on_scx)
+		p->sched_class = &ext_sched_class;
 	else
 		p->sched_class = &fair_sched_class;
+#else
+	if (dl_prio(prio))
+		p->sched_class = &dl_sched_class;
+	else if (rt_prio(prio))
+		p->sched_class = &rt_sched_class;
+	else
+		p->sched_class = &fair_sched_class;
+#endif
 
 	p->prio = prio;
 	trace_android_rvh_setscheduler_prio(p);
@@ -7876,6 +7930,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	int queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
 	struct rq *rq;
 	bool cpuset_locked = false;
+#ifdef CONFIG_HMBIRD_SCHED
+	unsigned long flags;
+#endif
 
 
 	/* The pi code expects interrupts enabled */
@@ -7942,7 +7999,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	 * To be able to change p->policy safely, the appropriate
 	 * runqueue lock must be held.
 	 */
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_lock_irqsave(&scx_tasks_lock, flags);
+#endif
 	rq = task_rq_lock(p, &rf);
 	update_rq_clock(rq);
 
@@ -7954,10 +8013,11 @@ static int __sched_setscheduler(struct task_struct *p,
 		goto unlock;
 	}
 
+#ifdef CONFIG_HMBIRD_SCHED
 	retval = scx_check_setscheduler(p, policy);
 	if (retval)
 		goto unlock;
-
+#endif
 	/*
 	 * If not changing anything there's no need to proceed further,
 	 * but store a possible modification of reset_on_fork.
@@ -8014,7 +8074,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
 		policy = oldpolicy = -1;
 		task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+		spin_unlock_irqrestore(&scx_tasks_lock, flags);
+#endif
 		if (cpuset_locked)
 			cpuset_unlock();
 		goto recheck;
@@ -8072,7 +8134,9 @@ static int __sched_setscheduler(struct task_struct *p,
 	preempt_disable();
 	head = splice_balance_callbacks(rq);
 	task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_unlock_irqrestore(&scx_tasks_lock, flags);
+#endif
 	if (pi) {
 		if (cpuset_locked)
 			cpuset_unlock();
@@ -8087,7 +8151,9 @@ static int __sched_setscheduler(struct task_struct *p,
 
 unlock:
 	task_rq_unlock(rq, p, &rf);
-
+#ifdef CONFIG_HMBIRD_SCHED
+	spin_unlock_irqrestore(&scx_tasks_lock, flags);
+#endif
 	if (cpuset_locked)
 		cpuset_unlock();
 	return retval;
@@ -9309,7 +9375,9 @@ SYSCALL_DEFINE1(sched_get_priority_max, int, policy)
 	case SCHED_NORMAL:
 	case SCHED_BATCH:
 	case SCHED_IDLE:
+#ifdef CONFIG_HMBIRD_SCHED
 	case SCHED_EXT:
+#endif
 		ret = 0;
 		break;
 	}
@@ -9337,7 +9405,9 @@ SYSCALL_DEFINE1(sched_get_priority_min, int, policy)
 	case SCHED_NORMAL:
 	case SCHED_BATCH:
 	case SCHED_IDLE:
+#ifdef CONFIG_HMBIRD_SCHED
 	case SCHED_EXT:
+#endif
 		ret = 0;
 	}
 	return ret;
@@ -10212,17 +10282,21 @@ void __init sched_init(void)
 	int i;
 
 	/* Make sure the linker didn't screw up */
+#ifdef CONFIG_HMBIRD_SCHED
 #ifdef CONFIG_SMP
-	BUG_ON(!sched_class_above(&stop_sched_class, &dl_sched_class));
-#endif
-	BUG_ON(!sched_class_above(&dl_sched_class, &rt_sched_class));
-	BUG_ON(!sched_class_above(&rt_sched_class, &fair_sched_class));
-	BUG_ON(!sched_class_above(&fair_sched_class, &idle_sched_class));
-#ifdef CONFIG_SCHED_CLASS_EXT
-	BUG_ON(!sched_class_above(&fair_sched_class, &ext_sched_class));
-	BUG_ON(!sched_class_above(&ext_sched_class, &idle_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&stop_sched_class, &dl_sched_class));
 #endif
+	WARN_ON_ONCE(!sched_class_above(&dl_sched_class, &rt_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&rt_sched_class, &fair_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&fair_sched_class, &idle_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&fair_sched_class, &ext_sched_class));
+	WARN_ON_ONCE(!sched_class_above(&ext_sched_class, &idle_sched_class));
+#else
+	BUG_ON(&idle_sched_class != &fair_sched_class + 1 ||
+	       &fair_sched_class != &rt_sched_class + 1 ||
+	       &rt_sched_class   != &dl_sched_class + 1);
 
+#endif
 	wait_bit_init();
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
@@ -10392,8 +10466,9 @@ void __init sched_init(void)
 	balance_push_set(smp_processor_id(), false);
 #endif
 	init_sched_fair_class();
+#ifdef CONFIG_HMBIRD_SCHED
 	init_sched_ext_class();
-
+#endif
 	psi_init();
 
 	init_uclamp();
@@ -10862,6 +10937,13 @@ static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)
 {
 	struct task_group *tg = css_tg(css);
 	struct task_group *parent = css_tg(css->parent);
+#ifdef CONFIG_HMBIRD_SCHED
+	int ret;
+
+	ret = scx_tg_online(tg);
+	if (ret)
+		return ret;
+#endif
 
 	if (parent)
 		sched_online_group(tg, parent);
@@ -10912,13 +10994,67 @@ static int cpu_cgroup_can_attach(struct cgroup_taskset *tset)
 }
 #endif
 
+#ifdef CONFIG_HMBIRD_SCHED
+static int cgroup_write_scx_deadline(struct cgroup_subsys_state *css,
+					  struct cftype *cftype, u64 dl)
+{
+	struct task_group *tg;
+	int i;
+
+	for (i = MIN_CGROUP_DL_IDX; i < MAX_GLOBAL_DSQS; ++i) {
+		if (dl < SCX_BPF_DSQS_DEADLINE[i])
+			break;
+	}
+
+	i = max_t(int, i-1, MIN_CGROUP_DL_IDX);
+
+	tg = css_tg(css);
+	tg->scx_deadline_idx = i;
+
+	return 0;
+}
+
+static u64 cgroup_read_scx_deadline(struct cgroup_subsys_state *css,
+					  struct cftype *cft)
+{
+	struct task_group *tg = css_tg(css);
+	int i;
+
+	i = min_t(int, tg->scx_deadline_idx, MAX_GLOBAL_DSQS-1);
+	if (i < 0) {
+		pr_err("<sched_ext> <cgroup_read_scx_deadline> i is %d, less than 0, name is %s\n",
+			i, css->cgroup->kn->name);
+		i = DEFAULT_CGROUP_DL_IDX;
+	}
+
+	return (u64) SCX_BPF_DSQS_DEADLINE[i];
+}
+
+static void scx_change_rt_sched_prop(struct cgroup_subsys_state *css, struct task_struct *p, int prio)
+{
+	if (!css || !rt_prio(prio))
+		return;
+
+	if (!(p->scx->sched_prop & SCHED_PROP_DEADLINE_MASK)) {
+		if (!strcmp(css->cgroup->kn->name, "display"))
+			sched_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL3);
+		else if (!strcmp(css->cgroup->kn->name, "touch"))
+			sched_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL2);
+		else if (!strcmp(css->cgroup->kn->name, "multimedia"))
+			sched_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL1);
+	}
+}
+#endif
+
 static void cpu_cgroup_attach(struct cgroup_taskset *tset)
 {
 	struct task_struct *task;
 	struct cgroup_subsys_state *css;
 
 	cgroup_taskset_for_each(task, css, tset) {
-
+#ifdef CONFIG_HMBIRD_SCHED
+		scx_change_rt_sched_prop(css, task, task->prio);
+#endif
 		sched_move_task(task);
 	}
 
@@ -11600,7 +11736,13 @@ static struct cftype cpu_legacy_files[] = {
 		.write_u64 = cpu_uclamp_ls_write_u64,
 	},
 #endif
-
+#ifdef CONFIG_HMBIRD_SCHED
+	{
+		.name = "scx.deadline",
+		.read_u64 = cgroup_read_scx_deadline,
+		.write_u64 = cgroup_write_scx_deadline,
+	},
+#endif
 	{ }	/* Terminate */
 };
 
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
old mode 100755
new mode 100644
index a6c99df9edf94..9a8148787fab0
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -376,7 +376,7 @@ static __init int sched_init_debug(void)
 
 	debugfs_create_file("debug", 0444, debugfs_sched, NULL, &sched_debug_fops);
 
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 	debugfs_create_file("ext", 0444, debugfs_sched, NULL, &sched_ext_fops);
 #endif
 	return 0;
@@ -1006,7 +1006,7 @@ void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 	SEQ_printf(m,
 		"---------------------------------------------------------"
 		"----------\n");
-#ifdef CONFIG_SLIM_SCHED
+#ifdef CONFIG_HMBIRD_SCHED
 	SEQ_printf(m, "p->sched_prop:0x%lx\n", p->sched_prop);
 #endif
 
@@ -1104,7 +1104,7 @@ void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 	} else if (fair_policy(p->policy)) {
 		P(se.slice);
 	}
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 	__PS("ext.enabled", p->sched_class == &ext_sched_class);
 #endif
 #undef PN_SCHEDSTAT
diff --git a/kernel/sched/ext.c b/kernel/sched/ext.c
index 4845d441df2b0..82bba65a99184 100755
--- a/kernel/sched/ext.c
+++ b/kernel/sched/ext.c
@@ -6,12 +6,20 @@
  * Copyright (c) 2022 Tejun Heo <tj@kernel.org>
  * Copyright (c) 2022 David Vernet <dvernet@meta.com>
  */
-#define SCX_OP_IDX(op)		(offsetof(struct sched_ext_ops, op) / sizeof(void (*)(void)))
+
+#include "slim.h"
+#define CLUSTER_SEPARATE
+
+enum task_event {
+	PUT_PREV_TASK   = 0,
+	PICK_NEXT_TASK  = 1,
+	TASK_WAKE       = 2,
+	TASK_MIGRATE    = 3,
+	TASK_UPDATE     = 4,
+	IRQ_UPDATE      = 5,
+};
 
 enum scx_internal_consts {
-	SCX_NR_ONLINE_OPS	= SCX_OP_IDX(init),
-	SCX_DSP_DFL_MAX_BATCH	= 32,
-	SCX_DSP_MAX_LOOPS	= 32,
 	SCX_WATCHDOG_MAX_TIMEOUT = 30 * HZ,
 };
 
@@ -66,38 +74,34 @@ enum scx_ops_state {
 	SCX_OPSS_QSEQ_MASK	= ~SCX_OPSS_STATE_MASK,
 };
 
+enum switch_stat {
+	SCX_DISABLED,
+	SCX_SWITCH_PREP,
+	SCX_RQ_SWITCH_BEGIN,
+	SCX_RQ_SWITCH_DONE,
+	SCX_ENABLED,
+};
+enum switch_stat curr_ss;
+
 /*
  * During exit, a task may schedule after losing its PIDs. When disabling the
  * BPF scheduler, we need to be able to iterate tasks in every state to
  * guarantee system safety. Maintain a dedicated task list which contains every
  * task between its fork and eventual free.
  */
-static DEFINE_SPINLOCK(scx_tasks_lock);
+DEFINE_SPINLOCK(scx_tasks_lock);
 static LIST_HEAD(scx_tasks);
 
 /* ops enable/disable */
 static struct kthread_worker *scx_ops_helper;
 static DEFINE_MUTEX(scx_ops_enable_mutex);
-DEFINE_STATIC_KEY_FALSE(__scx_ops_enabled);
 DEFINE_STATIC_PERCPU_RWSEM(scx_fork_rwsem);
 static atomic_t scx_ops_enable_state_var = ATOMIC_INIT(SCX_OPS_DISABLED);
-static bool scx_switch_all_req;
-static bool scx_switching_all;
-DEFINE_STATIC_KEY_FALSE(__scx_switched_all);
+static atomic_t set_sched_clock_prepare;
 
-static struct sched_ext_ops scx_ops;
 static bool scx_warned_zero_slice;
 
-static DEFINE_STATIC_KEY_FALSE(scx_ops_enq_last);
-static DEFINE_STATIC_KEY_FALSE(scx_ops_enq_exiting);
 DEFINE_STATIC_KEY_FALSE(scx_ops_cpu_preempt);
-static DEFINE_STATIC_KEY_FALSE(scx_builtin_idle_enabled);
-
-struct static_key_false scx_has_op[SCX_NR_ONLINE_OPS] =
-	{ [0 ... SCX_NR_ONLINE_OPS-1] = STATIC_KEY_FALSE_INIT };
-
-static atomic_t scx_exit_type = ATOMIC_INIT(SCX_EXIT_DONE);
-static struct scx_exit_info scx_exit_info;
 
 static atomic64_t scx_nr_rejected = ATOMIC64_INIT(0);
 
@@ -134,3845 +138,3294 @@ static struct {
 static bool __cacheline_aligned_in_smp scx_has_idle_cpus;
 #endif	/* CONFIG_SMP */
 
-/* for %SCX_KICK_WAIT */
-static u64 __percpu *scx_kick_cpus_pnt_seqs;
-
-/*
- * Direct dispatch marker.
- *
- * Non-NULL values are used for direct dispatch from enqueue path. A valid
- * pointer points to the task currently being enqueued. An ERR_PTR value is used
- * to indicate that direct dispatch has already happened.
- */
-static DEFINE_PER_CPU(struct task_struct *, direct_dispatch_task);
-
 /* dispatch queues */
 static struct scx_dispatch_q __cacheline_aligned_in_smp scx_dsq_global;
 
-static LLIST_HEAD(dsqs_to_free);
+u32 SCX_BPF_DSQS_DEADLINE[MAX_GLOBAL_DSQS] = {0, 1, 2, 4, 6, 8, 16, 32, 64, 128};
+u32 pcp_dsq_deadline = 20;
+static struct scx_dispatch_q __cacheline_aligned_in_smp gdsqs[MAX_GLOBAL_DSQS];
+static DEFINE_PER_CPU(struct scx_dispatch_q, pcp_ldsq);
+
+static u64 max_ext_dsq_internal_id;
+
+/* a dsq idx, whether task push to little domain cpu or bit domain cpu*/
+#define CLUSTER_SEPARATE_IDX	(8)
+#define GDSQS_ID_BASE		(3)
+#define RT_DSQ_IDX		(0)
+#define NON_PERIOD_START	(5)
+#define NON_PERIOD_END		(MAX_GLOBAL_DSQS)
+#define CREATE_DSQ_LEVEL_WITHIN	(1)
+
+struct hmbird_sched_info {
+	spinlock_t lock;
+	int curr_idx[2];
+	int rtime[MAX_GLOBAL_DSQS];
+};
 
-/* dispatch buf */
-struct scx_dsp_buf_ent {
-	struct task_struct	*task;
-	u64			qseq;
-	u64			dsq_id;
-	u64			enq_flags;
+struct pcp_sched_info {
+	s64 pcp_seq;
+	int rtime;
+	bool pcp_round;
 };
 
-static u32 scx_dsp_max_batch;
-static struct scx_dsp_buf_ent __percpu *scx_dsp_buf;
+/*
+ * pcp_info may rw by another cpu.
+ * protected by rq->lock.
+ */
+atomic64_t pcp_dsq_round;
+static DEFINE_PER_CPU(struct pcp_sched_info, pcp_info);
+
+static struct hmbird_sched_info sinfo;
+
+static unsigned long pcp_dsq_quota __read_mostly = 3 * NSEC_PER_MSEC;
+static unsigned long dsq_quota[MAX_GLOBAL_DSQS] = {
+					0, 0, 0, 0, 0,
+					32 * NSEC_PER_MSEC,
+					20 * NSEC_PER_MSEC,
+					14 * NSEC_PER_MSEC,
+					8 * NSEC_PER_MSEC,
+					6 * NSEC_PER_MSEC
+};
 
-struct scx_dsp_ctx {
-	struct rq		*rq;
-	struct rq_flags		*rf;
-	u32			buf_cursor;
-	u32			nr_tasks;
+struct cluster_ctx {
+        /* cpu-dsq map must within [lower, upper) */
+	int upper;
+	int lower;
+	int tidx;
 };
 
-static DEFINE_PER_CPU(struct scx_dsp_ctx, scx_dsp_ctx);
+enum stat_items {
+	GLOBAL_STAT,
+	CPU_ALLOW_FAIL,
+	RT_CNT,
+	KEY_TASK_CNT,
+	SWITCH_IDX,
+	TIMEOUT_CNT,
 
-void scx_bpf_dispatch(struct task_struct *p, u64 dsq_id, u64 slice,
-		      u64 enq_flags);
-void scx_bpf_kick_cpu(s32 cpu, u64 flags);
+	TOTAL_DSP_CNT,
+	MOVE_RQ_CNT,
 
-struct scx_task_iter {
-	struct sched_ext_entity		cursor;
-	struct task_struct		*locked;
-	struct rq			*rq;
-	struct rq_flags			rf;
+	DWORD_STAT_END = MOVE_RQ_CNT,
+
+	GDSQ_CNT,
+	ERR_IDX,
+	PCP_TIMEOUT_CNT,
+	PCP_LDSQ_CNT,
+	PCP_ENQL_CNT,
+
+	MAX_ITEMS,
+};
+static DEFINE_SPINLOCK(stats_lock);
+static char *stats_str[MAX_ITEMS] = {
+	"global stat", "cpu_allow_fail", "rt_cnt", "key_task_cnt",
+	"switch_idx", "timeout_cnt", "total_dsp_cnt", "move_rq_cnt",
+	"gdsq_cnt", "err_idx", "pcp_timeout_cnt", "pcp_ldsq_cnt",
+	"pcp_enql_cnt"
 };
 
-#define SCX_HAS_OP(op)	static_branch_likely(&scx_has_op[SCX_OP_IDX(op)])
 
-/* if the highest set bit is N, return a mask with bits [N+1, 31] set */
-static u32 higher_bits(u32 flags)
-{
-	return ~((1 << fls(flags)) - 1);
-}
+struct stats_struct {
+	u64 global_stat[2];
+	u64 cpu_allow_fail[2];
+	u64 rt_cnt[2];
+	u64 key_task_cnt[2];
+	u64 switch_idx[2];
+	u64 timeout_cnt[2];
 
-/* return the mask with only the highest bit set */
-static u32 highest_bit(u32 flags)
-{
-	int bit = fls(flags);
-	return bit ? 1 << (bit - 1) : 0;
-}
+	/* for compatible, only use [0] */
+	u64 total_dsp_cnt[2];
+	u64 move_rq_cnt[2];
 
-/*
- * scx_kf_mask enforcement. Some kfuncs can only be called from specific SCX
- * ops. When invoking SCX ops, SCX_CALL_OP[_RET]() should be used to indicate
- * the allowed kfuncs and those kfuncs should use scx_kf_allowed() to check
- * whether it's running from an allowed context.
- *
- * @mask is constant, always inline to cull the mask calculations.
- */
-static __always_inline void scx_kf_allow(u32 mask)
-{
-	/* nesting is allowed only in increasing scx_kf_mask order */
-	WARN_ONCE((mask | higher_bits(mask)) & current->scx->kf_mask,
-		  "invalid nesting current->scx->kf_mask=0x%x mask=0x%x\n",
-		  current->scx->kf_mask, mask);
-	current->scx->kf_mask |= mask;
-}
-
-static void scx_kf_disallow(u32 mask)
-{
-	current->scx->kf_mask &= ~mask;
-}
-
-#define SCX_CALL_OP(mask, op, args...)						\
-do {										\
-	if (mask) {								\
-		scx_kf_allow(mask);						\
-		scx_ops.op(args);						\
-		scx_kf_disallow(mask);						\
-	} else {								\
-		scx_ops.op(args);						\
-	}									\
-} while (0)
-
-#define SCX_CALL_OP_RET(mask, op, args...)					\
-({										\
-	__typeof__(scx_ops.op(args)) __ret;					\
-	if (mask) {								\
-		scx_kf_allow(mask);						\
-		__ret = scx_ops.op(args);					\
-		scx_kf_disallow(mask);						\
-	} else {								\
-		__ret = scx_ops.op(args);					\
-	}									\
-	__ret;									\
-})
+	u64 gdsq_count[MAX_GLOBAL_DSQS][2];
+	u64 err_idx[5];
+	u64 pcp_timeout_cnt[NR_CPUS];
+	u64 pcp_ldsq_count[NR_CPUS][2];
+	u64 pcp_enql_cnt[NR_CPUS];
+} stats_data;
 
-/*
- * Some kfuncs are allowed only on the tasks that are subjects of the
- * in-progress scx_ops operation for, e.g., locking guarantees. To enforce such
- * restrictions, the following SCX_CALL_OP_*() variants should be used when
- * invoking scx_ops operations that take task arguments. These can only be used
- * for non-nesting operations due to the way the tasks are tracked.
- *
- * kfuncs which can only operate on such tasks can in turn use
- * scx_kf_allowed_on_arg_tasks() to test whether the invocation is allowed on
- * the specific task.
- */
-#define SCX_CALL_OP_TASK(mask, op, task, args...)				\
-do {										\
-	BUILD_BUG_ON(mask & ~__SCX_KF_TERMINAL);				\
-	current->scx->kf_tasks[0] = task;					\
-	SCX_CALL_OP(mask, op, task, ##args);					\
-	current->scx->kf_tasks[0] = NULL;					\
-} while (0)
-
-#define SCX_CALL_OP_TASK_RET(mask, op, task, args...)				\
-({										\
-	__typeof__(scx_ops.op(task, ##args)) __ret;				\
-	BUILD_BUG_ON(mask & ~__SCX_KF_TERMINAL);				\
-	current->scx->kf_tasks[0] = task;					\
-	__ret = SCX_CALL_OP_RET(mask, op, task, ##args);			\
-	current->scx->kf_tasks[0] = NULL;					\
-	__ret;									\
-})
-
-#define SCX_CALL_OP_2TASKS_RET(mask, op, task0, task1, args...)			\
-({										\
-	__typeof__(scx_ops.op(task0, task1, ##args)) __ret;			\
-	BUILD_BUG_ON(mask & ~__SCX_KF_TERMINAL);				\
-	current->scx->kf_tasks[0] = task0;					\
-	current->scx->kf_tasks[1] = task1;					\
-	__ret = SCX_CALL_OP_RET(mask, op, task0, task1, ##args);		\
-	current->scx->kf_tasks[0] = NULL;					\
-	current->scx->kf_tasks[1] = NULL;					\
-	__ret;									\
-})
-
-//#include "./slim_walt.c"
-
-/* @mask is constant, always inline to cull unnecessary branches */
-static __always_inline bool scx_kf_allowed(u32 mask)
-{
-	if (unlikely(!(current->scx->kf_mask & mask))) {
-		scx_ops_error("kfunc with mask 0x%x called from an operation only allowing 0x%x",
-			      mask, current->scx->kf_mask);
-		return false;
-	}
 
-	if (unlikely((mask & (SCX_KF_INIT | SCX_KF_SLEEPABLE)) &&
-		     in_interrupt())) {
-		scx_ops_error("sleepable kfunc called from non-sleepable context");
-		return false;
-	}
+static void slim_stats_record(enum stat_items item, int idx, int dsq_id, int cpu)
+{
+	unsigned long flags;
+	u64 *pval;
+	u64 *pbase = (u64*)&stats_data;
 
-	/*
-	 * Enforce nesting boundaries. e.g. A kfunc which can be called from
-	 * DISPATCH must not be called if we're running DEQUEUE which is nested
-	 * inside ops.dispatch(). We don't need to check the SCX_KF_SLEEPABLE
-	 * boundary thanks to the above in_interrupt() check.
-	 */
-	if (unlikely(highest_bit(mask) == SCX_KF_CPU_RELEASE &&
-		     (current->scx->kf_mask & higher_bits(SCX_KF_CPU_RELEASE)))) {
-		scx_ops_error("cpu_release kfunc called from a nested operation");
-		return false;
-	}
+	if (!slim_stats)
+		return;
 
-	if (unlikely(highest_bit(mask) == SCX_KF_DISPATCH &&
-		     (current->scx->kf_mask & higher_bits(SCX_KF_DISPATCH)))) {
-		scx_ops_error("dispatch kfunc called from a nested operation");
-		return false;
+	switch (item) {
+	case GLOBAL_STAT:
+		fallthrough;
+	case CPU_ALLOW_FAIL:
+		fallthrough;
+	case RT_CNT:
+		fallthrough;
+	case KEY_TASK_CNT:
+		fallthrough;
+	case SWITCH_IDX:
+		fallthrough;
+	case TIMEOUT_CNT:
+		fallthrough;
+	case TOTAL_DSP_CNT:
+		fallthrough;
+	case MOVE_RQ_CNT:
+		pval = pbase + item * 2 + idx;
+		break;
+	case GDSQ_CNT:
+		pval = &stats_data.gdsq_count[dsq_id][idx];
+		break;
+	case ERR_IDX:
+		pval = &stats_data.err_idx[idx];
+		break;
+	case PCP_TIMEOUT_CNT:
+		pval = &stats_data.pcp_timeout_cnt[cpu];
+		break;
+	case PCP_LDSQ_CNT:
+		pval = &stats_data.pcp_ldsq_count[cpu][idx];
+		break;
+	case PCP_ENQL_CNT:
+		pval = &stats_data.pcp_enql_cnt[cpu];
+		break;
+	default:
+		return;
 	}
 
-	return true;
+	spin_lock_irqsave(&stats_lock, flags);
+	*pval += 1;
+	spin_unlock_irqrestore(&stats_lock, flags);
 }
 
-/* see SCX_CALL_OP_TASK() */
-static __always_inline bool scx_kf_allowed_on_arg_tasks(u32 mask,
-							struct task_struct *p)
+#define PRINT_INTV	(5 * HZ)
+void stats_print(char *buf, int len)
 {
-	if (!scx_kf_allowed(__SCX_KF_RQ_LOCKED))
-		return false;
+	int idx = 0, j, ret;
+	int item = 0;
+	u64 *pval;
+	u64 *pbase = (u64*)&stats_data;
 
-	if (unlikely((p != current->scx->kf_tasks[0] &&
-		      p != current->scx->kf_tasks[1]))) {
-		scx_ops_error("called on a task not being operated on");
-		return false;
-	}
 
-	return true;
+	for (item = 0; item < MAX_ITEMS; item++) {
+		if (item <= DWORD_STAT_END) {
+			pval = pbase + item * 2;
+			ret = snprintf(&buf[idx], len - idx, "%s:%llu, %llu\n",
+					stats_str[item], pval[0],  pval[1]);
+			if (ret < 0 || ret >= len - idx)
+				return;
+			idx += ret;
+		} else if (GDSQ_CNT == item) {
+			for (j = 0; j < MAX_GLOBAL_DSQS; j++) {
+				pval = (u64*)&stats_data.gdsq_count[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu, %llu\n",
+						stats_str[item], j, pval[0], pval[1]);
+				if (ret < 0 || ret >= len - idx)
+					return;
+				idx += ret;
+			}
+		} else if (ERR_IDX == item) {
+			pval = (u64*)&stats_data.err_idx;
+			ret = snprintf(&buf[idx], len - idx, "%s:%llu, %llu, %llu, %llu,"
+						"%llu\n", stats_str[item], pval[0],
+						pval[1], pval[2], pval[3], pval[4]);
+			if (ret < 0 || ret >= len - idx)
+				return;
+			idx += ret;
+		} else if (PCP_TIMEOUT_CNT == item) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64*)&stats_data.pcp_timeout_cnt[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu\n",
+							stats_str[item], j, *pval);
+				if (ret < 0 || ret >= len - idx)
+					return;
+				idx += ret;
+			}
+		} else if (PCP_LDSQ_CNT == item) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64*)&stats_data.pcp_ldsq_count[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu,%llu\n",
+						stats_str[item], j, pval[0], pval[1]);
+				if (ret < 0 || ret >= len - idx)
+					return;
+				idx += ret;
+			}
+		} else if (PCP_ENQL_CNT == item) {
+			for (j = 0; j < nr_cpu_ids; j++) {
+				pval = (u64*)&stats_data.pcp_enql_cnt[j];
+				ret = snprintf(&buf[idx], len - idx, "%s[%d]:%llu\n",
+						stats_str[item], j, *pval);
+				if (ret < 0 || ret >= len - idx)
+					return;
+				idx += ret;
+			}
+		}
+		else {}
+	}
+	buf[idx] = '\0';
 }
 
-/**
- * scx_task_iter_init - Initialize a task iterator
- * @iter: iterator to init
- *
- * Initialize @iter. Must be called with scx_tasks_lock held. Once initialized,
- * @iter must eventually be exited with scx_task_iter_exit().
- *
- * scx_tasks_lock may be released between this and the first next() call or
- * between any two next() calls. If scx_tasks_lock is released between two
- * next() calls, the caller is responsible for ensuring that the task being
- * iterated remains accessible either through RCU read lock or obtaining a
- * reference count.
- *
- * All tasks which existed when the iteration started are guaranteed to be
- * visited as long as they still exist.
- */
-static void scx_task_iter_init(struct scx_task_iter *iter)
-{
-	lockdep_assert_held(&scx_tasks_lock);
-
-	iter->cursor = (struct sched_ext_entity){ .flags = SCX_TASK_CURSOR };
-	list_add(&iter->cursor.tasks_node, &scx_tasks);
-	iter->locked = NULL;
-}
+static struct {
+	cpumask_var_t exclusive;
+	cpumask_var_t partial;
+	cpumask_var_t big;
+	cpumask_var_t little;
+} iso_masks;
+
+enum cpu_type
+{
+	LITTLE,
+	BIG,
+	PARTIAL,
+	EXCLUSIVE,
+	INVALID
+};
 
-/**
- * scx_task_iter_exit - Exit a task iterator
- * @iter: iterator to exit
- *
- * Exit a previously initialized @iter. Must be called with scx_tasks_lock held.
- * If the iterator holds a task's rq lock, that rq lock is released. See
- * scx_task_iter_init() for details.
- */
-static void scx_task_iter_exit(struct scx_task_iter *iter)
+enum dsq_type
 {
-	struct list_head *cursor = &iter->cursor.tasks_node;
+	GLOBAL_DSQ,
+	PCP_DSQ,
+	OTHER,
+	MAX_DSQ_TYPE,
+};
 
-	lockdep_assert_held(&scx_tasks_lock);
+static enum cpu_type cpu_cluster(int cpu)
+{
+	int exclusive = 0;
 
-	if (iter->locked) {
-		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
-		iter->locked = NULL;
+	trace_android_vh_scx_cpu_exclusive(cpu, &exclusive);
+	if (exclusive) {
+		return EXCLUSIVE;
+	} else {
+		if (cpumask_test_cpu(cpu, iso_masks.little)) {
+			return LITTLE;
+		} else if (cpumask_test_cpu(cpu, iso_masks.big)) {
+			return BIG;
+		} else if (cpumask_test_cpu(cpu, iso_masks.partial)) {
+			return PARTIAL;
+		} else if (cpumask_test_cpu(cpu, iso_masks.exclusive)) {
+			return EXCLUSIVE;
+		}
 	}
-
-	if (list_empty(cursor))
-		return;
-
-	list_del_init(cursor);
+	return INVALID;
 }
 
-/**
- * scx_task_iter_next - Next task
- * @iter: iterator to walk
- *
- * Visit the next task. See scx_task_iter_init() for details.
- */
-static struct task_struct *scx_task_iter_next(struct scx_task_iter *iter)
+static enum dsq_type get_dsq_type(struct scx_dispatch_q *dsq)
 {
-	struct list_head *cursor = &iter->cursor.tasks_node;
-	struct sched_ext_entity *pos;
+	if (!dsq)
+		return OTHER;
 
-	lockdep_assert_held(&scx_tasks_lock);
+	if ((dsq->id & SCX_DSQ_FLAG_BUILTIN) &&
+		((dsq->id & 0xff) >= GDSQS_ID_BASE) &&
+		((dsq->id & 0xff) < MAX_GLOBAL_DSQS))
+		return GLOBAL_DSQ;
 
-	list_for_each_entry(pos, cursor, tasks_node) {
-		if (&pos->tasks_node == &scx_tasks)
-			return NULL;
-		if (!(pos->flags & SCX_TASK_CURSOR)) {
-			list_move(cursor, &pos->tasks_node);
-			return pos->task;
-		}
-	}
+	if ((dsq->id & SCX_DSQ_FLAG_BUILTIN) &&
+		((dsq->id & 0xff) >= MAX_GLOBAL_DSQS) &&
+		((dsq->id & 0xff) < max_ext_dsq_internal_id))
+		return PCP_DSQ;
 
-	/* can't happen, should always terminate at scx_tasks above */
-	BUG();
+	return OTHER;
 }
 
-/**
- * scx_task_iter_next_filtered - Next non-idle task
- * @iter: iterator to walk
- *
- * Visit the next non-idle task. See scx_task_iter_init() for details.
- */
-static struct task_struct *
-scx_task_iter_next_filtered(struct scx_task_iter *iter)
+static int dsq_id_to_internal(struct scx_dispatch_q *dsq)
 {
-	struct task_struct *p;
+	enum dsq_type type;
 
-	while ((p = scx_task_iter_next(iter))) {
-		if (!is_idle_task(p))
-			return p;
+	type = get_dsq_type(dsq);
+	switch (type) {
+	case GLOBAL_DSQ:
+	case PCP_DSQ:
+		return (dsq->id & 0xff) - GDSQS_ID_BASE;
+	default:
+		return -1;
 	}
-	return NULL;
+	return -1;
 }
 
-/**
- * scx_task_iter_next_filtered_locked - Next non-idle task with its rq locked
- * @iter: iterator to walk
- *
- * Visit the next non-idle task with its rq lock held. See scx_task_iter_init()
- * for details.
+/* Noting!!!!!!!!
+ * idle_masks.cpu does not accurately reflect the idle status of the CPU.
+ * Just provide a core selection tendency.
  */
-static struct task_struct *
-scx_task_iter_next_filtered_locked(struct scx_task_iter *iter)
+static void update_partial_idle(bool idle)
 {
-	struct task_struct *p;
-
-	if (iter->locked) {
-		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
-		iter->locked = NULL;
-	}
-
-	p = scx_task_iter_next_filtered(iter);
-	if (!p)
-		return NULL;
-
-	iter->rq = task_rq_lock(p, &iter->rf);
-	iter->locked = p;
-	return p;
+	if (idle)
+		cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.partial);
+	else
+		cpumask_andnot(idle_masks.cpu, idle_masks.cpu, iso_masks.partial);
 }
 
-static enum scx_ops_enable_state scx_ops_enable_state(void)
+/*
+ * Need more synchronization for these two variables?
+ * I choose not to.
+ */
+static int l_need_rescue, b_need_rescue;
+static void set_partial_status(bool enable, bool little, bool big)
 {
-	return atomic_read(&scx_ops_enable_state_var);
+	WRITE_ONCE(partial_enable, enable);
+	WRITE_ONCE(l_need_rescue, little);
+	WRITE_ONCE(b_need_rescue, big);
 }
 
-static enum scx_ops_enable_state
-scx_ops_set_enable_state(enum scx_ops_enable_state to)
+static bool is_little_need_rescue(void)
 {
-	return atomic_xchg(&scx_ops_enable_state_var, to);
+	return READ_ONCE(l_need_rescue);
 }
 
-static bool scx_ops_tryset_enable_state(enum scx_ops_enable_state to,
-					enum scx_ops_enable_state from)
+static bool is_big_need_rescue(void)
 {
-	int from_v = from;
+	return READ_ONCE(b_need_rescue);
+}
 
-	return atomic_try_cmpxchg(&scx_ops_enable_state_var, &from_v, to);
+static bool is_partial_enabled(void)
+{
+	return READ_ONCE(partial_enable);
 }
 
-static bool scx_ops_disabling(void)
+static bool is_partial_cpu(int cpu)
 {
-	return unlikely(scx_ops_enable_state() == SCX_OPS_DISABLING);
+	return cpumask_test_cpu(cpu, iso_masks.partial);
 }
 
-/**
- * wait_ops_state - Busy-wait the specified ops state to end
- * @p: target task
- * @opss: state to wait the end of
- *
- * Busy-wait for @p to transition out of @opss. This can only be used when the
- * state part of @opss is %SCX_QUEUEING or %SCX_DISPATCHING. This function also
- * has load_acquire semantics to ensure that the caller can see the updates made
- * in the enqueueing and dispatching paths.
- */
-static void wait_ops_state(struct task_struct *p, u64 opss)
+static bool skip_update_idle(void)
 {
-	do {
-		cpu_relax();
-	} while (atomic64_read_acquire(&p->scx->ops_state) == opss);
+	int cpu = smp_processor_id();
+	enum cpu_type type = cpu_cluster(cpu);
+
+	if (type == EXCLUSIVE ||
+		/* partial enable may changed during idle, it doesn't matter. */
+		(!is_partial_enabled() && type == PARTIAL))
+		return true;
+
+	return false;
 }
 
-/**
- * ops_cpu_valid - Verify a cpu number
- * @cpu: cpu number which came from a BPF ops
- *
- * @cpu is a cpu number which came from the BPF scheduler and can be any value.
- * Verify that it is in range and one of the possible cpus.
- */
-static bool ops_cpu_valid(s32 cpu)
+static void init_isolate_cpus(void)
 {
-	return likely(cpu >= 0 && cpu < nr_cpu_ids && cpu_possible(cpu));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.partial, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.exclusive, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.big, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&iso_masks.little, GFP_KERNEL));
+	cpumask_set_cpu(0, iso_masks.little);
+	cpumask_set_cpu(1, iso_masks.little);
+	cpumask_set_cpu(2, iso_masks.big);
+	cpumask_set_cpu(3, iso_masks.big);
+	cpumask_set_cpu(4, iso_masks.exclusive);
+	cpumask_set_cpu(5, iso_masks.partial);
+	cpumask_set_cpu(6, iso_masks.partial);
+	cpumask_set_cpu(7, iso_masks.exclusive);
 }
 
-/**
- * ops_sanitize_err - Sanitize a -errno value
- * @ops_name: operation to blame on failure
- * @err: -errno value to sanitize
- *
- * Verify @err is a valid -errno. If not, trigger scx_ops_error() and return
- * -%EPROTO. This is necessary because returning a rogue -errno up the chain can
- * cause misbehaviors. For an example, a large negative return from
- * ops.prep_enable() triggers an oops when passed up the call chain because the
- * value fails IS_ERR() test after being encoded with ERR_PTR() and then is
- * handled as a pointer.
- */
-static int ops_sanitize_err(const char *ops_name, s32 err)
+
+/* Should do get/put to guarantee exists,TODO. */
+static struct cgroup *cgroup_ancestor_l1(struct cgroup *cgrp)
 {
-	if (err < 0 && err >= -MAX_ERRNO)
-		return err;
+	int i;
+	struct cgroup *anc;
 
-	scx_ops_error("ops.%s() returned an invalid errno %d", ops_name, err);
-	return -EPROTO;
+	for (i = 0; i < cgrp->level; i++) {
+		anc = cgrp->ancestors[i];
+		if (CREATE_DSQ_LEVEL_WITHIN != anc->level)
+			continue;
+		return anc;
+	}
+	pr_err("<slim_sched><error>:error cgroup = %s\n", cgrp->kn->name);
+	return NULL;
 }
 
-/**
- * touch_core_sched - Update timestamp used for core-sched task ordering
- * @rq: rq to read clock from, must be locked
- * @p: task to update the timestamp for
- *
- * Update @p->scx->core_sched_at timestamp. This is used by scx_prio_less() to
- * implement global or local-DSQ FIFO ordering for core-sched. Should be called
- * when a task becomes runnable and its turn on the CPU ends (e.g. slice
- * exhaustion).
- */
-static void touch_core_sched(struct rq *rq, struct task_struct *p)
+#define PCP_IDX_BIT    (1 << 31)
+
+static bool is_pcp_rt(struct task_struct *p)
 {
-#ifdef CONFIG_SCHED_CORE
-	/*
-	 * It's okay to update the timestamp spuriously. Use
-	 * sched_core_disabled() which is cheaper than enabled().
-	 */
-	if (!sched_core_disabled())
-		p->scx->core_sched_at = rq_clock_task(rq);
-#endif
+	return rt_prio(p->prio) && (1 == p->nr_cpus_allowed);
 }
 
-/**
- * touch_core_sched_dispatch - Update core-sched timestamp on dispatch
- * @rq: rq to read clock from, must be locked
- * @p: task being dispatched
- *
- * If the BPF scheduler implements custom core-sched ordering via
- * ops.core_sched_before(), @p->scx->core_sched_at is used to implement FIFO
- * ordering within each local DSQ. This function is called from dispatch paths
- * and updates @p->scx->core_sched_at if custom core-sched ordering is in effect.
- */
-static void touch_core_sched_dispatch(struct rq *rq, struct task_struct *p)
+static bool is_pcp_idx(int idx)
 {
-	lockdep_assert_rq_held(rq);
-	assert_clock_updated(rq);
-
-#ifdef CONFIG_SCHED_CORE
-	if (SCX_HAS_OP(core_sched_before))
-		touch_core_sched(rq, p);
-#endif
+	return idx & PCP_IDX_BIT;
 }
 
-static void update_curr_scx(struct rq *rq)
+static int find_idx_from_task(struct task_struct *p)
 {
-	struct task_struct *curr = rq->curr;
-	u64 now = rq_clock_task(rq);
-	u64 delta_exec;
+	int idx, cpu;
+	int sp_dl;
+	struct task_group *tg = p->sched_task_group;
 
-	if (time_before_eq64(now, curr->se.exec_start))
-		return;
+	if (1 == p->nr_cpus_allowed || is_migration_disabled(p)) {
+		cpu = cpumask_any(p->cpus_ptr);
+		idx = cpu | PCP_IDX_BIT;
+		return idx;
+	}
 
-	delta_exec = now - curr->se.exec_start;
-	curr->se.exec_start = now;
-	curr->se.sum_exec_runtime += delta_exec;
-	account_group_exec_runtime(curr, delta_exec);
-	cgroup_account_cputime(curr, delta_exec);
+	sp_dl = p->scx->sched_prop & SCHED_PROP_DEADLINE_MASK;
+	if (sp_dl) {
+		idx = sp_dl;
+		goto done;
+	}
 
-	if (curr->scx->slice != SCX_SLICE_INF) {
-		curr->scx->slice -= min(curr->scx->slice, delta_exec);
-		if (!curr->scx->slice)
-			touch_core_sched(rq, curr);
+	/*
+	 * Those rt threads(prio>=50) which we can not recognized,
+	 * put them into SCHED_PROP_DEADLINE_LEVEL3.
+	 */
+	if (rt_prio(p->prio)) {
+		idx = SCHED_PROP_DEADLINE_LEVEL3;
+		goto done;
 	}
-}
 
-static bool scx_dsq_priq_less(struct rb_node *node_a,
-			      const struct rb_node *node_b)
-{
-	const struct sched_ext_entity *a =
-		container_of(node_a, struct sched_ext_entity, dsq_node.priq);
-	const struct sched_ext_entity *b =
-		container_of(node_b, struct sched_ext_entity, dsq_node.priq);
+	if (tg && tg->css.cgroup) {
+		idx = tg->scx_deadline_idx;
+	} else {
+		idx = DEFAULT_CGROUP_DL_IDX;
+	}
 
-	return time_before64(a->dsq_vtime, b->dsq_vtime);
+done:
+	/* Must check whether cpu_allowed match cluster. TODO. */
+
+	if (idx < 0 || idx >= MAX_GLOBAL_DSQS) {
+		pr_err("<slim_sched><error> : idx error, idx = %d-----\n", idx);
+		idx = DEFAULT_CGROUP_DL_IDX;
+	}
+	return idx;
 }
 
-static void dispatch_enqueue(struct scx_dispatch_q *dsq, struct task_struct *p,
-			     u64 enq_flags)
+static struct scx_dispatch_q* find_dsq_from_task(struct task_struct *p)
 {
-	bool is_local = dsq->id == SCX_DSQ_LOCAL;
-
-	WARN_ON_ONCE(p->scx->dsq || !list_empty(&p->scx->dsq_node.fifo));
-	WARN_ON_ONCE((p->scx->dsq_flags & SCX_TASK_DSQ_ON_PRIQ) ||
-		     !RB_EMPTY_NODE(&p->scx->dsq_node.priq));
+        int idx;
+	unsigned long flags;
+	struct scx_dispatch_q *dsq;
 
-	if (!is_local) {
-		raw_spin_lock(&dsq->lock);
-		if (unlikely(dsq->id == SCX_DSQ_INVALID)) {
-			scx_ops_error("attempting to dispatch to a destroyed dsq");
-			/* fall back to the global dsq */
-			raw_spin_unlock(&dsq->lock);
-			dsq = &scx_dsq_global;
-			raw_spin_lock(&dsq->lock);
-		}
-	}
+        if (!p)
+                return NULL;
 
-	if (enq_flags & SCX_ENQ_DSQ_PRIQ) {
-		p->scx->dsq_flags |= SCX_TASK_DSQ_ON_PRIQ;
-		rb_add_cached(&p->scx->dsq_node.priq, &dsq->priq,
-			      scx_dsq_priq_less);
+        idx = find_idx_from_task(p);
+	if(is_pcp_idx(idx)) {
+		idx &= ~PCP_IDX_BIT;
+                dsq = &per_cpu(pcp_ldsq, idx);
+		p->scx->gdsq_idx = dsq_id_to_internal(dsq);
+		slim_stats_record(PCP_LDSQ_CNT, 0, 0, idx);
 	} else {
-		if (enq_flags & (SCX_ENQ_HEAD | SCX_ENQ_PREEMPT))
-			list_add(&p->scx->dsq_node.fifo, &dsq->fifo);
-		else
-			list_add_tail(&p->scx->dsq_node.fifo, &dsq->fifo);
+		dsq = &gdsqs[idx];
+                p->scx->gdsq_idx = idx;
+		slim_stats_record(GDSQ_CNT, 0, idx, 0);
 	}
-	dsq->nr++;
-	p->scx->dsq = dsq;
 
-	/*
-	 * We're transitioning out of QUEUEING or DISPATCHING. store_release to
-	 * match waiters' load_acquire.
-	 */
-	if (enq_flags & SCX_ENQ_CLEAR_OPSS)
-		atomic64_set_release(&p->scx->ops_state, SCX_OPSS_NONE);
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+        if (list_empty(&dsq->fifo)) {
+                dsq->last_consume_at = jiffies;
+        }
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
 
-	if (is_local) {
-		struct scx_rq *scx = container_of(dsq, struct scx_rq, local_dsq);
-		struct rq *rq = scx->rq;
-		bool preempt = false;
+        return dsq;
+}
 
-		if ((enq_flags & SCX_ENQ_PREEMPT) && p != rq->curr &&
-		    rq->curr->sched_class == &ext_sched_class) {
-			rq->curr->scx->slice = 0;
-			preempt = true;
-		}
 
-		if (preempt || sched_class_above(&ext_sched_class,
-						 rq->curr->sched_class))
-			resched_curr(rq);
-	} else {
-		raw_spin_unlock(&dsq->lock);
-	}
+bool consume_dispatch_q(struct rq *rq, struct rq_flags *rf,
+                               struct scx_dispatch_q *dsq);
+
+static void set_partial_rescue(bool p_state, bool l_over, bool b_over)
+{
+	set_partial_status(p_state, l_over, b_over);
+	update_partial_idle(p_state);
+	scx_internal_systrace("C|9999|partial_enable|%d\n", is_partial_enabled());
+	scx_internal_systrace("C|9999|l_need_rescue|%d\n", is_little_need_rescue());
+	scx_internal_systrace("C|9999|b_need_rescue|%d\n", is_big_need_rescue());
 }
 
-static void task_unlink_from_dsq(struct task_struct *p,
-				 struct scx_dispatch_q *dsq)
+void partial_dynamic_ctrl(void)
 {
-	if (p->scx->dsq_flags & SCX_TASK_DSQ_ON_PRIQ) {
-		rb_erase_cached(&p->scx->dsq_node.priq, &dsq->priq);
-		RB_CLEAR_NODE(&p->scx->dsq_node.priq);
-		p->scx->dsq_flags &= ~SCX_TASK_DSQ_ON_PRIQ;
-	} else {
-		list_del_init(&p->scx->dsq_node.fifo);
+	int cpu;
+	u64 ratio, util = 0;
+	u64 lmax = 0, bmax = 0;
+	bool l_over, l_under, b_over, b_under;
+	static bool last_l_over = false, last_b_over = false;
+
+	for_each_cpu(cpu, iso_masks.little) {
+		trace_android_vh_get_util(cpu, NULL, &util);
+		ratio = util * 100 / arch_scale_cpu_capacity(cpu);
+		if (ratio > lmax)
+			lmax = ratio;
+	}
+	l_over = lmax >= cpuctrl_high_ratio;
+	l_under = lmax < cpuctrl_low_ratio;
+	for_each_cpu(cpu, iso_masks.big) {
+		trace_android_vh_get_util(cpu, NULL, &util);
+		ratio = util * 100 / arch_scale_cpu_capacity(cpu);
+		if (ratio > bmax)
+			bmax = ratio;
 	}
+	b_over = bmax >= cpuctrl_high_ratio;
+	b_under = bmax < cpuctrl_low_ratio;
 
+	if (is_partial_enabled() && (l_over || b_over)) {
+		if (last_l_over != l_over || last_b_over != b_over)
+			set_partial_rescue(true, l_over, b_over);
+	}
+	else if (!is_partial_enabled() && (l_over || b_over)) {
+		set_partial_rescue(true, l_over, b_over);
+	} else if (is_partial_enabled() && l_under && b_under) {
+		set_partial_rescue(false, false, false);
+	} else {}
+	last_l_over = l_over;
+	last_b_over = b_over;
 }
 
-static bool task_linked_on_dsq(struct task_struct *p)
+static inline void slim_trace_show_cpu_consume_dsq_idx(unsigned int cpu, unsigned int idx)
 {
-	return !list_empty(&p->scx->dsq_node.fifo) ||
-		!RB_EMPTY_NODE(&p->scx->dsq_node.priq);
+	scx_info_systrace("C|9999|Cpu%d_dsq_id|%d\n", cpu, idx);
 }
 
-static void dispatch_dequeue(struct scx_rq *scx_rq, struct task_struct *p)
+static int consume_target_dsq(struct rq *rq, struct rq_flags *rf, unsigned int idx)
 {
-	struct scx_dispatch_q *dsq = p->scx->dsq;
-	bool is_local = dsq == &scx_rq->local_dsq;
+	if (idx < 0 || idx >= MAX_GLOBAL_DSQS)
+		return 0;
 
-	if (!dsq) {
-		WARN_ON_ONCE(task_linked_on_dsq(p));
-		/*
-		 * When dispatching directly from the BPF scheduler to a local
-		 * DSQ, the task isn't associated with any DSQ but
-		 * @p->scx->holding_cpu may be set under the protection of
-		 * %SCX_OPSS_DISPATCHING.
-		 */
-		if (p->scx->holding_cpu >= 0)
-			p->scx->holding_cpu = -1;
-		return;
+	if (consume_dispatch_q(rq, rf, &gdsqs[idx])) {
+		slim_stats_record(GDSQ_CNT, 1, idx, 0);
+		return 1;
 	}
+	return 0;
+}
 
-	if (!is_local)
-		raw_spin_lock(&dsq->lock);
+static int consume_period_dsq(struct rq *rq, struct rq_flags *rf)
+{
+        int i;
 
-	/*
-	 * Now that we hold @dsq->lock, @p->holding_cpu and @p->scx->dsq_node
-	 * can't change underneath us.
-	*/
-	if (p->scx->holding_cpu < 0) {
-		/* @p must still be on @dsq, dequeue */
-		WARN_ON_ONCE(!task_linked_on_dsq(p));
-		task_unlink_from_dsq(p, dsq);
-		dsq->nr--;
-	} else {
-		/*
-		 * We're racing against dispatch_to_local_dsq() which already
-		 * removed @p from @dsq and set @p->scx->holding_cpu. Clear the
-		 * holding_cpu which tells dispatch_to_local_dsq() that it lost
-		 * the race.
-		 */
-		WARN_ON_ONCE(task_linked_on_dsq(p));
-		p->scx->holding_cpu = -1;
-	}
-	p->scx->dsq = NULL;
+        for (i = 0; i < NON_PERIOD_START; i++) {
+                if (consume_dispatch_q(rq, rf, &gdsqs[i])) {
+			slim_stats_record(GDSQ_CNT, 1, i, 0);
+                        return 1;
+                }
+        }
+        return 0;
+}
 
-	if (!is_local)
-		raw_spin_unlock(&dsq->lock);
+static void update_timeout_stats(struct rq *rq, struct scx_dispatch_q *dsq, u64 deadline)
+{
+	struct sched_ext_entity *entity;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&dsq->lock, flags);
+	if (list_empty(&dsq->fifo))
+		goto clear_timeout;
+
+	entity = list_first_entry(&dsq->fifo, struct sched_ext_entity, dsq_node.fifo);
+	if (time_before_eq(jiffies, entity->runnable_at + msecs_to_jiffies(deadline)))
+		goto clear_timeout;
+
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	scx_info_trace("<hmbird_sched><timeout>dsq[%d] still timeout task-%s, "
+				"jiffies = %lu, deadline = %lu, runnable at = %lu\n",
+				dsq_id_to_internal(dsq), entity->task->comm,
+				jiffies, msecs_to_jiffies(deadline), entity->runnable_at);
+	scx_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id_to_internal(dsq), 1);
+	return;
+
+clear_timeout:
+	scx_info_trace("<hmbird_sched><timeout>dsq[%d] clear timeout\n",
+				dsq_id_to_internal(dsq));
+	scx_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id_to_internal(dsq), 0);
+	dsq->is_timeout = false;
+	slim_stats_record(PCP_TIMEOUT_CNT, 0, 0, cpu_of(rq));
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+}
+
+static void systrace_output_rtime_state(struct scx_dispatch_q *dsq, int rtime)
+{
+	scx_info_systrace("C|9999|dsq%d_rtime|%d\n", dsq_id_to_internal(dsq), rtime);
 }
 
-static struct scx_dispatch_q *find_non_local_dsq(u64 dsq_id)
+static int consume_pcp_dsq(struct rq *rq, struct rq_flags *rf, bool any)
 {
-	lockdep_assert(rcu_read_lock_any_held());
+        bool is_timeout;
+        int cpu = cpu_of(rq);
+        unsigned long flags;
+        struct scx_dispatch_q *dsq = &per_cpu(pcp_ldsq, cpu);
 
-	return &scx_dsq_global;
+        raw_spin_lock_irqsave(&dsq->lock, flags);
+        is_timeout = dsq->is_timeout;
+        raw_spin_unlock_irqrestore(&dsq->lock, flags);
+
+	/*
+	 * dsq->is_timeout may change here, let it be.
+	 * it won't cause serious problems.
+	 * the same for consume_dispatch_q later.
+	 */
+	if (!is_timeout && !any)
+		return 0;
+
+	if (consume_dispatch_q(rq, rf, dsq)) {
+		if (is_timeout) {
+			scx_info_trace("<hmbird_sched><timeout>dsq[%d]"
+					" consume a pcp timeout task\n",
+						dsq_id_to_internal(dsq));
+			update_timeout_stats(rq, dsq, pcp_dsq_deadline);
+			slim_stats_record(PCP_TIMEOUT_CNT, 0, 0, cpu);
+		}
+		slim_stats_record(PCP_LDSQ_CNT, 1, 0, cpu);
+		return 1;
+	}
+	/*
+	 * No pcp task, clear quota.
+	 */
+	if (any) {
+		if (per_cpu(pcp_info, cpu_of(rq)).pcp_round) {
+			per_cpu(pcp_info, cpu).rtime = 0;
+			per_cpu(pcp_info, cpu).pcp_round = false;
+			scx_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, false);
+			systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+					per_cpu(pcp_info, cpu).rtime);
+		}
+	}
+        return 0;
 }
 
-static struct scx_dispatch_q *find_dsq_for_dispatch(struct rq *rq, u64 dsq_id,
-						    struct task_struct *p)
+static int consume_timeout_dsq(struct rq *rq, struct rq_flags *rf, struct cluster_ctx *ctx)
 {
-	struct scx_dispatch_q *dsq;
+	int i;
+	bool is_timeout;
+	unsigned long flags;
 
-	if (dsq_id == SCX_DSQ_LOCAL)
-		return &rq->scx->local_dsq;
+	/* Third param <false> means only consume timeout pcp dsq. */
+	if (consume_pcp_dsq(rq, rf, false))
+		return 1;
 
-	dsq = find_non_local_dsq(dsq_id);
-	if (unlikely(!dsq)) {
-		scx_ops_error("non-existent DSQ 0x%llx for %s[%d]",
-			      dsq_id, p->comm, p->pid);
-		return &scx_dsq_global;
+	for(i = ctx->lower; i < ctx->upper; i++) {
+		raw_spin_lock_irqsave(&gdsqs[i].lock, flags);
+                is_timeout = gdsqs[i].is_timeout;
+                raw_spin_unlock_irqrestore(&gdsqs[i].lock, flags);
+		/* gdsqs[i].is_timeout may change here, let it be... */
+		if (is_timeout) {
+			/*
+			 * consume_dispatch_q will acquire dsq-lock,
+			 * So cannot keep lock here, annoy enough.
+			 * may rewrite a consume_dispatch_q_locked, TODO.
+			 */
+                        if (consume_dispatch_q(rq, rf, &gdsqs[i])) {
+				scx_info_trace("<hmbird_sched><timeout>dsq[%d]"
+						" consume a timeout task\n", i);
+                                slim_stats_record(TIMEOUT_CNT, ctx->tidx, 0, 0);
+				update_timeout_stats(rq, &gdsqs[i], SCX_BPF_DSQS_DEADLINE[i]);
+                                return 1;
+                        }
+                }
 	}
+	return 0;
+}
 
-	return dsq;
+static int check_pcp_dsq_round(struct rq *rq, struct rq_flags *rf)
+{
+	if (per_cpu(pcp_info, cpu_of(rq)).pcp_round) {
+		if (consume_pcp_dsq(rq, rf, true))
+			return 1;
+	}
+	return 0;
 }
 
-static void direct_dispatch(struct task_struct *ddsp_task, struct task_struct *p,
-			    u64 dsq_id, u64 enq_flags)
+static int check_non_period_dsq_phase(struct rq *rq, struct rq_flags *rf,
+						     int tmp, int cidx, int tidx)
 {
-	struct scx_dispatch_q *dsq;
+	unsigned long flags;
 
-	/* @p must match the task which is being enqueued */
-	if (unlikely(p != ddsp_task)) {
-		if (IS_ERR(ddsp_task))
-			scx_ops_error("%s[%d] already direct-dispatched",
-				      p->comm, p->pid);
-		else
-			scx_ops_error("enqueueing %s[%d] but trying to direct-dispatch %s[%d]",
-				      ddsp_task->comm, ddsp_task->pid,
-				      p->comm, p->pid);
-		return;
-	}
+	if (consume_dispatch_q(rq, rf, &gdsqs[tmp])) {
+		if (tmp != cidx) {
+			spin_lock(&sinfo.lock);
+			sinfo.curr_idx[tidx] = tmp;
+			spin_unlock(&sinfo.lock);
+			scx_info_systrace("C|9999|cidx_%d|%d\n", tidx, sinfo.curr_idx[tidx]);
+			slim_stats_record(SWITCH_IDX, 0, 0, 0);
+		}
+		slim_stats_record(GDSQ_CNT, 1, tmp, 0);
 
-	/*
-	 * %SCX_DSQ_LOCAL_ON is not supported during direct dispatch because
-	 * dispatching to the local DSQ of a different CPU requires unlocking
-	 * the current rq which isn't allowed in the enqueue path. Use
-	 * ops.select_cpu() to be on the target CPU and then %SCX_DSQ_LOCAL.
-	 */
-	if (unlikely((dsq_id & SCX_DSQ_LOCAL_ON) == SCX_DSQ_LOCAL_ON)) {
-		scx_ops_error("SCX_DSQ_LOCAL_ON can't be used for direct-dispatch");
-		return;
+		raw_spin_lock_irqsave(&gdsqs[tmp].lock, flags);
+		gdsqs[tmp].last_consume_at = jiffies;
+		raw_spin_unlock_irqrestore(&gdsqs[tmp].lock, flags);
+		return 1;
 	}
+	return 0;
+
+}
 
-	touch_core_sched_dispatch(task_rq(p), p);
+static int get_cidx(struct cluster_ctx *ctx)
+{
+	int cidx;
 
-	dsq = find_dsq_for_dispatch(task_rq(p), dsq_id, p);
-	dispatch_enqueue(dsq, p, enq_flags | SCX_ENQ_CLEAR_OPSS);
+	spin_lock(&sinfo.lock);
+	cidx = sinfo.curr_idx[ctx->tidx];
+	if (cidx < ctx->lower || cidx >= ctx->upper) {
+		sinfo.curr_idx[ctx->tidx] = ctx->lower;
+		scx_info_systrace("C|9999|cidx_%d|%d\n", ctx->tidx, sinfo.curr_idx[ctx->tidx]);
+		slim_stats_record(ERR_IDX, ctx->tidx + 3, 0, 0);
+		cidx = sinfo.curr_idx[ctx->tidx];
+	}
+	spin_unlock(&sinfo.lock);
 
-	/*
-	 * Mark that dispatch already happened by spoiling direct_dispatch_task
-	 * with a non-NULL value which can never match a valid task pointer.
-	 */
-	__this_cpu_write(direct_dispatch_task, ERR_PTR(-ESRCH));
+	return cidx;
 }
 
-static bool test_rq_online(struct rq *rq)
+
+static int gen_cluster_ctx(struct cluster_ctx* ctx, enum cpu_type type)
 {
-#ifdef CONFIG_SMP
-	return rq->online;
+	switch (type) {
+	case PARTIAL:
+		if (!is_partial_enabled())
+			return -1;
+		fallthrough;
+#ifdef CLUSTER_SEPARATE
+        case BIG:
+                ctx->lower = NON_PERIOD_START;
+                ctx->upper = CLUSTER_SEPARATE_IDX;
+                ctx->tidx = 0;
+                break;
+        case LITTLE:
+                ctx->lower = CLUSTER_SEPARATE_IDX;
+                ctx->upper = NON_PERIOD_END;
+                ctx->tidx = 1;
+                break;
 #else
-	return true;
+	case BIG:
+/*		ctx->lower = NON_PERIOD_START;
+                ctx->upper = NON_PERIOD_END;
+                ctx->tidx = 0;
+		break;
+*/
+	case LITTLE:
+		ctx->lower = NON_PERIOD_START;
+		ctx->upper = NON_PERIOD_END;
+		ctx->tidx = 0;
+		break;
 #endif
+        default:
+                WARN_ON(1);
+                return -1;
+        }
+	return 0;
 }
 
-static void do_enqueue_task(struct rq *rq, struct task_struct *p, u64 enq_flags,
-			    int sticky_cpu)
+static int consume_non_period_dsq(struct rq *rq, struct rq_flags *rf, enum cpu_type type)
 {
-	struct task_struct **ddsp_taskp;
-	u64 qseq;
+	struct cluster_ctx ctx;
+        int cidx;
+        int tmp;
 
-	WARN_ON_ONCE(!(p->scx->flags & SCX_TASK_QUEUED));
-
-	if (p->scx->flags & SCX_TASK_ENQ_LOCAL) {
-		enq_flags |= SCX_ENQ_LOCAL;
-		p->scx->flags &= ~SCX_TASK_ENQ_LOCAL;
-	}
+	if (gen_cluster_ctx(&ctx, type))
+		return 0;
 
-	/* rq migration */
-	if (sticky_cpu == cpu_of(rq))
-		goto local_norefill;
+	if (consume_timeout_dsq(rq, rf, &ctx))
+		return 1;
 
-	/*
-	 * If !rq->online, we already told the BPF scheduler that the CPU is
-	 * offline. We're just trying to on/offline the CPU. Don't bother the
-	 * BPF scheduler.
-	 */
-	if (unlikely(!test_rq_online(rq)))
-		goto local;
+	cidx = get_cidx(&ctx);
+	tmp = cidx;
+	do {
+		if (check_pcp_dsq_round(rq, rf))
+			return 1;
+		if (check_non_period_dsq_phase(rq, rf, tmp, cidx, ctx.tidx))
+			return 1;
+		spin_lock(&sinfo.lock);
+		sinfo.rtime[tmp] = 0;
+		systrace_output_rtime_state(&gdsqs[tmp], sinfo.rtime[tmp]);
+		tmp++;
+		if (tmp >= ctx.upper) {
+			atomic64_inc(&pcp_dsq_round);
+			scx_info_systrace("C|9999|pcp_dsq_round|%lld\n", atomic64_read(&pcp_dsq_round));
+			tmp = ctx.lower;
+		}
+		spin_unlock(&sinfo.lock);
+	} while (tmp != cidx);
 
-	/* see %SCX_OPS_ENQ_EXITING */
-	if (!static_branch_unlikely(&scx_ops_enq_exiting) &&
-	    unlikely(p->flags & PF_EXITING))
-		goto local;
+	return consume_pcp_dsq(rq, rf, true);
+}
 
-	/* see %SCX_OPS_ENQ_LAST */
-	if (!static_branch_unlikely(&scx_ops_enq_last) &&
-	    (enq_flags & SCX_ENQ_LAST))
-		goto local;
+static bool consume_hmbird_global_dsq(struct rq *rq, struct rq_flags *rf)
+{
+	enum cpu_type type = cpu_cluster(cpu_of(rq));
+	int period_allowed = 1;
+	int non_period_allowed = 1;
 
-	if (!SCX_HAS_OP(enqueue)) {
-		if (enq_flags & SCX_ENQ_LOCAL)
-			goto local;
-		else
-			goto global;
-	}
+	trace_android_vh_scx_consume_dsq_allowed(rq, rf, SCHED_EXT_DSQ_TYPE_PERIOD, &period_allowed);
+	trace_android_vh_scx_consume_dsq_allowed(rq, rf, SCHED_EXT_DSQ_TYPE_NON_PERIOD, &non_period_allowed);
 
-	/* DSQ bypass didn't trigger, enqueue on the BPF scheduler */
-	qseq = rq->scx->ops_qseq++ << SCX_OPSS_QSEQ_SHIFT;
+	switch (type) {
+		case EXCLUSIVE:
+			if (consume_pcp_dsq(rq, rf, true))
+				return 1;
+			return 0;
+
+		case PARTIAL:
+			if (!is_partial_enabled()) {
+				if (consume_pcp_dsq(rq, rf, true))
+					return 1;
+				return 0;
+			}
+			if (is_little_need_rescue()) {
+				if (consume_target_dsq(rq, rf, RT_DSQ_IDX))
+					return 1;
+				if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL1))
+					return 1;
+				if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL2))
+					return 1;
+
+				if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL3))
+					return 1;
+				if (non_period_allowed && consume_non_period_dsq(rq, rf, LITTLE))
+					return 1;
+			}
+			if (is_big_need_rescue()) {
+				if (period_allowed && consume_period_dsq(rq, rf))
+					return 1;
+				if (non_period_allowed && consume_non_period_dsq(rq, rf, BIG))
+					return 1;
+			}
+			break;
 
-	WARN_ON_ONCE(atomic64_read(&p->scx->ops_state) != SCX_OPSS_NONE);
-	atomic64_set(&p->scx->ops_state, SCX_OPSS_QUEUEING | qseq);
+		case BIG:
+			if (period_allowed && consume_period_dsq(rq, rf))
+				return 1;
+			if (non_period_allowed && consume_non_period_dsq(rq, rf, type))
+				return 1;
+			break;
 
-	ddsp_taskp = this_cpu_ptr(&direct_dispatch_task);
-	WARN_ON_ONCE(*ddsp_taskp);
-	*ddsp_taskp = p;
+		case LITTLE:
+			if (consume_target_dsq(rq, rf, RT_DSQ_IDX))
+				return 1;
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL1))
+				return 1;
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL2))
+				return 1;
 
-	SCX_CALL_OP_TASK(SCX_KF_ENQUEUE, enqueue, p, enq_flags);
+			if (consume_target_dsq(rq, rf, SCHED_PROP_DEADLINE_LEVEL3))
+				return 1;
 
-	/*
-	 * If not directly dispatched, QUEUEING isn't clear yet and dispatch or
-	 * dequeue may be waiting. The store_release matches their load_acquire.
-	 */
-	if (*ddsp_taskp == p)
-		atomic64_set_release(&p->scx->ops_state, SCX_OPSS_QUEUED | qseq);
-	*ddsp_taskp = NULL;
-	return;
+			if (non_period_allowed && consume_non_period_dsq(rq, rf, type))
+				return 1;
+			break;
 
-local:
-	/*
-	 * For task-ordering, slice refill must be treated as implying the end
-	 * of the current slice. Otherwise, the longer @p stays on the CPU, the
-	 * higher priority it becomes from scx_prio_less()'s POV.
-	 */
-	touch_core_sched(rq, p);
-	p->scx->slice = SCX_SLICE_DFL;
-local_norefill:
-	dispatch_enqueue(&rq->scx->local_dsq, p, enq_flags);
-	return;
+		default:
+			break;
+	}
 
-global:
-	touch_core_sched(rq, p);	/* see the comment in local: */
-	p->scx->slice = SCX_SLICE_DFL;
-	dispatch_enqueue(&scx_dsq_global, p, enq_flags);
+	return 0;
 }
 
-static bool watchdog_task_watched(const struct task_struct *p)
+static int consume_dispatch_global(struct rq *rq, struct rq_flags *rf)
 {
-	return !list_empty(&p->scx->watchdog_node);
+	return consume_hmbird_global_dsq(rq, rf);
 }
 
-static void watchdog_watch_task(struct rq *rq, struct task_struct *p)
-{
-	lockdep_assert_rq_held(rq);
-	if (p->scx->flags & SCX_TASK_WATCHDOG_RESET)
-		p->scx->runnable_at = jiffies;
-	p->scx->flags &= ~SCX_TASK_WATCHDOG_RESET;
-	list_add_tail(&p->scx->watchdog_node, &rq->scx->watchdog_list);
-}
 
-static void watchdog_unwatch_task(struct task_struct *p, bool reset_timeout)
+static void update_runningtime(struct rq *rq, struct task_struct *p, unsigned long exec_time)
 {
-	list_del_init(&p->scx->watchdog_node);
-	if (reset_timeout)
-		p->scx->flags |= SCX_TASK_WATCHDOG_RESET;
+	int idx;
+
+	/* which dsq belongs to while task enqueue, task will consume its running time. */
+	idx = p->scx->gdsq_idx;
+	/* Only non-period dsq share running time between each other. */
+	if (idx < NON_PERIOD_START || idx >= max_ext_dsq_internal_id)
+		return;
+
+	if (idx >= MAX_GLOBAL_DSQS) {
+		per_cpu(pcp_info, cpu_of(rq)).rtime += exec_time;
+		systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu_of(rq)),
+					per_cpu(pcp_info, cpu_of(rq)).rtime);
+	}
+	else {
+		spin_lock(&sinfo.lock);
+		sinfo.rtime[idx] += exec_time;
+		spin_unlock(&sinfo.lock);
+		systrace_output_rtime_state(&gdsqs[idx], sinfo.rtime[idx]);
+	}
 }
 
-static void enqueue_task_scx(struct rq *rq, struct task_struct *p, int enq_flags)
+static void update_dsq_idx(struct rq *rq, struct task_struct *p, enum cpu_type type)
 {
-	int sticky_cpu = p->scx->sticky_cpu;
+	int cidx;
+	struct cluster_ctx ctx;
+	int cpu = cpu_of(rq);
 
-	enq_flags |= rq->scx->extra_enq_flags;
+	if (gen_cluster_ctx(&ctx, type))
+		return;
 
-	if (sticky_cpu >= 0)
-		p->scx->sticky_cpu = -1;
+	spin_lock(&sinfo.lock);
+	cidx = sinfo.curr_idx[ctx.tidx];
+	if (cidx < ctx.lower || cidx >= ctx.upper) {
+		sinfo.curr_idx[ctx.tidx] = ctx.lower;
+		scx_info_systrace("C|9999|cidx_%d|%d\n", ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		slim_stats_record(ERR_IDX, ctx.tidx, 0, 0);
+		cidx = sinfo.curr_idx[ctx.tidx];
+	}
+
+	while(1) {
+		if (per_cpu(pcp_info, cpu).pcp_round) {
+			if (per_cpu(pcp_info, cpu).rtime >= pcp_dsq_quota) {
+				scx_info_trace("<hmbird_sched><non> : cpu[%d] pcp_dsq_round is full,"
+						" rtime = %d \n", cpu, per_cpu(pcp_info, cpu).rtime);
+				per_cpu(pcp_info, cpu).rtime = 0;
+				per_cpu(pcp_info, cpu).pcp_round = false;
+				scx_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, false);
+				systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+						per_cpu(pcp_info, cpu_of(rq)).rtime);
+			}
+		}
+		if (sinfo.rtime[cidx] < dsq_quota[cidx])
+			break;
 
-	/*
-	 * Restoring a running task will be immediately followed by
-	 * set_next_task_scx() which expects the task to not be on the BPF
-	 * scheduler as tasks can only start running through local DSQs. Force
-	 * direct-dispatch into the local DSQ by setting the sticky_cpu.
-	 */
-	if (unlikely(enq_flags & ENQUEUE_RESTORE) && task_current(rq, p))
-		sticky_cpu = cpu_of(rq);
+		/* clear current dsq rtime */
+		sinfo.rtime[cidx] = 0;
+		systrace_output_rtime_state(&gdsqs[cidx], sinfo.rtime[cidx]);
+
+		sinfo.curr_idx[ctx.tidx]++;
+		scx_info_systrace("C|9999|cidx_%d|%d\n", ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		if (sinfo.curr_idx[ctx.tidx] >= ctx.upper) {
+			atomic64_inc(&pcp_dsq_round);
+			scx_info_systrace("C|9999|pcp_dsq_round|%lld\n", atomic64_read(&pcp_dsq_round));
+			sinfo.curr_idx[ctx.tidx] = ctx.lower;
+			scx_info_systrace("C|9999|cidx_%d|%d\n", ctx.tidx, sinfo.curr_idx[ctx.tidx]);
+		}
+		cidx = sinfo.curr_idx[ctx.tidx];
+		slim_stats_record(SWITCH_IDX, 1, 0, 0);
+	}
+	spin_unlock(&sinfo.lock);
+}
 
-	if (p->scx->flags & SCX_TASK_QUEUED) {
-		WARN_ON_ONCE(!watchdog_task_watched(p));
+
+static void update_dispatch_dsq_info(struct rq *rq, struct task_struct *p)
+{
+	enum cpu_type type;
+	if (!rq || !p)
+		return;
+
+	type = cpu_cluster(cpu_of(rq));
+	switch(type) {
+	case PARTIAL:
+                if (is_partial_enabled())
+                        break;
+		fallthrough;
+	case EXCLUSIVE:
 		return;
+	default:
+		break;
+        }
+	update_dsq_idx(rq, p, type);
+}
+
+
+static bool scan_dsq_timeout(struct rq *rq, struct scx_dispatch_q *dsq, u64 deadline)
+{
+	struct sched_ext_entity *entity;
+
+	raw_spin_lock(&dsq->lock);
+	if (list_empty(&dsq->fifo) || dsq->is_timeout) {
+		raw_spin_unlock(&dsq->lock);
+		return false;
 	}
 
-	watchdog_watch_task(rq, p);
-	p->scx->flags |= SCX_TASK_QUEUED;
-	rq->scx->nr_running++;
-	add_nr_running(rq, 1);
+	entity = list_first_entry(&dsq->fifo, struct sched_ext_entity, dsq_node.fifo);
+	if (!entity) {
+		WARN_ON(1);
+		raw_spin_unlock(&dsq->lock);
+		return false;
+	}
 
-	if (SCX_HAS_OP(runnable))
-		SCX_CALL_OP_TASK(SCX_KF_REST, runnable, p, enq_flags);
+	if (time_before_eq(jiffies, entity->runnable_at + msecs_to_jiffies(deadline))) {
+		raw_spin_unlock(&dsq->lock);
+		return false;
+	}
 
-	if (enq_flags & SCX_ENQ_WAKEUP)
-		touch_core_sched(rq, p);
+	dsq->is_timeout = true;
+	scx_info_trace("<hmbird_sched><timeout>dsq[%d] has timeout task-%s, "
+				"jiffies = %lu, runnable at = %lu\n",
+				dsq_id_to_internal(dsq), entity->task->comm,
+				jiffies, entity->runnable_at);
+	scx_info_systrace("C|9999|dsq_%d_timeout|%d\n", dsq_id_to_internal(dsq), 1);
+	raw_spin_unlock(&dsq->lock);
 
-	do_enqueue_task(rq, p, enq_flags, sticky_cpu);
+	return true;
 }
 
-static void ops_dequeue(struct task_struct *p, u64 deq_flags)
+void scan_timeout(struct rq *rq)
 {
-	u64 opss;
+	int i;
+	int cpu = cpu_of(rq);
+	struct scx_dispatch_q *dsq;
+	static u64 last_scan_at = 0;
+	static DEFINE_PER_CPU(u64, pcp_last_scan_at);
 
-	watchdog_unwatch_task(p, false);
+	if (time_before_eq(jiffies, (unsigned long)per_cpu(pcp_last_scan_at, cpu)))
+		return;
+	per_cpu(pcp_last_scan_at, cpu) = jiffies;
 
-	/* acquire ensures that we see the preceding updates on QUEUED */
-	opss = atomic64_read_acquire(&p->scx->ops_state);
+	dsq = &per_cpu(pcp_ldsq, cpu);
+	scan_dsq_timeout(rq, dsq, pcp_dsq_deadline);
 
-	switch (opss & SCX_OPSS_STATE_MASK) {
-	case SCX_OPSS_NONE:
-		break;
-	case SCX_OPSS_QUEUEING:
-		/*
-		 * QUEUEING is started and finished while holding @p's rq lock.
-		 * As we're holding the rq lock now, we shouldn't see QUEUEING.
-		 */
-		BUG();
-	case SCX_OPSS_QUEUED:
-		if (SCX_HAS_OP(dequeue))
-			SCX_CALL_OP_TASK(SCX_KF_REST, dequeue, p, deq_flags);
+	if (time_before_eq(jiffies, (unsigned long)last_scan_at))
+		return;
+	last_scan_at = jiffies;
 
-		if (atomic64_try_cmpxchg(&p->scx->ops_state, &opss,
-					 SCX_OPSS_NONE))
-			break;
-		fallthrough;
-	case SCX_OPSS_DISPATCHING:
-		/*
-		 * If @p is being dispatched from the BPF scheduler to a DSQ,
-		 * wait for the transfer to complete so that @p doesn't get
-		 * added to its DSQ after dequeueing is complete.
-		 *
-		 * As we're waiting on DISPATCHING with the rq locked, the
-		 * dispatching side shouldn't try to lock the rq while
-		 * DISPATCHING is set. See dispatch_to_local_dsq().
-		 *
-		 * DISPATCHING shouldn't have qseq set and control can reach
-		 * here with NONE @opss from the above QUEUED case block.
-		 * Explicitly wait on %SCX_OPSS_DISPATCHING instead of @opss.
-		 */
-		wait_ops_state(p, SCX_OPSS_DISPATCHING);
-		BUG_ON(atomic64_read(&p->scx->ops_state) != SCX_OPSS_NONE);
-		break;
+	for (i = NON_PERIOD_START; i < NON_PERIOD_END; i++) {
+		dsq = &gdsqs[i];
+		scan_dsq_timeout(rq, dsq, SCX_BPF_DSQS_DEADLINE[i]);
 	}
 }
 
-static void dequeue_task_scx(struct rq *rq, struct task_struct *p, int deq_flags)
-{
-	struct scx_rq *scx_rq = rq->scx;
+/*******************************Initialize***********************************/
 
-	if (!(p->scx->flags & SCX_TASK_QUEUED)) {
-		WARN_ON_ONCE(watchdog_task_watched(p));
-		return;
-	}
+void init_dsq(struct scx_dispatch_q *dsq, u64 dsq_id);
+static void init_dsq_at_boot(void)
+{
+	int i, cpu;
 
-	ops_dequeue(p, deq_flags);
+	for (i = 0; i < MAX_GLOBAL_DSQS; i++) {
+		init_dsq(&gdsqs[i], (u64)SCX_DSQ_FLAG_BUILTIN |
+				(GDSQS_ID_BASE + i));
+        }
+	for_each_possible_cpu(cpu)
+		init_dsq(&per_cpu(pcp_ldsq, cpu), (u64)SCX_DSQ_FLAG_BUILTIN |
+				(GDSQS_ID_BASE + i + cpu));
 
-	/*
-	 * A currently running task which is going off @rq first gets dequeued
-	 * and then stops running. As we want running <-> stopping transitions
-	 * to be contained within runnable <-> quiescent transitions, trigger
-	 * ->stopping() early here instead of in put_prev_task_scx().
-	 *
-	 * @p may go through multiple stopping <-> running transitions between
-	 * here and put_prev_task_scx() if task attribute changes occur while
-	 * balance_scx() leaves @rq unlocked. However, they don't contain any
-	 * information meaningful to the BPF scheduler and can be suppressed by
-	 * skipping the callbacks if the task is !QUEUED.
-	 */
-	if (SCX_HAS_OP(stopping) && task_current(rq, p)) {
-		update_curr_scx(rq);
-		SCX_CALL_OP_TASK(SCX_KF_REST, stopping, p, false);
-	}
+	max_ext_dsq_internal_id = GDSQS_ID_BASE + i + cpu;
+	spin_lock_init(&sinfo.lock);
+}
 
-	//if(task_current(rq, p))
-	//	scx_update_task_ravg(p, rq, PUT_PREV_TASK, rq->clock);
 
-	if (SCX_HAS_OP(quiescent))
-		SCX_CALL_OP_TASK(SCX_KF_REST, quiescent, p, deq_flags);
+static int cgrp_name_to_idx(struct cgroup *cgrp)
+{
+	int idx;
 
-	if (deq_flags & SCX_DEQ_SLEEP)
-		p->scx->flags |= SCX_TASK_DEQD_FOR_SLEEP;
+	if (!cgrp)
+		return -1;
+
+	if (!strcmp(cgrp->kn->name, "display")
+			|| !strcmp(cgrp->kn->name, "multimedia"))
+		idx = 5; /* 8ms */
+	else if (!strcmp(cgrp->kn->name, "top-app")
+			|| !strcmp(cgrp->kn->name, "ss-top"))
+		idx = 6; /* 16ms */
+	else if (!strcmp(cgrp->kn->name, "ssfg")
+			|| !strcmp(cgrp->kn->name, "foreground"))
+		idx = 7; /* 32ms */
+	else if (!strcmp(cgrp->kn->name, "bg")
+			|| !strcmp(cgrp->kn->name, "log")
+			|| !strcmp(cgrp->kn->name, "dex2oat")
+			|| !strcmp(cgrp->kn->name, "background"))
+		idx = 9; /* 128ms */
 	else
-		p->scx->flags &= ~SCX_TASK_DEQD_FOR_SLEEP;
+		idx = DEFAULT_CGROUP_DL_IDX; /* 64ms */
 
-	p->scx->flags &= ~SCX_TASK_QUEUED;
-	BUG_ON(!scx_rq->nr_running);
-	scx_rq->nr_running--;
-	sub_nr_running(rq, 1);
+	return idx;
+}
 
-	dispatch_dequeue(scx_rq, p);
+static void init_root_tg(struct cgroup  *cgrp, struct task_group *tg)
+{
+	if (!cgrp || !tg)
+		return;
+	tg->scx_deadline_idx = DEFAULT_CGROUP_DL_IDX;
 }
 
-static void yield_task_scx(struct rq *rq)
+static void init_level1_tg(struct cgroup *cgrp, struct task_group *tg)
 {
-	struct task_struct *p = rq->curr;
+	if (!cgrp || !tg)
+		return;
 
-	if (SCX_HAS_OP(yield))
-		SCX_CALL_OP_2TASKS_RET(SCX_KF_REST, yield, p, NULL);
-	else
-		p->scx->slice = 0;
+	if (-1 == tg->scx_deadline_idx)
+		tg->scx_deadline_idx = cgrp_name_to_idx(cgrp);
 }
 
-static bool yield_to_task_scx(struct rq *rq, struct task_struct *to)
+static void init_child_tg(struct cgroup *cgrp, struct task_group *tg)
 {
-	struct task_struct *from = rq->curr;
+	struct cgroup *l1cgrp;
 
-	if (SCX_HAS_OP(yield))
-		return SCX_CALL_OP_2TASKS_RET(SCX_KF_REST, yield, from, to);
-	else
-		return false;
+	if (!cgrp || !tg)
+		return;
+
+	l1cgrp = cgroup_ancestor_l1(cgrp);
+	if (NULL == l1cgrp) {
+		pr_err("<slim_sched><error> : can't find l1 parent cgrp\n");
+		tg->scx_deadline_idx = DEFAULT_CGROUP_DL_IDX;
+		return;
+	}
+	tg->scx_deadline_idx = cgrp_name_to_idx(l1cgrp);
 }
 
-#ifdef CONFIG_SMP
-/**
- * move_task_to_local_dsq - Move a task from a different rq to a local DSQ
- * @rq: rq to move the task into, currently locked
- * @p: task to move
- * @enq_flags: %SCX_ENQ_*
- *
- * Move @p which is currently on a different rq to @rq's local DSQ. The caller
- * must:
- *
- * 1. Start with exclusive access to @p either through its DSQ lock or
- *    %SCX_OPSS_DISPATCHING flag.
- *
- * 2. Set @p->scx->holding_cpu to raw_smp_processor_id().
- *
- * 3. Remember task_rq(@p). Release the exclusive access so that we don't
- *    deadlock with dequeue.
- *
- * 4. Lock @rq and the task_rq from #3.
- *
- * 5. Call this function.
- *
- * Returns %true if @p was successfully moved. %false after racing dequeue and
- * losing.
- */
-static bool move_task_to_local_dsq(struct rq *rq, struct task_struct *p,
-				   u64 enq_flags)
+static void cgrp_dsq_idx_init(struct cgroup *cgrp, struct task_group *tg)
 {
-	struct rq *task_rq;
-
-	lockdep_assert_rq_held(rq);
+	switch (cgrp->level) {
+	case 0:
+		init_root_tg(cgrp, tg);
+		break;
+	case 1:
+		init_level1_tg(cgrp, tg);
+		break;
+	default:
+		init_child_tg(cgrp, tg);
+		break;
+	}
+}
 
-	/*
-	 * If dequeue got to @p while we were trying to lock both rq's, it'd
-	 * have cleared @p->scx->holding_cpu to -1. While other cpus may have
-	 * updated it to different values afterwards, as this operation can't be
-	 * preempted or recurse, @p->scx->holding_cpu can never become
-	 * raw_smp_processor_id() again before we're done. Thus, we can tell
-	 * whether we lost to dequeue by testing whether @p->scx->holding_cpu is
-	 * still raw_smp_processor_id().
-	 *
-	 * See dispatch_dequeue() for the counterpart.
-	 */
-	if (unlikely(p->scx->holding_cpu != raw_smp_processor_id()))
-		return false;
+/**************************************************************************/
 
-	/* @p->rq couldn't have changed if we're still the holding cpu */
-	task_rq = task_rq(p);
-	lockdep_assert_rq_held(task_rq);
+static u64 tick_sched_clock;
+static DECLARE_COMPLETION(tick_sched_clock_completion);
 
-	WARN_ON_ONCE(!cpumask_test_cpu(cpu_of(rq), p->cpus_ptr));
-	deactivate_task(task_rq, p, 0);
-	set_task_cpu(p, cpu_of(rq));
-	p->scx->sticky_cpu = cpu_of(rq);
+void scx_scheduler_tick(void)
+{
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
 
-	/*
-	 * We want to pass scx-specific enq_flags but activate_task() will
-	 * truncate the upper 32 bit. As we own @rq, we can pass them through
-	 * @rq->scx->extra_enq_flags instead.
-	 */
-	WARN_ON_ONCE(rq->scx->extra_enq_flags);
-	rq->scx->extra_enq_flags = enq_flags;
-	activate_task(rq, p, 0);
-	rq->scx->extra_enq_flags = 0;
+	if (!atomic_cmpxchg(&set_sched_clock_prepare, true, false))
+		return;
 
-	return true;
+	if(unlikely(!tick_sched_clock)) {
+		/*
+		 * Let the window begin 20us prior to the tick,
+		 * that way we are guaranteed a rollover when the tick occurs.
+		 * Use rq->clock directly instead of rq_clock() since
+		 * we do not have the rq lock and
+		 * rq->clock was updated in the tick callpath.
+		 */
+		if (cmpxchg64(&tick_sched_clock, 0, rq->clock - 20000))
+			return;
+		for_each_possible_cpu(cpu) {
+			struct scx_sched_rq_stats *srq = &per_cpu(scx_sched_rq_stats, cpu);
+			srq->window_start = tick_sched_clock;
+		}
+		complete(&tick_sched_clock_completion);
+	}
 }
 
+
+struct scx_task_iter {
+	struct sched_ext_entity		cursor;
+	struct task_struct		*locked;
+	struct rq			*rq;
+	struct rq_flags			rf;
+};
+
 /**
- * dispatch_to_local_dsq_lock - Ensure source and desitnation rq's are locked
- * @rq: current rq which is locked
- * @rf: rq_flags to use when unlocking @rq
- * @src_rq: rq to move task from
- * @dst_rq: rq to move task to
+ * scx_task_iter_init - Initialize a task iterator
+ * @iter: iterator to init
+ *
+ * Initialize @iter. Must be called with scx_tasks_lock held. Once initialized,
+ * @iter must eventually be exited with scx_task_iter_exit().
+ *
+ * scx_tasks_lock may be released between this and the first next() call or
+ * between any two next() calls. If scx_tasks_lock is released between two
+ * next() calls, the caller is responsible for ensuring that the task being
+ * iterated remains accessible either through RCU read lock or obtaining a
+ * reference count.
  *
- * We're holding @rq lock and trying to dispatch a task from @src_rq to
- * @dst_rq's local DSQ and thus need to lock both @src_rq and @dst_rq. Whether
- * @rq stays locked isn't important as long as the state is restored after
- * dispatch_to_local_dsq_unlock().
+ * All tasks which existed when the iteration started are guaranteed to be
+ * visited as long as they still exist.
  */
-static void dispatch_to_local_dsq_lock(struct rq *rq, struct rq_flags *rf,
-				       struct rq *src_rq, struct rq *dst_rq)
+static void scx_task_iter_init(struct scx_task_iter *iter)
 {
-	rq_unpin_lock(rq, rf);
+	lockdep_assert_held(&scx_tasks_lock);
 
-	if (src_rq == dst_rq) {
-		raw_spin_rq_unlock(rq);
-		raw_spin_rq_lock(dst_rq);
-	} else if (rq == src_rq) {
-		double_lock_balance(rq, dst_rq);
-		rq_repin_lock(rq, rf);
-	} else if (rq == dst_rq) {
-		double_lock_balance(rq, src_rq);
-		rq_repin_lock(rq, rf);
-	} else {
-		raw_spin_rq_unlock(rq);
-		double_rq_lock(src_rq, dst_rq);
-	}
+	iter->cursor = (struct sched_ext_entity){ .flags = SCX_TASK_CURSOR };
+	list_add(&iter->cursor.tasks_node, &scx_tasks);
+	iter->locked = NULL;
 }
 
 /**
- * dispatch_to_local_dsq_unlock - Undo dispatch_to_local_dsq_lock()
- * @rq: current rq which is locked
- * @rf: rq_flags to use when unlocking @rq
- * @src_rq: rq to move task from
- * @dst_rq: rq to move task to
+ * scx_task_iter_exit - Exit a task iterator
+ * @iter: iterator to exit
  *
- * Unlock @src_rq and @dst_rq and ensure that @rq is locked on return.
+ * Exit a previously initialized @iter. Must be called with scx_tasks_lock held.
+ * If the iterator holds a task's rq lock, that rq lock is released. See
+ * scx_task_iter_init() for details.
  */
-static void dispatch_to_local_dsq_unlock(struct rq *rq, struct rq_flags *rf,
-					 struct rq *src_rq, struct rq *dst_rq)
-{
-	if (src_rq == dst_rq) {
-		raw_spin_rq_unlock(dst_rq);
-		raw_spin_rq_lock(rq);
-		rq_repin_lock(rq, rf);
-	} else if (rq == src_rq) {
-		double_unlock_balance(rq, dst_rq);
-	} else if (rq == dst_rq) {
-		double_unlock_balance(rq, src_rq);
-	} else {
-		double_rq_unlock(src_rq, dst_rq);
-		raw_spin_rq_lock(rq);
-		rq_repin_lock(rq, rf);
+static void scx_task_iter_exit(struct scx_task_iter *iter)
+{
+	struct list_head *cursor = &iter->cursor.tasks_node;
+
+	lockdep_assert_held(&scx_tasks_lock);
+
+	if (iter->locked) {
+		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
+		iter->locked = NULL;
 	}
-}
-#endif	/* CONFIG_SMP */
 
+	if (list_empty(cursor))
+		return;
 
-static bool task_can_run_on_rq(struct task_struct *p, struct rq *rq)
-{
-	return likely(test_rq_online(rq)) && !is_migration_disabled(p) &&
-		cpumask_test_cpu(cpu_of(rq), p->cpus_ptr);
+	list_del_init(cursor);
 }
 
-static bool consume_dispatch_q(struct rq *rq, struct rq_flags *rf,
-			       struct scx_dispatch_q *dsq)
+/**
+ * scx_task_iter_next - Next task
+ * @iter: iterator to walk
+ *
+ * Visit the next task. See scx_task_iter_init() for details.
+ */
+static struct task_struct *scx_task_iter_next(struct scx_task_iter *iter)
 {
-	struct scx_rq *scx_rq = rq->scx;
-	struct sched_ext_entity *entity;
-	struct task_struct *p;
-	struct rb_node *rb_node;
-	struct rq *task_rq;
-	bool moved = false;
-retry:
-	if (list_empty(&dsq->fifo) && !rb_first_cached(&dsq->priq))
-		return false;
-
-	raw_spin_lock(&dsq->lock);
+	struct list_head *cursor = &iter->cursor.tasks_node;
+	struct sched_ext_entity *pos;
 
-	list_for_each_entry(entity, &dsq->fifo, dsq_node.fifo) {
-		p = entity->task;
-		task_rq = task_rq(p);
-		if (rq == task_rq)
-			goto this_rq;
-		if (task_can_run_on_rq(p, rq))
-			goto remote_rq;
-	}
+	lockdep_assert_held(&scx_tasks_lock);
 
-	for (rb_node = rb_first_cached(&dsq->priq); rb_node;
-	     rb_node = rb_next(rb_node)) {
-		entity = container_of(rb_node, struct sched_ext_entity, dsq_node.priq);
-		p = entity->task;
-		task_rq = task_rq(p);
-		if (rq == task_rq)
-			goto this_rq;
-		if (task_can_run_on_rq(p, rq))
-			goto remote_rq;
+	list_for_each_entry(pos, cursor, tasks_node) {
+		if (&pos->tasks_node == &scx_tasks)
+			return NULL;
+		if (!(pos->flags & SCX_TASK_CURSOR)) {
+			list_move(cursor, &pos->tasks_node);
+			return pos->task;
+		}
 	}
 
-	raw_spin_unlock(&dsq->lock);
-	return false;
-
-this_rq:
-	/* @dsq is locked and @p is on this rq */
-	WARN_ON_ONCE(p->scx->holding_cpu >= 0);
-	task_unlink_from_dsq(p, dsq);
-	list_add_tail(&p->scx->dsq_node.fifo, &scx_rq->local_dsq.fifo);
-	dsq->nr--;
-	scx_rq->local_dsq.nr++;
-	p->scx->dsq = &scx_rq->local_dsq;
-	raw_spin_unlock(&dsq->lock);
-	return true;
-
-remote_rq:
-#ifdef CONFIG_SMP
-	/*
-	 * @dsq is locked and @p is on a remote rq. @p is currently protected by
-	 * @dsq->lock. We want to pull @p to @rq but may deadlock if we grab
-	 * @task_rq while holding @dsq and @rq locks. As dequeue can't drop the
-	 * rq lock or fail, do a little dancing from our side. See
-	 * move_task_to_local_dsq().
-	 */
-	WARN_ON_ONCE(p->scx->holding_cpu >= 0);
-	task_unlink_from_dsq(p, dsq);
-	dsq->nr--;
-	p->scx->holding_cpu = raw_smp_processor_id();
-	raw_spin_unlock(&dsq->lock);
-
-	rq_unpin_lock(rq, rf);
-	double_lock_balance(rq, task_rq);
-	rq_repin_lock(rq, rf);
-
-	moved = move_task_to_local_dsq(rq, p, 0);
-
-	double_unlock_balance(rq, task_rq);
-#endif /* CONFIG_SMP */
-	if (likely(moved))
-		return true;
-	goto retry;
+	/* can't happen, should always terminate at scx_tasks above */
+	WARN_ON(1);
+	return NULL;
 }
 
-enum dispatch_to_local_dsq_ret {
-	DTL_DISPATCHED,		/* successfully dispatched */
-	DTL_LOST,		/* lost race to dequeue */
-	DTL_NOT_LOCAL,		/* destination is not a local DSQ */
-	DTL_INVALID,		/* invalid local dsq_id */
-};
-
 /**
- * dispatch_to_local_dsq - Dispatch a task to a local dsq
- * @rq: current rq which is locked
- * @rf: rq_flags to use when unlocking @rq
- * @dsq_id: destination dsq ID
- * @p: task to dispatch
- * @enq_flags: %SCX_ENQ_*
- *
- * We're holding @rq lock and want to dispatch @p to the local DSQ identified by
- * @dsq_id. This function performs all the synchronization dancing needed
- * because local DSQs are protected with rq locks.
+ * scx_task_iter_next_filtered - Next non-idle task
+ * @iter: iterator to walk
  *
- * The caller must have exclusive ownership of @p (e.g. through
- * %SCX_OPSS_DISPATCHING).
+ * Visit the next non-idle task. See scx_task_iter_init() for details.
  */
-static enum dispatch_to_local_dsq_ret
-dispatch_to_local_dsq(struct rq *rq, struct rq_flags *rf, u64 dsq_id,
-		      struct task_struct *p, u64 enq_flags)
+static struct task_struct *
+scx_task_iter_next_filtered(struct scx_task_iter *iter)
 {
-	struct rq *src_rq = task_rq(p);
-	struct rq *dst_rq;
-
-	/*
-	 * We're synchronized against dequeue through DISPATCHING. As @p can't
-	 * be dequeued, its task_rq and cpus_allowed are stable too.
-	 */
-	if (dsq_id == SCX_DSQ_LOCAL) {
-		dst_rq = rq;
-	} else if ((dsq_id & SCX_DSQ_LOCAL_ON) == SCX_DSQ_LOCAL_ON) {
-		s32 cpu = dsq_id & SCX_DSQ_LOCAL_CPU_MASK;
-
-		if (!ops_cpu_valid(cpu)) {
-			scx_ops_error("invalid cpu %d in SCX_DSQ_LOCAL_ON verdict for %s[%d]",
-				      cpu, p->comm, p->pid);
-			return DTL_INVALID;
-		}
-		dst_rq = cpu_rq(cpu);
-	} else {
-		return DTL_NOT_LOCAL;
-	}
-
-	/* if dispatching to @rq that @p is already on, no lock dancing needed */
-	if (rq == src_rq && rq == dst_rq) {
-		dispatch_enqueue(&dst_rq->scx->local_dsq, p,
-				 enq_flags | SCX_ENQ_CLEAR_OPSS);
-		return DTL_DISPATCHED;
-	}
-
-#ifdef CONFIG_SMP
-	if (cpumask_test_cpu(cpu_of(dst_rq), p->cpus_ptr)) {
-		struct rq *locked_dst_rq = dst_rq;
-		bool dsp;
-
-		/*
-		 * @p is on a possibly remote @src_rq which we need to lock to
-		 * move the task. If dequeue is in progress, it'd be locking
-		 * @src_rq and waiting on DISPATCHING, so we can't grab @src_rq
-		 * lock while holding DISPATCHING.
-		 *
-		 * As DISPATCHING guarantees that @p is wholly ours, we can
-		 * pretend that we're moving from a DSQ and use the same
-		 * mechanism - mark the task under transfer with holding_cpu,
-		 * release DISPATCHING and then follow the same protocol.
-		 */
-		p->scx->holding_cpu = raw_smp_processor_id();
-
-		/* store_release ensures that dequeue sees the above */
-		atomic64_set_release(&p->scx->ops_state, SCX_OPSS_NONE);
-
-		dispatch_to_local_dsq_lock(rq, rf, src_rq, locked_dst_rq);
-
-		/*
-		 * We don't require the BPF scheduler to avoid dispatching to
-		 * offline CPUs mostly for convenience but also because CPUs can
-		 * go offline between scx_bpf_dispatch() calls and here. If @p
-		 * is destined to an offline CPU, queue it on its current CPU
-		 * instead, which should always be safe. As this is an allowed
-		 * behavior, don't trigger an ops error.
-		 */
-		if (unlikely(!test_rq_online(dst_rq)))
-			dst_rq = src_rq;
-
-		if (src_rq == dst_rq) {
-			/*
-			 * As @p is staying on the same rq, there's no need to
-			 * go through the full deactivate/activate cycle.
-			 * Optimize by abbreviating the operations in
-			 * move_task_to_local_dsq().
-			 */
-			dsp = p->scx->holding_cpu == raw_smp_processor_id();
-			if (likely(dsp)) {
-				p->scx->holding_cpu = -1;
-				dispatch_enqueue(&dst_rq->scx->local_dsq, p,
-						 enq_flags);
-			}
-		} else {
-			dsp = move_task_to_local_dsq(dst_rq, p, enq_flags);
-		}
-
-		/* if the destination CPU is idle, wake it up */
-		if (dsp && p->sched_class > dst_rq->curr->sched_class)
-			resched_curr(dst_rq);
-
-		dispatch_to_local_dsq_unlock(rq, rf, src_rq, locked_dst_rq);
+	struct task_struct *p;
 
-		return dsp ? DTL_DISPATCHED : DTL_LOST;
+	while ((p = scx_task_iter_next(iter))) {
+		if (!is_idle_task(p))
+			return p;
 	}
-#endif /* CONFIG_SMP */
-
-	scx_ops_error("SCX_DSQ_LOCAL[_ON] verdict target cpu %d not allowed for %s[%d]",
-		      cpu_of(dst_rq), p->comm, p->pid);
-	return DTL_INVALID;
+	return NULL;
 }
 
 /**
- * finish_dispatch - Asynchronously finish dispatching a task
- * @rq: current rq which is locked
- * @rf: rq_flags to use when unlocking @rq
- * @p: task to finish dispatching
- * @qseq_at_dispatch: qseq when @p started getting dispatched
- * @dsq_id: destination DSQ ID
- * @enq_flags: %SCX_ENQ_*
- *
- * Dispatching to local DSQs may need to wait for queueing to complete or
- * require rq lock dancing. As we don't wanna do either while inside
- * ops.dispatch() to avoid locking order inversion, we split dispatching into
- * two parts. scx_bpf_dispatch() which is called by ops.dispatch() records the
- * task and its qseq. Once ops.dispatch() returns, this function is called to
- * finish up.
+ * scx_task_iter_next_filtered_locked - Next non-idle task with its rq locked
+ * @iter: iterator to walk
  *
- * There is no guarantee that @p is still valid for dispatching or even that it
- * was valid in the first place. Make sure that the task is still owned by the
- * BPF scheduler and claim the ownership before dispatching.
+ * Visit the next non-idle task with its rq lock held. See scx_task_iter_init()
+ * for details.
  */
-static void finish_dispatch(struct rq *rq, struct rq_flags *rf,
-			    struct task_struct *p, u64 qseq_at_dispatch,
-			    u64 dsq_id, u64 enq_flags)
+static struct task_struct *
+scx_task_iter_next_filtered_locked(struct scx_task_iter *iter)
 {
-	struct scx_dispatch_q *dsq;
-	u64 opss;
-
-	touch_core_sched_dispatch(rq, p);
-retry:
-	/*
-	 * No need for _acquire here. @p is accessed only after a successful
-	 * try_cmpxchg to DISPATCHING.
-	 */
-	opss = atomic64_read(&p->scx->ops_state);
-
-	switch (opss & SCX_OPSS_STATE_MASK) {
-	case SCX_OPSS_DISPATCHING:
-	case SCX_OPSS_NONE:
-		/* someone else already got to it */
-		return;
-	case SCX_OPSS_QUEUED:
-		/*
-		 * If qseq doesn't match, @p has gone through at least one
-		 * dispatch/dequeue and re-enqueue cycle between
-		 * scx_bpf_dispatch() and here and we have no claim on it.
-		 */
-		if ((opss & SCX_OPSS_QSEQ_MASK) != qseq_at_dispatch)
-			return;
+	struct task_struct *p;
 
-		/*
-		 * While we know @p is accessible, we don't yet have a claim on
-		 * it - the BPF scheduler is allowed to dispatch tasks
-		 * spuriously and there can be a racing dequeue attempt. Let's
-		 * claim @p by atomically transitioning it from QUEUED to
-		 * DISPATCHING.
-		 */
-		if (likely(atomic64_try_cmpxchg(&p->scx->ops_state, &opss,
-						SCX_OPSS_DISPATCHING)))
-			break;
-		goto retry;
-	case SCX_OPSS_QUEUEING:
-		/*
-		 * do_enqueue_task() is in the process of transferring the task
-		 * to the BPF scheduler while holding @p's rq lock. As we aren't
-		 * holding any kernel or BPF resource that the enqueue path may
-		 * depend upon, it's safe to wait.
-		 */
-		wait_ops_state(p, opss);
-		goto retry;
+	if (iter->locked) {
+		task_rq_unlock(iter->rq, iter->locked, &iter->rf);
+		iter->locked = NULL;
 	}
 
-	BUG_ON(!(p->scx->flags & SCX_TASK_QUEUED));
+	p = scx_task_iter_next_filtered(iter);
+	if (!p)
+		return NULL;
 
-	switch (dispatch_to_local_dsq(rq, rf, dsq_id, p, enq_flags)) {
-	case DTL_DISPATCHED:
-		break;
-	case DTL_LOST:
-		break;
-	case DTL_INVALID:
-		dsq_id = SCX_DSQ_GLOBAL;
-		fallthrough;
-	case DTL_NOT_LOCAL:
-		dsq = find_dsq_for_dispatch(cpu_rq(raw_smp_processor_id()),
-					    dsq_id, p);
-		dispatch_enqueue(dsq, p, enq_flags | SCX_ENQ_CLEAR_OPSS);
-		break;
-	}
+	iter->rq = task_rq_lock(p, &iter->rf);
+	iter->locked = p;
+	return p;
 }
 
-static void flush_dispatch_buf(struct rq *rq, struct rq_flags *rf)
+static enum scx_ops_enable_state scx_ops_enable_state(void)
 {
-	struct scx_dsp_ctx *dspc = this_cpu_ptr(&scx_dsp_ctx);
-	u32 u;
+	return atomic_read(&scx_ops_enable_state_var);
+}
 
-	for (u = 0; u < dspc->buf_cursor; u++) {
-		struct scx_dsp_buf_ent *ent = &this_cpu_ptr(scx_dsp_buf)[u];
+static enum scx_ops_enable_state
+scx_ops_set_enable_state(enum scx_ops_enable_state to)
+{
+	return atomic_xchg(&scx_ops_enable_state_var, to);
+}
 
-		finish_dispatch(rq, rf, ent->task, ent->qseq, ent->dsq_id,
-				ent->enq_flags);
-	}
+static bool scx_ops_tryset_enable_state(enum scx_ops_enable_state to,
+					enum scx_ops_enable_state from)
+{
+	int from_v = from;
 
-	dspc->nr_tasks += dspc->buf_cursor;
-	dspc->buf_cursor = 0;
+	return atomic_try_cmpxchg(&scx_ops_enable_state_var, &from_v, to);
 }
 
-static int balance_one(struct rq *rq, struct task_struct *prev,
-		       struct rq_flags *rf, bool local)
+static bool scx_ops_disabling(void)
 {
-	struct scx_rq *scx_rq = rq->scx;
-	struct scx_dsp_ctx *dspc = this_cpu_ptr(&scx_dsp_ctx);
-	bool prev_on_scx = prev->sched_class == &ext_sched_class;
-	int nr_loops = SCX_DSP_MAX_LOOPS;
-
-	lockdep_assert_rq_held(rq);
+	return false;
+/*	return unlikely(scx_ops_enable_state() == SCX_OPS_DISABLING);*/
+}
 
-	if (static_branch_unlikely(&scx_ops_cpu_preempt) &&
-	    unlikely(rq->scx->cpu_released)) {
-		/*
-		 * If the previous sched_class for the current CPU was not SCX,
-		 * notify the BPF scheduler that it again has control of the
-		 * core. This callback complements ->cpu_release(), which is
-		 * emitted in scx_notify_pick_next_task().
-		 */
-		if (SCX_HAS_OP(cpu_acquire))
-			SCX_CALL_OP(SCX_KF_UNLOCKED, cpu_acquire, cpu_of(rq),
-				    NULL);
-		rq->scx->cpu_released = false;
-	}
+/**
+ * wait_ops_state - Busy-wait the specified ops state to end
+ * @p: target task
+ * @opss: state to wait the end of
+ *
+ * Busy-wait for @p to transition out of @opss. This can only be used when the
+ * state part of @opss is %SCX_QUEUEING or %SCX_DISPATCHING. This function also
+ * has load_acquire semantics to ensure that the caller can see the updates made
+ * in the enqueueing and dispatching paths.
+ */
+static void wait_ops_state(struct task_struct *p, u64 opss)
+{
+	do {
+		cpu_relax();
+	} while (atomic64_read_acquire(&p->scx->ops_state) == opss);
+}
 
-	if (prev_on_scx) {
-		WARN_ON_ONCE(local && (prev->scx->flags & SCX_TASK_BAL_KEEP));
-		update_curr_scx(rq);
 
-		/*
-		 * If @prev is runnable & has slice left, it has priority and
-		 * fetching more just increases latency for the fetched tasks.
-		 * Tell put_prev_task_scx() to put @prev on local_dsq. If the
-		 * BPF scheduler wants to handle this explicitly, it should
-		 * implement ->cpu_released().
-		 *
-		 * See scx_ops_disable_workfn() for the explanation on the
-		 * disabling() test.
-		 *
-		 * When balancing a remote CPU for core-sched, there won't be a
-		 * following put_prev_task_scx() call and we don't own
-		 * %SCX_TASK_BAL_KEEP. Instead, pick_task_scx() will test the
-		 * same conditions later and pick @rq->curr accordingly.
-		 */
-		if ((prev->scx->flags & SCX_TASK_QUEUED) &&
-		    prev->scx->slice && !scx_ops_disabling()) {
-			if (local)
-				prev->scx->flags |= SCX_TASK_BAL_KEEP;
-			return 1;
-		}
-	}
+static void update_curr_scx(struct rq *rq)
+{
+	struct task_struct *curr = rq->curr;
+	u64 now = rq_clock_task(rq);
+	u64 delta_exec;
 
-	/* if there already are tasks to run, nothing to do */
-	if (scx_rq->local_dsq.nr)
-		return 1;
+	if (time_before_eq64(now, curr->se.exec_start))
+		return;
 
-	if (consume_dispatch_q(rq, rf, &scx_dsq_global))
-		return 1;
+	delta_exec = now - curr->se.exec_start;
+	curr->se.exec_start = now;
+	update_runningtime(rq, curr, delta_exec);
+	curr->se.sum_exec_runtime += delta_exec;
+	account_group_exec_runtime(curr, delta_exec);
+	cgroup_account_cputime(curr, delta_exec);
 
-	if (!SCX_HAS_OP(dispatch))
-		return 0;
+	if (curr->scx->slice != SCX_SLICE_INF)
+		curr->scx->slice -= min(curr->scx->slice, delta_exec);
 
-	dspc->rq = rq;
-	dspc->rf = rf;
+	trace_sched_stat_runtime(curr, delta_exec, 0);
+}
 
-	/*
-	 * The dispatch loop. Because flush_dispatch_buf() may drop the rq lock,
-	 * the local DSQ might still end up empty after a successful
-	 * ops.dispatch(). If the local DSQ is empty even after ops.dispatch()
-	 * produced some tasks, retry. The BPF scheduler may depend on this
-	 * looping behavior to simplify its implementation.
-	 */
-	do {
-		dspc->nr_tasks = 0;
+static bool scx_dsq_priq_less(struct rb_node *node_a,
+			      const struct rb_node *node_b)
+{
+	const struct sched_ext_entity *a =
+		container_of(node_a, struct sched_ext_entity, dsq_node.priq);
+	const struct sched_ext_entity *b =
+		container_of(node_b, struct sched_ext_entity, dsq_node.priq);
 
-		SCX_CALL_OP(SCX_KF_DISPATCH, dispatch, cpu_of(rq),
-			    prev_on_scx ? prev : NULL);
+	return time_before64(a->dsq_vtime, b->dsq_vtime);
+}
 
-		flush_dispatch_buf(rq, rf);
+static void dispatch_enqueue(struct scx_dispatch_q *dsq, struct task_struct *p,
+			     u64 enq_flags)
+{
+	bool is_local = dsq->id == SCX_DSQ_LOCAL;
+	unsigned long flags;
 
-		if (scx_rq->local_dsq.nr)
-			return 1;
-		if (consume_dispatch_q(rq, rf, &scx_dsq_global))
-			return 1;
+	WARN_ON_ONCE(p->scx->dsq || !list_empty(&p->scx->dsq_node.fifo));
+	WARN_ON_ONCE((p->scx->dsq_flags & SCX_TASK_DSQ_ON_PRIQ) ||
+		     !RB_EMPTY_NODE(&p->scx->dsq_node.priq));
 
-		/*
-		 * ops.dispatch() can trap us in this loop by repeatedly
-		 * dispatching ineligible tasks. Break out once in a while to
-		 * allow the watchdog to run. As IRQ can't be enabled in
-		 * balance(), we want to complete this scheduling cycle and then
-		 * start a new one. IOW, we want to call resched_curr() on the
-		 * next, most likely idle, task, not the current one. Use
-		 * scx_bpf_kick_cpu() for deferred kicking.
-		 */
-		if (unlikely(!--nr_loops)) {
-			scx_bpf_kick_cpu(cpu_of(rq), 0);
-			break;
+	if (!is_local) {
+		raw_spin_lock_irqsave(&dsq->lock, flags);
+		if (unlikely(dsq->id == SCX_DSQ_INVALID)) {
+			scx_ops_error("attempting to dispatch to a destroyed dsq");
+			/* fall back to the global dsq */
+			raw_spin_unlock_irqrestore(&dsq->lock, flags);
+			dsq = &scx_dsq_global;
+			raw_spin_lock_irqsave(&dsq->lock, flags);
 		}
-	} while (dspc->nr_tasks);
-
-	return 0;
-}
+	}
 
-static int balance_scx(struct rq *rq, struct task_struct *prev,
-		       struct rq_flags *rf)
-{
-	int ret;
+	if (enq_flags & SCX_ENQ_DSQ_PRIQ) {
+		p->scx->dsq_flags |= SCX_TASK_DSQ_ON_PRIQ;
+		rb_add_cached(&p->scx->dsq_node.priq, &dsq->priq,
+			      scx_dsq_priq_less);
+	} else {
+		if (enq_flags & (SCX_ENQ_HEAD | SCX_ENQ_PREEMPT))
+			list_add(&p->scx->dsq_node.fifo, &dsq->fifo);
+		else
+			list_add_tail(&p->scx->dsq_node.fifo, &dsq->fifo);
+	}
+	dsq->nr++;
+	p->scx->dsq = dsq;
 
-	ret = balance_one(rq, prev, rf, true);
-#ifdef CONFIG_SCHED_SMT
 	/*
-	 * When core-sched is enabled, this ops.balance() call will be followed
-	 * by put_prev_scx() and pick_task_scx() on this CPU and pick_task_scx()
-	 * on the SMT siblings. Balance the siblings too.
+	 * We're transitioning out of QUEUEING or DISPATCHING. store_release to
+	 * match waiters' load_acquire.
 	 */
-	if (sched_core_enabled(rq)) {
-		const struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));
-		int scpu;
-
-		for_each_cpu_andnot(scpu, smt_mask, cpumask_of(cpu_of(rq))) {
-			struct rq *srq = cpu_rq(scpu);
-			struct rq_flags srf;
-			struct task_struct *sprev = srq->curr;
-
-			/*
-			 * While core-scheduling, rq lock is shared among
-			 * siblings but the debug annotations and rq clock
-			 * aren't. Do pinning dance to transfer the ownership.
-			 */
-			WARN_ON_ONCE(__rq_lockp(rq) != __rq_lockp(srq));
-			rq_unpin_lock(rq, rf);
-			rq_pin_lock(srq, &srf);
+	if (enq_flags & SCX_ENQ_CLEAR_OPSS)
+		atomic64_set_release(&p->scx->ops_state, SCX_OPSS_NONE);
 
-			update_rq_clock(srq);
-			balance_one(srq, sprev, &srf, false);
+	if (is_local) {
+		struct scx_rq *scx = container_of(dsq, struct scx_rq, local_dsq);
+		struct rq *rq = scx->rq;
+		bool preempt = false;
 
-			rq_unpin_lock(srq, &srf);
-			rq_repin_lock(rq, rf);
+		if ((enq_flags & SCX_ENQ_PREEMPT) && p != rq->curr &&
+		    rq->curr->sched_class == &ext_sched_class) {
+			rq->curr->scx->slice = 0;
+			preempt = true;
 		}
+
+		if (preempt || sched_class_above(&ext_sched_class,
+						 rq->curr->sched_class))
+			resched_curr(rq);
+	} else {
+		raw_spin_unlock_irqrestore(&dsq->lock, flags);
 	}
-#endif
-	return ret;
 }
 
-static void set_next_task_scx(struct rq *rq, struct task_struct *p, bool first)
+static void task_unlink_from_dsq(struct task_struct *p,
+				 struct scx_dispatch_q *dsq)
 {
-	if (p->scx->flags & SCX_TASK_QUEUED) {
-		/*
-		 * Core-sched might decide to execute @p before it is
-		 * dispatched. Call ops_dequeue() to notify the BPF scheduler.
-		 */
-		ops_dequeue(p, SCX_DEQ_CORE_SCHED_EXEC);
-		dispatch_dequeue(rq->scx, p);
-	}
-
-	p->se.exec_start = rq_clock_task(rq);
-
-	/* see dequeue_task_scx() on why we skip when !QUEUED */
-	if (SCX_HAS_OP(running) && (p->scx->flags & SCX_TASK_QUEUED))
-		SCX_CALL_OP_TASK(SCX_KF_REST, running, p);
-
-	//if(p->scx->flags & SCX_TASK_QUEUED)
-	//	scx_update_task_ravg(p, rq, PICK_NEXT_TASK, rq->clock);
-
-	watchdog_unwatch_task(p, true);
-
-	/*
-	 * @p is getting newly scheduled or got kicked after someone updated its
-	 * slice. Refresh whether tick can be stopped. See can_stop_tick_scx().
-	 */
-	if ((p->scx->slice == SCX_SLICE_INF) !=
-	    (bool)(rq->scx->flags & SCX_RQ_CAN_STOP_TICK)) {
-		if (p->scx->slice == SCX_SLICE_INF)
-			rq->scx->flags |= SCX_RQ_CAN_STOP_TICK;
-		else
-			rq->scx->flags &= ~SCX_RQ_CAN_STOP_TICK;
-
-		sched_update_tick_dependency(rq);
+	if (p->scx->dsq_flags & SCX_TASK_DSQ_ON_PRIQ) {
+		rb_erase_cached(&p->scx->dsq_node.priq, &dsq->priq);
+		RB_CLEAR_NODE(&p->scx->dsq_node.priq);
+		p->scx->dsq_flags &= ~SCX_TASK_DSQ_ON_PRIQ;
+	} else {
+		list_del_init(&p->scx->dsq_node.fifo);
 	}
 }
 
-static void put_prev_task_scx(struct rq *rq, struct task_struct *p)
+static bool task_linked_on_dsq(struct task_struct *p)
 {
-#ifndef CONFIG_SMP
-	/*
-	 * UP workaround.
-	 *
-	 * Because SCX may transfer tasks across CPUs during dispatch, dispatch
-	 * is performed from its balance operation which isn't called in UP.
-	 * Let's work around by calling it from the operations which come right
-	 * after.
-	 *
-	 * 1. If the prev task is on SCX, pick_next_task() calls
-	 *    .put_prev_task() right after. As .put_prev_task() is also called
-	 *    from other places, we need to distinguish the calls which can be
-	 *    done by looking at the previous task's state - if still queued or
-	 *    dequeued with %SCX_DEQ_SLEEP, the caller must be pick_next_task().
-	 *    This case is handled here.
-	 *
-	 * 2. If the prev task is not on SCX, the first following call into SCX
-	 *    will be .pick_next_task(), which is covered by calling
-	 *    balance_scx() from pick_next_task_scx().
-	 *
-	 * Note that we can't merge the first case into the second as
-	 * balance_scx() must be called before the previous SCX task goes
-	 * through put_prev_task_scx().
-	 *
-	 * As UP doesn't transfer tasks around, balance_scx() doesn't need @rf.
-	 * Pass in %NULL.
-	 */
-	if (p->scx->flags & (SCX_TASK_QUEUED | SCX_TASK_DEQD_FOR_SLEEP))
-		balance_scx(rq, p, NULL);
-#endif
-
-	update_curr_scx(rq);
-
-	/* see dequeue_task_scx() on why we skip when !QUEUED */
-	if (SCX_HAS_OP(stopping) && (p->scx->flags & SCX_TASK_QUEUED))
-		SCX_CALL_OP_TASK(SCX_KF_REST, stopping, p, true);
-
-	//if(p->scx->flags & SCX_TASK_QUEUED)
-	//	scx_update_task_ravg(p, rq, PUT_PREV_TASK, rq->clock);
+	return !list_empty(&p->scx->dsq_node.fifo) ||
+		!RB_EMPTY_NODE(&p->scx->dsq_node.priq);
+}
 
+static void dispatch_dequeue(struct scx_rq *scx_rq, struct task_struct *p)
+{
+	unsigned long flags;
+	struct scx_dispatch_q *dsq = p->scx->dsq;
+	bool is_local = dsq == &scx_rq->local_dsq;
 
-	/*
-	 * If we're being called from put_prev_task_balance(), balance_scx() may
-	 * have decided that @p should keep running.
-	 */
-	if (p->scx->flags & SCX_TASK_BAL_KEEP) {
-		p->scx->flags &= ~SCX_TASK_BAL_KEEP;
-		watchdog_watch_task(rq, p);
-		dispatch_enqueue(&rq->scx->local_dsq, p, SCX_ENQ_HEAD);
+	if (!dsq) {
+		WARN_ON_ONCE(task_linked_on_dsq(p));
+		/*
+		 * When dispatching directly from the BPF scheduler to a local
+		 * DSQ, the task isn't associated with any DSQ but
+		 * @p->scx->holding_cpu may be set under the protection of
+		 * %SCX_OPSS_DISPATCHING.
+		 */
+		if (p->scx->holding_cpu >= 0)
+			p->scx->holding_cpu = -1;
 		return;
 	}
 
-	if (p->scx->flags & SCX_TASK_QUEUED) {
-		watchdog_watch_task(rq, p);
-
-		/*
-		 * If @p has slice left and balance_scx() didn't tag it for
-		 * keeping, @p is getting preempted by a higher priority
-		 * scheduler class or core-sched forcing a different task. Leave
-		 * it at the head of the local DSQ.
-		 */
-		if (p->scx->slice && !scx_ops_disabling()) {
-			dispatch_enqueue(&rq->scx->local_dsq, p, SCX_ENQ_HEAD);
-			return;
-		}
+	if (!is_local)
+		raw_spin_lock_irqsave(&dsq->lock, flags);
 
+	/*
+	 * Now that we hold @dsq->lock, @p->holding_cpu and @p->scx->dsq_node
+	 * can't change underneath us.
+	*/
+	if (p->scx->holding_cpu < 0) {
+		/* @p must still be on @dsq, dequeue */
+		WARN_ON_ONCE(!task_linked_on_dsq(p));
+		task_unlink_from_dsq(p, dsq);
+		dsq->nr--;
+	} else {
 		/*
-		 * If we're in the pick_next_task path, balance_scx() should
-		 * have already populated the local DSQ if there are any other
-		 * available tasks. If empty, tell ops.enqueue() that @p is the
-		 * only one available for this cpu. ops.enqueue() should put it
-		 * on the local DSQ so that the subsequent pick_next_task_scx()
-		 * can find the task unless it wants to trigger a separate
-		 * follow-up scheduling event.
+		 * We're racing against dispatch_to_local_dsq() which already
+		 * removed @p from @dsq and set @p->scx->holding_cpu. Clear the
+		 * holding_cpu which tells dispatch_to_local_dsq() that it lost
+		 * the race.
 		 */
-		if (list_empty(&rq->scx->local_dsq.fifo))
-			do_enqueue_task(rq, p, SCX_ENQ_LAST | SCX_ENQ_LOCAL, -1);
-		else
-			do_enqueue_task(rq, p, 0, -1);
+		WARN_ON_ONCE(task_linked_on_dsq(p));
+		p->scx->holding_cpu = -1;
 	}
+	p->scx->dsq = NULL;
+
+	if (!is_local)
+		raw_spin_unlock_irqrestore(&dsq->lock, flags);
 }
 
-static struct task_struct *first_local_task(struct rq *rq)
+
+static bool test_rq_online(struct rq *rq)
 {
-	struct rb_node *rb_node;
-	struct sched_ext_entity *entity;
+#ifdef CONFIG_SMP
+	return rq->online;
+#else
+	return true;
+#endif
+}
 
-	if (!list_empty(&rq->scx->local_dsq.fifo)) {
-		entity = list_first_entry(&rq->scx->local_dsq.fifo, struct sched_ext_entity, dsq_node.fifo);
-		return entity->task;
+
+static void do_enqueue_task(struct rq *rq, struct task_struct *p, u64 enq_flags,
+			    int sticky_cpu)
+{
+	struct scx_dispatch_q* d;
+	WARN_ON_ONCE(!test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags));
+
+	if (is_pcp_rt(p)) {
+		/* Enqueue percpu rt task to local directly. */
+		/* Or cause a bug when disable dispatch. */
+		if (cpumask_test_cpu(cpu_of(rq), p->cpus_ptr))
+			enq_flags |= SCX_ENQ_LOCAL;
 	}
 
-	rb_node = rb_first_cached(&rq->scx->local_dsq.priq);
-	if (rb_node) {
-		entity = container_of(rb_node, struct sched_ext_entity, dsq_node.priq);
-		return entity->task;
+	if (test_bit(ffs(SCX_TASK_ENQ_LOCAL), (unsigned long*)&p->scx->flags)) {
+		enq_flags |= SCX_ENQ_LOCAL;
+		clear_bit(ffs(SCX_TASK_ENQ_LOCAL), (unsigned long*)&p->scx->flags);
 	}
+	/* rq migration */
+	if (sticky_cpu == cpu_of(rq))
+		goto local_norefill;
+	/*
+	 * If !rq->online, we already told the BPF scheduler that the CPU is
+	 * offline. We're just trying to on/offline the CPU. Don't bother the
+	 * BPF scheduler.
+	 */
+	if (unlikely(!test_rq_online(rq)))
+		goto local;
 
-	return NULL;
-}
+	/* see %SCX_OPS_ENQ_EXITING */
+	if (unlikely(p->flags & PF_EXITING))
+		goto local;
 
-static struct task_struct *pick_next_task_scx(struct rq *rq)
-{
-	struct task_struct *p;
+	/* see %SCX_OPS_ENQ_LAST */
+	if (enq_flags & SCX_ENQ_LAST)
+		goto local;
 
-#ifndef CONFIG_SMP
-	/* UP workaround - see the comment at the head of put_prev_task_scx() */
-	if (unlikely(rq->curr->sched_class != &ext_sched_class))
-		balance_scx(rq, rq->curr, NULL);
-#endif
+	if (enq_flags & SCX_ENQ_LOCAL)
+		goto local;
+	else
+		goto global;
 
-	p = first_local_task(rq);
-	if (!p)
-		return NULL;
+local:
+	/*
+	 * For task-ordering, slice refill must be treated as implying the end
+	 * of the current slice. Otherwise, the longer @p stays on the CPU, the
+	 * higher priority it becomes from scx_prio_less()'s POV.
+	 */
+	p->scx->slice = SCX_SLICE_DFL;
+local_norefill:
+	dispatch_enqueue(&rq->scx->local_dsq, p, enq_flags);
+	slim_stats_record(PCP_ENQL_CNT, 0, 0, cpu_of(rq));
+	return;
 
-	if (unlikely(!p->scx->slice)) {
-		if (!scx_ops_disabling() && !scx_warned_zero_slice) {
-			printk_deferred(KERN_WARNING "sched_ext: %s[%d] has zero slice in pick_next_task_scx()\n",
-					p->comm, p->pid);
-			scx_warned_zero_slice = true;
-		}
+global:
+	d = find_dsq_from_task(p);
+	if (d) {
 		p->scx->slice = SCX_SLICE_DFL;
+		dispatch_enqueue(d, p, enq_flags);
+		return;
 	}
-
-	set_next_task_scx(rq, p, true);
-
-	return p;
+	slim_stats_record(GLOBAL_STAT, 0, 0, 0);
+	p->scx->slice = SCX_SLICE_DFL;
+	dispatch_enqueue(&scx_dsq_global, p, enq_flags);
 }
 
-#ifdef CONFIG_SCHED_CORE
-/**
- * scx_prio_less - Task ordering for core-sched
- * @a: task A
- * @b: task B
- *
- * Core-sched is implemented as an additional scheduling layer on top of the
- * usual sched_class'es and needs to find out the expected task ordering. For
- * SCX, core-sched calls this function to interrogate the task ordering.
- *
- * Unless overridden by ops.core_sched_before(), @p->scx->core_sched_at is used
- * to implement the default task ordering. The older the timestamp, the higher
- * prority the task - the global FIFO ordering matching the default scheduling
- * behavior.
- *
- * When ops.core_sched_before() is enabled, @p->scx->core_sched_at is used to
- * implement FIFO ordering within each local DSQ. See pick_task_scx().
- */
-bool scx_prio_less(const struct task_struct *a, const struct task_struct *b,
-		   bool in_fi)
+static bool watchdog_task_watched(const struct task_struct *p)
 {
-	/*
-	 * The const qualifiers are dropped from task_struct pointers when
-	 * calling ops.core_sched_before(). Accesses are controlled by the
-	 * verifier.
-	 */
-	if (SCX_HAS_OP(core_sched_before) && !scx_ops_disabling())
-		return SCX_CALL_OP_2TASKS_RET(SCX_KF_REST, core_sched_before,
-					      (struct task_struct *)a,
-					      (struct task_struct *)b);
-	else
-		return time_after64(a->scx->core_sched_at, b->scx->core_sched_at);
+	return !list_empty(&p->scx->watchdog_node);
 }
 
-/**
- * pick_task_scx - Pick a candidate task for core-sched
- * @rq: rq to pick the candidate task from
- *
- * Core-sched calls this function on each SMT sibling to determine the next
- * tasks to run on the SMT siblings. balance_one() has been called on all
- * siblings and put_prev_task_scx() has been called only for the current CPU.
- *
- * As put_prev_task_scx() hasn't been called on remote CPUs, we can't just look
- * at the first task in the local dsq. @rq->curr has to be considered explicitly
- * to mimic %SCX_TASK_BAL_KEEP.
- */
-static struct task_struct *pick_task_scx(struct rq *rq)
+static void watchdog_watch_task(struct rq *rq, struct task_struct *p)
 {
-	struct task_struct *curr = rq->curr;
-	struct task_struct *first = first_local_task(rq);
-
-	if (curr->scx->flags & SCX_TASK_QUEUED) {
-		/* is curr the only runnable task? */
-		if (!first)
-			return curr;
-
-		/*
-		 * Does curr trump first? We can always go by core_sched_at for
-		 * this comparison as it represents global FIFO ordering when
-		 * the default core-sched ordering is used and local-DSQ FIFO
-		 * ordering otherwise.
-		 *
-		 * We can have a task with an earlier timestamp on the DSQ. For
-		 * example, when a current task is preempted by a sibling
-		 * picking a different cookie, the task would be requeued at the
-		 * head of the local DSQ with an earlier timestamp than the
-		 * core-sched picked next task. Besides, the BPF scheduler may
-		 * dispatch any tasks to the local DSQ anytime.
-		 */
-		if (curr->scx->slice && time_before64(curr->scx->core_sched_at,
-						     first->scx->core_sched_at))
-			return curr;
-	}
-
-	return first;	/* this may be %NULL */
+	lockdep_assert_rq_held(rq);
+	if (test_bit(ffs(SCX_TASK_WATCHDOG_RESET), (unsigned long*)&p->scx->flags))
+		p->scx->runnable_at = jiffies;
+	clear_bit(ffs(SCX_TASK_WATCHDOG_RESET), (unsigned long*)&p->scx->flags);
+	list_add_tail(&p->scx->watchdog_node, &rq->scx->watchdog_list);
 }
-#endif	/* CONFIG_SCHED_CORE */
 
-static enum scx_cpu_preempt_reason
-preempt_reason_from_class(const struct sched_class *class)
+static void watchdog_unwatch_task(struct task_struct *p, bool reset_timeout)
 {
-#ifdef CONFIG_SMP
-	if (class == &stop_sched_class)
-		return SCX_CPU_PREEMPT_STOP;
-#endif
-	if (class == &dl_sched_class)
-		return SCX_CPU_PREEMPT_DL;
-	if (class == &rt_sched_class)
-		return SCX_CPU_PREEMPT_RT;
-	return SCX_CPU_PREEMPT_UNKNOWN;
+	list_del_init(&p->scx->watchdog_node);
+	if (reset_timeout)
+		set_bit(ffs(SCX_TASK_WATCHDOG_RESET), (unsigned long*)&p->scx->flags);
 }
 
-void __scx_notify_pick_next_task(struct rq *rq, struct task_struct *task,
-				 const struct sched_class *active)
+static void enqueue_task_scx(struct rq *rq, struct task_struct *p, int enq_flags)
 {
-	lockdep_assert_rq_held(rq);
+	int sticky_cpu = p->scx->sticky_cpu;
+
+	enq_flags |= rq->scx->extra_enq_flags;
+
+	if (sticky_cpu >= 0)
+		p->scx->sticky_cpu = -1;
 
 	/*
-	 * The callback is conceptually meant to convey that the CPU is no
-	 * longer under the control of SCX. Therefore, don't invoke the
-	 * callback if the CPU is is staying on SCX, or going idle (in which
-	 * case the SCX scheduler has actively decided not to schedule any
-	 * tasks on the CPU).
+	 * Restoring a running task will be immediately followed by
+	 * set_next_task_scx() which expects the task to not be on the BPF
+	 * scheduler as tasks can only start running through local DSQs. Force
+	 * direct-dispatch into the local DSQ by setting the sticky_cpu.
 	 */
-	if (likely(active >= &ext_sched_class))
-		return;
+	if (unlikely(enq_flags & ENQUEUE_RESTORE) && task_current(rq, p))
+		sticky_cpu = cpu_of(rq);
 
-	/*
-	 * At this point we know that SCX was preempted by a higher priority
-	 * sched_class, so invoke the ->cpu_release() callback if we have not
-	 * done so already. We only send the callback once between SCX being
-	 * preempted, and it regaining control of the CPU.
-	 *
-	 * ->cpu_release() complements ->cpu_acquire(), which is emitted the
-	 *  next time that balance_scx() is invoked.
-	 */
-	if (!rq->scx->cpu_released) {
-		if (SCX_HAS_OP(cpu_release)) {
-			struct scx_cpu_release_args args = {
-				.reason = preempt_reason_from_class(active),
-				.task = task,
-			};
-
-			SCX_CALL_OP(SCX_KF_CPU_RELEASE,
-				    cpu_release, cpu_of(rq), &args);
-		}
-		rq->scx->cpu_released = true;
+	if (test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags)) {
+		WARN_ON_ONCE(!watchdog_task_watched(p));
+		return;
 	}
-}
 
-#ifdef CONFIG_SMP
+	watchdog_watch_task(rq, p);
+	set_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags);
+	rq->scx->nr_running++;
+	add_nr_running(rq, 1);
 
-static bool test_and_clear_cpu_idle(int cpu)
-{
-	if (cpumask_test_and_clear_cpu(cpu, idle_masks.cpu)) {
-		if (cpumask_empty(idle_masks.cpu))
-			scx_has_idle_cpus = false;
-		return true;
-	} else {
-		return false;
-	}
+	do_enqueue_task(rq, p, enq_flags, sticky_cpu);
 }
 
-static s32 scx_pick_idle_cpu(const struct cpumask *cpus_allowed)
+static void ops_dequeue(struct task_struct *p, u64 deq_flags)
 {
-	int cpu;
+	u64 opss;
 
-	do {
-		cpu = cpumask_any_and_distribute(idle_masks.smt, cpus_allowed);
-		if (cpu < nr_cpu_ids) {
-			const struct cpumask *sbm = topology_sibling_cpumask(cpu);
+	watchdog_unwatch_task(p, false);
 
-			/*
-			 * If offline, @cpu is not its own sibling and we can
-			 * get caught in an infinite loop as @cpu is never
-			 * cleared from idle_masks.smt. Clear @cpu directly in
-			 * such cases.
-			 */
-			if (likely(cpumask_test_cpu(cpu, sbm)))
-				cpumask_andnot(idle_masks.smt, idle_masks.smt, sbm);
-			else
-				cpumask_andnot(idle_masks.smt, idle_masks.smt, cpumask_of(cpu));
-		} else {
-			cpu = cpumask_any_and_distribute(idle_masks.cpu, cpus_allowed);
-			if (cpu >= nr_cpu_ids)
-				return -EBUSY;
-		}
-	} while (!test_and_clear_cpu_idle(cpu));
+	/* acquire ensures that we see the preceding updates on QUEUED */
+	opss = atomic64_read_acquire(&p->scx->ops_state);
 
-	return cpu;
+	switch (opss & SCX_OPSS_STATE_MASK) {
+	case SCX_OPSS_NONE:
+		break;
+	case SCX_OPSS_QUEUEING:
+		/*
+		 * QUEUEING is started and finished while holding @p's rq lock.
+		 * As we're holding the rq lock now, we shouldn't see QUEUEING.
+		 */
+		WARN_ON(1);
+		break;
+	case SCX_OPSS_QUEUED:
+		if (atomic64_try_cmpxchg(&p->scx->ops_state, &opss,
+					 SCX_OPSS_NONE))
+			break;
+		fallthrough;
+	case SCX_OPSS_DISPATCHING:
+		/*
+		 * If @p is being dispatched from the BPF scheduler to a DSQ,
+		 * wait for the transfer to complete so that @p doesn't get
+		 * added to its DSQ after dequeueing is complete.
+		 *
+		 * As we're waiting on DISPATCHING with the rq locked, the
+		 * dispatching side shouldn't try to lock the rq while
+		 * DISPATCHING is set. See dispatch_to_local_dsq().
+		 *
+		 * DISPATCHING shouldn't have qseq set and control can reach
+		 * here with NONE @opss from the above QUEUED case block.
+		 * Explicitly wait on %SCX_OPSS_DISPATCHING instead of @opss.
+		 */
+		wait_ops_state(p, SCX_OPSS_DISPATCHING);
+		WARN_ON(atomic64_read(&p->scx->ops_state) != SCX_OPSS_NONE);
+		break;
+	}
 }
 
-static s32 scx_select_cpu_dfl(struct task_struct *p, s32 prev_cpu, u64 wake_flags)
+static void dequeue_task_scx(struct rq *rq, struct task_struct *p, int deq_flags)
 {
-	s32 cpu;
-
-	if (!static_branch_likely(&scx_builtin_idle_enabled)) {
-		scx_ops_error("built-in idle tracking is disabled");
-		return prev_cpu;
-	}
+	struct scx_rq *scx_rq = rq->scx;
 
-	/*
-	 * If WAKE_SYNC and the machine isn't fully saturated, wake up @p to the
-	 * local DSQ of the waker.
-	 */
-	if ((wake_flags & SCX_WAKE_SYNC) && p->nr_cpus_allowed > 1 &&
-	    scx_has_idle_cpus && !(current->flags & PF_EXITING)) {
-		cpu = smp_processor_id();
-		if (cpumask_test_cpu(cpu, p->cpus_ptr)) {
-			p->scx->flags |= SCX_TASK_ENQ_LOCAL;
-			return cpu;
-		}
+	if (!test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags)) {
+		WARN_ON_ONCE(watchdog_task_watched(p));
+		return;
 	}
 
-	/* if the previous CPU is idle, dispatch directly to it */
-	if (test_and_clear_cpu_idle(prev_cpu)) {
-		p->scx->flags |= SCX_TASK_ENQ_LOCAL;
-		return prev_cpu;
-	}
+	ops_dequeue(p, deq_flags);
 
-	if (p->nr_cpus_allowed == 1)
-		return prev_cpu;
+	if(task_current(rq, p))
+		trace_android_vh_hmbird_update_load(p, rq, PUT_PREV_TASK, rq->clock);
 
-	cpu = scx_pick_idle_cpu(p->cpus_ptr);
-	if (cpu >= 0) {
-		p->scx->flags |= SCX_TASK_ENQ_LOCAL;
-		return cpu;
-	}
+	if (deq_flags & SCX_DEQ_SLEEP)
+		set_bit(ffs(SCX_TASK_DEQD_FOR_SLEEP), (unsigned long*)&p->scx->flags);
+	else
+		clear_bit(ffs(SCX_TASK_DEQD_FOR_SLEEP), (unsigned long*)&p->scx->flags);
 
-	return prev_cpu;
+	clear_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags);
+	WARN_ON(!scx_rq->nr_running);
+	scx_rq->nr_running--;
+	sub_nr_running(rq, 1);
+	dispatch_dequeue(scx_rq, p);
 }
 
-static int select_task_rq_scx(struct task_struct *p, int prev_cpu, int wake_flags)
+static void yield_task_scx(struct rq *rq)
 {
-	if (SCX_HAS_OP(select_cpu)) {
-		s32 cpu;
+	struct task_struct *p = rq->curr;
 
-		cpu = SCX_CALL_OP_TASK_RET(SCX_KF_REST, select_cpu, p, prev_cpu,
-					   wake_flags);
-		if (ops_cpu_valid(cpu)) {
-			return cpu;
-		} else {
-			scx_ops_error("select_cpu returned invalid cpu %d", cpu);
-			return prev_cpu;
-		}
-	} else {
-		return scx_select_cpu_dfl(p, prev_cpu, wake_flags);
-	}
+	p->scx->slice = 0;
 }
 
-static void set_cpus_allowed_scx(struct task_struct *p, struct affinity_context *ctx)
+static bool yield_to_task_scx(struct rq *rq, struct task_struct *to)
 {
-	set_cpus_allowed_common(p, ctx);
+	return false;
+}
+
+#ifdef CONFIG_SMP
+/**
+ * move_task_to_local_dsq - Move a task from a different rq to a local DSQ
+ * @rq: rq to move the task into, currently locked
+ * @p: task to move
+ * @enq_flags: %SCX_ENQ_*
+ *
+ * Move @p which is currently on a different rq to @rq's local DSQ. The caller
+ * must:
+ *
+ * 1. Start with exclusive access to @p either through its DSQ lock or
+ *    %SCX_OPSS_DISPATCHING flag.
+ *
+ * 2. Set @p->scx->holding_cpu to raw_smp_processor_id().
+ *
+ * 3. Remember task_rq(@p). Release the exclusive access so that we don't
+ *    deadlock with dequeue.
+ *
+ * 4. Lock @rq and the task_rq from #3.
+ *
+ * 5. Call this function.
+ *
+ * Returns %true if @p was successfully moved. %false after racing dequeue and
+ * losing.
+ */
+static bool move_task_to_local_dsq(struct rq *rq, struct task_struct *p,
+				   u64 enq_flags)
+{
+	struct rq *task_rq;
+
+	lockdep_assert_rq_held(rq);
 
 	/*
-	 * The effective cpumask is stored in @p->cpus_ptr which may temporarily
-	 * differ from the configured one in @p->cpus_mask. Always tell the bpf
-	 * scheduler the effective one.
+	 * If dequeue got to @p while we were trying to lock both rq's, it'd
+	 * have cleared @p->scx->holding_cpu to -1. While other cpus may have
+	 * updated it to different values afterwards, as this operation can't be
+	 * preempted or recurse, @p->scx->holding_cpu can never become
+	 * raw_smp_processor_id() again before we're done. Thus, we can tell
+	 * whether we lost to dequeue by testing whether @p->scx->holding_cpu is
+	 * still raw_smp_processor_id().
 	 *
-	 * Fine-grained memory write control is enforced by BPF making the const
-	 * designation pointless. Cast it away when calling the operation.
+	 * See dispatch_dequeue() for the counterpart.
+	 */
+	if (unlikely(p->scx->holding_cpu != raw_smp_processor_id()))
+		return false;
+
+	/* @p->rq couldn't have changed if we're still the holding cpu */
+	task_rq = task_rq(p);
+	lockdep_assert_rq_held(task_rq);
+	deactivate_task(task_rq, p, 0);
+	set_task_cpu(p, cpu_of(rq));
+	p->scx->sticky_cpu = cpu_of(rq);
+
+	/*
+	 * We want to pass scx-specific enq_flags but activate_task() will
+	 * truncate the upper 32 bit. As we own @rq, we can pass them through
+	 * @rq->scx->extra_enq_flags instead.
 	 */
-	if (SCX_HAS_OP(set_cpumask))
-		SCX_CALL_OP_TASK(SCX_KF_REST, set_cpumask, p,
-				 (struct cpumask *)p->cpus_ptr);
+	WARN_ON_ONCE(rq->scx->extra_enq_flags);
+	rq->scx->extra_enq_flags = enq_flags;
+	activate_task(rq, p, 0);
+	rq->scx->extra_enq_flags = 0;
+
+	return true;
 }
 
-static void reset_idle_masks(void)
+#endif	/* CONFIG_SMP */
+
+static int task_fits_cpu_scx(struct task_struct *p, int cpu)
 {
-	/* consider all cpus idle, should converge to the actual state quickly */
-	cpumask_setall(idle_masks.cpu);
-	cpumask_setall(idle_masks.smt);
-	scx_has_idle_cpus = true;
+	int fitable = 1;
+
+	trace_android_vh_task_fits_cpu_scx(p, cpu, &fitable);
+
+	return fitable;
 }
 
-void __scx_update_idle(struct rq *rq, bool idle)
+static int check_misfit_task_on_little(struct task_struct *p, struct rq *rq, struct scx_dispatch_q *dsq)
 {
+	bool dsq_misfit;
 	int cpu = cpu_of(rq);
-	struct cpumask *sib_mask = topology_sibling_cpumask(cpu);
+	u64 task_util = 0;
+	struct cluster_ctx ctx;
+	int dsq_int = dsq_id_to_internal(dsq);
+
+	trace_android_vh_get_util(-1, p, &task_util);
+	gen_cluster_ctx(&ctx, BIG);
+	dsq_misfit = (dsq_int >= SCHED_PROP_DEADLINE_LEVEL1 &&
+				dsq_int <= SCHED_PROP_DEADLINE_LEVEL3);
+#ifdef CLUSTER_SEPARATE
+	dsq_misfit |= (dsq_int >= ctx.lower && dsq_int < ctx.upper);
+#endif
+	if (cpumask_test_cpu(cpu, iso_masks.little)
+                && task_util > misfit_ds && dsq_misfit) {
+                scx_info_trace("<hmbird_sched><filter>:task %s "
+				"can't run on cpu%d, util = %llu\n",
+				p->comm, cpu, task_util);
+                return true;
+        }
+	return false;
+}
 
-	if (SCX_HAS_OP(update_idle)) {
-		SCX_CALL_OP(SCX_KF_REST, update_idle, cpu_of(rq), idle);
-		if (!static_branch_unlikely(&scx_builtin_idle_enabled))
-			return;
+static bool task_can_run_on_rq(struct task_struct *p, struct rq *rq, struct scx_dispatch_q *dsq)
+{
+	if (!task_fits_cpu_scx(p, cpu_of(rq))) {
+		return false;
 	}
 
-	if (idle) {
-		cpumask_set_cpu(cpu, idle_masks.cpu);
-		if (!scx_has_idle_cpus)
-			scx_has_idle_cpus = true;
-
-		/*
-		 * idle_masks.smt handling is racy but that's fine as it's only
-		 * for optimization and self-correcting.
-		 */
-		for_each_cpu(cpu, sib_mask) {
-			if (!cpumask_test_cpu(cpu, idle_masks.cpu))
-				return;
-		}
-		cpumask_or(idle_masks.smt, idle_masks.smt, sib_mask);
-	} else {
-		cpumask_clear_cpu(cpu, idle_masks.cpu);
-		if (scx_has_idle_cpus && cpumask_empty(idle_masks.cpu))
-			scx_has_idle_cpus = false;
+	if (check_misfit_task_on_little(p, rq, dsq))
+		return false;
 
-		cpumask_andnot(idle_masks.smt, idle_masks.smt, sib_mask);
-	}
+	return likely(test_rq_online(rq)) && !is_migration_disabled(p);
 }
 
-#else /* !CONFIG_SMP */
-
-static bool test_and_clear_cpu_idle(int cpu) { return false; }
-static s32 scx_pick_idle_cpu(const struct cpumask *cpus_allowed) { return -EBUSY; }
-static void reset_idle_masks(void) {}
-
-#endif /* CONFIG_SMP */
-
-static bool check_rq_for_timeouts(struct rq *rq)
+bool consume_dispatch_q(struct rq *rq, struct rq_flags *rf,
+			       struct scx_dispatch_q *dsq)
 {
+	struct scx_rq *scx_rq = rq->scx;
 	struct sched_ext_entity *entity;
 	struct task_struct *p;
-	struct rq_flags rf;
-	bool timed_out = false;
-
-	rq_lock_irqsave(rq, &rf);
-	list_for_each_entry(entity, &rq->scx->watchdog_list, watchdog_node) {
-		unsigned long last_runnable;
-
-		p = entity->task;
-		last_runnable = p->scx->runnable_at;
-
-		if (unlikely(time_after(jiffies,
-					last_runnable + scx_watchdog_timeout))) {
-			u32 dur_ms = jiffies_to_msecs(jiffies - last_runnable);
-
-			scx_ops_error_type(SCX_EXIT_ERROR_STALL,
-					   "%s[%d] failed to run for %u.%03us",
-					   p->comm, p->pid,
-					   dur_ms / 1000, dur_ms % 1000);
-			timed_out = true;
-			break;
-		}
-	}
-	rq_unlock_irqrestore(rq, &rf);
+	struct rb_node *rb_node;
+	struct rq *task_rq;
+	unsigned long flags;
+	bool moved = false;
 
-	return timed_out;
-}
+	slim_stats_record(TOTAL_DSP_CNT, 0, 0, 0);
 
-static void scx_watchdog_workfn(struct work_struct *work)
-{
-	int cpu;
+retry:
+	if (list_empty(&dsq->fifo) && !rb_first_cached(&dsq->priq))
+		return false;
 
-	scx_watchdog_timestamp = jiffies;
+	raw_spin_lock_irqsave(&dsq->lock, flags);
 
-	for_each_online_cpu(cpu) {
-		if (unlikely(check_rq_for_timeouts(cpu_rq(cpu))))
-			break;
+	list_for_each_entry(entity, &dsq->fifo, dsq_node.fifo) {
+		p = entity->task;
+		task_rq = task_rq(p);
+		if (rq == task_rq)
+			goto this_rq;
+		if (task_can_run_on_rq(p, rq, dsq))
+			goto remote_rq;
+	}
 
-		cond_resched();
+	for (rb_node = rb_first_cached(&dsq->priq); rb_node;
+	     rb_node = rb_next(rb_node)) {
+		entity = container_of(rb_node, struct sched_ext_entity, dsq_node.priq);
+		p = entity->task;
+		task_rq = task_rq(p);
+		if (rq == task_rq)
+			goto this_rq;
+		if (task_can_run_on_rq(p, rq, dsq))
+			goto remote_rq;
 	}
-	queue_delayed_work(system_unbound_wq, to_delayed_work(work),
-			   scx_watchdog_timeout / 2);
-}
 
-static void task_tick_scx(struct rq *rq, struct task_struct *curr, int queued)
-{
-	update_curr_scx(rq);
-	//scx_update_task_ravg(curr, rq, TASK_UPDATE, rq->clock);
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	return false;
+
+this_rq:
+	/* @dsq is locked and @p is on this rq */
+	WARN_ON_ONCE(p->scx->holding_cpu >= 0);
+	task_unlink_from_dsq(p, dsq);
+	list_add_tail(&p->scx->dsq_node.fifo, &scx_rq->local_dsq.fifo);
+	dsq->nr--;
+	scx_rq->local_dsq.nr++;
+	p->scx->dsq = &scx_rq->local_dsq;
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
+	return true;
+
+remote_rq:
+#ifdef CONFIG_SMP
+	slim_stats_record(MOVE_RQ_CNT, 0, 0, 0);
 	/*
-	 * While disabling, always resched and refresh core-sched timestamp as
-	 * we can't trust the slice management or ops.core_sched_before().
+	 * @dsq is locked and @p is on a remote rq. @p is currently protected by
+	 * @dsq->lock. We want to pull @p to @rq but may deadlock if we grab
+	 * @task_rq while holding @dsq and @rq locks. As dequeue can't drop the
+	 * rq lock or fail, do a little dancing from our side. See
+	 * move_task_to_local_dsq().
 	 */
-	if (scx_ops_disabling()) {
-		curr->scx->slice = 0;
-		touch_core_sched(rq, curr);
-	}
+	WARN_ON_ONCE(p->scx->holding_cpu >= 0);
+	task_unlink_from_dsq(p, dsq);
+	dsq->nr--;
+	p->scx->holding_cpu = raw_smp_processor_id();
+	raw_spin_unlock_irqrestore(&dsq->lock, flags);
 
-	if (!curr->scx->slice)
-		resched_curr(rq);
-}
+	rq_unpin_lock(rq, rf);
+	double_lock_balance(rq, task_rq);
+	rq_repin_lock(rq, rf);
 
-#define SCX_ENABLE_ARGS_INIT_CGROUP(tg)
+	moved = move_task_to_local_dsq(rq, p, 0);
 
-static int scx_ops_prepare_task(struct task_struct *p, struct task_group *tg)
-{
-	int ret;
+	double_unlock_balance(rq, task_rq);
+#endif /* CONFIG_SMP */
+	if (likely(moved))
+		return true;
+	goto retry;
+}
 
-	WARN_ON_ONCE(p->scx->flags & SCX_TASK_OPS_PREPPED);
 
-	p->scx->disallow = false;
+static int balance_one(struct rq *rq, struct task_struct *prev,
+		       struct rq_flags *rf, bool local)
+{
+	struct scx_rq *scx_rq = rq->scx;
+	bool prev_on_scx = prev->sched_class == &ext_sched_class;
 
-	if (SCX_HAS_OP(prep_enable)) {
-		struct scx_enable_args args = {
-			SCX_ENABLE_ARGS_INIT_CGROUP(tg)
-		};
+	lockdep_assert_rq_held(rq);
 
-		ret = SCX_CALL_OP_RET(SCX_KF_SLEEPABLE, prep_enable, p, &args);
-		if (unlikely(ret)) {
-			ret = ops_sanitize_err("prep_enable", ret);
-			return ret;
-		}
+	if (static_branch_unlikely(&scx_ops_cpu_preempt) &&
+	    unlikely(rq->scx->cpu_released)) {
+		/*
+		 * If the previous sched_class for the current CPU was not SCX,
+		 * notify the BPF scheduler that it again has control of the
+		 * core. This callback complements ->cpu_release(), which is
+		 * emitted in scx_notify_pick_next_task().
+		 */
+		rq->scx->cpu_released = false;
 	}
-	//scx_sched_init_task(p);
-
-	if (p->scx->disallow) {
-		struct rq *rq;
-		struct rq_flags rf;
 
-		rq = task_rq_lock(p, &rf);
+	if (prev_on_scx) {
+		WARN_ON_ONCE(local && test_bit(ffs(SCX_TASK_BAL_KEEP), (unsigned long*)&prev->scx->flags));
+		update_curr_scx(rq);
 
 		/*
-		 * We're either in fork or load path and @p->policy will be
-		 * applied right after. Reverting @p->policy here and rejecting
-		 * %SCHED_EXT transitions from scx_check_setscheduler()
-		 * guarantees that if ops.prep_enable() sets @p->disallow, @p
-		 * can never be in SCX.
+		 * If @prev is runnable & has slice left, it has priority and
+		 * fetching more just increases latency for the fetched tasks.
+		 * Tell put_prev_task_scx() to put @prev on local_dsq. If the
+		 * BPF scheduler wants to handle this explicitly, it should
+		 * implement ->cpu_released().
+		 *
+		 * See scx_ops_disable_workfn() for the explanation on the
+		 * disabling() test.
+		 *
+		 * When balancing a remote CPU for core-sched, there won't be a
+		 * following put_prev_task_scx() call and we don't own
+		 * %SCX_TASK_BAL_KEEP. Instead, pick_task_scx() will test the
+		 * same conditions later and pick @rq->curr accordingly.
 		 */
-		if (p->policy == SCHED_EXT) {
-			p->policy = SCHED_NORMAL;
-			atomic64_inc(&scx_nr_rejected);
+		if (test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&prev->scx->flags) &&
+		    prev->scx->slice && !scx_ops_disabling()) {
+			if (local)
+				set_bit(ffs(SCX_TASK_BAL_KEEP), (unsigned long*)&prev->scx->flags);
+			return 1;
 		}
+	}
+	/* if there already are tasks to run, nothing to do */
+	if (scx_rq->local_dsq.nr)
+		return 1;
 
-		task_rq_unlock(rq, p, &rf);
+	if (consume_dispatch_q(rq, rf, &scx_dsq_global)) {
+		slim_stats_record(GLOBAL_STAT, 1, 0, 0);
+		return 1;
 	}
 
-	p->scx->flags |= (SCX_TASK_OPS_PREPPED | SCX_TASK_WATCHDOG_RESET);
+	if (consume_dispatch_global(rq, rf))
+		return 1;
+
 	return 0;
 }
 
-static void scx_ops_enable_task(struct task_struct *p)
+static int balance_scx(struct rq *rq, struct task_struct *prev,
+		       struct rq_flags *rf)
 {
-	lockdep_assert_rq_held(task_rq(p));
-	WARN_ON_ONCE(!(p->scx->flags & SCX_TASK_OPS_PREPPED));
-
-	if (SCX_HAS_OP(enable)) {
-		struct scx_enable_args args = {
-			SCX_ENABLE_ARGS_INIT_CGROUP(task_group(p))
-		};
-		SCX_CALL_OP_TASK(SCX_KF_REST, enable, p, &args);
-	}
-	p->scx->flags &= ~SCX_TASK_OPS_PREPPED;
-	p->scx->flags |= SCX_TASK_OPS_ENABLED;
+	return balance_one(rq, prev, rf, true);
 }
 
-static void scx_ops_disable_task(struct task_struct *p)
+static void set_next_task_scx(struct rq *rq, struct task_struct *p, bool first)
 {
-	lockdep_assert_rq_held(task_rq(p));
-
-	if (p->scx->flags & SCX_TASK_OPS_PREPPED) {
-		if (SCX_HAS_OP(cancel_enable)) {
-			struct scx_enable_args args = {
-				SCX_ENABLE_ARGS_INIT_CGROUP(task_group(p))
-			};
-			SCX_CALL_OP(SCX_KF_REST, cancel_enable, p, &args);
-		}
-		p->scx->flags &= ~SCX_TASK_OPS_PREPPED;
-	} else if (p->scx->flags & SCX_TASK_OPS_ENABLED) {
-		if (SCX_HAS_OP(disable))
-			SCX_CALL_OP(SCX_KF_REST, disable, p);
-		p->scx->flags &= ~SCX_TASK_OPS_ENABLED;
+	u64 util = 0;
+	if (test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags)) {
+		/*
+		 * Core-sched might decide to execute @p before it is
+		 * dispatched. Call ops_dequeue() to notify the BPF scheduler.
+		 */
+		ops_dequeue(p, SCX_DEQ_CORE_SCHED_EXEC);
+		dispatch_dequeue(rq->scx, p);
 	}
-}
 
-static void set_task_scx_weight(struct task_struct *p)
-{
-	u32 weight = sched_prio_to_weight[p->static_prio - MAX_RT_PRIO];
+	p->se.exec_start = rq_clock_task(rq);
 
-	p->scx->weight = sched_weight_to_cgroup(weight);
-}
+	if(test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags))
+		trace_android_vh_hmbird_update_load(p, rq, PICK_NEXT_TASK, rq->clock);
 
-/**
- * refresh_scx_weight - Refresh a task's ext weight
- * @p: task to refresh ext weight for
- *
- * @p->scx->weight carries the task's static priority in cgroup weight scale to
- * enable easy access from the BPF scheduler. To keep it synchronized with the
- * current task priority, this function should be called when a new task is
- * created, priority is changed for a task on sched_ext, and a task is switched
- * to sched_ext from other classes.
- */
-static void refresh_scx_weight(struct task_struct *p)
-{
-	lockdep_assert_rq_held(task_rq(p));
-	set_task_scx_weight(p);
-	if (SCX_HAS_OP(set_weight))
-		SCX_CALL_OP_TASK(SCX_KF_REST, set_weight, p, p->scx->weight);
+	watchdog_unwatch_task(p, true);
+	slim_trace_show_cpu_consume_dsq_idx(smp_processor_id(), p->scx->gdsq_idx);
+	if (debug_enabled()) {
+		trace_android_vh_get_util(-1, p, &util);
+		scx_info_systrace("C|9999|cpu_%d_ds|%llu\n", cpu_of(rq), util);
+	}
+	/*
+	 * @p is getting newly scheduled or got kicked after someone updated its
+	 * slice. Refresh whether tick can be stopped. See can_stop_tick_scx().
+	 */
+	if ((p->scx->slice == SCX_SLICE_INF) !=
+	    (bool)(rq->scx->flags & SCX_RQ_CAN_STOP_TICK)) {
+		if (p->scx->slice == SCX_SLICE_INF)
+			rq->scx->flags |= SCX_RQ_CAN_STOP_TICK;
+		else
+			rq->scx->flags &= ~SCX_RQ_CAN_STOP_TICK;
+
+		sched_update_tick_dependency(rq);
+	}
 }
 
-void scx_pre_fork(struct task_struct *p)
+static void put_prev_task_scx(struct rq *rq, struct task_struct *p)
 {
-	p->scx = kmalloc(sizeof(struct sched_ext_entity), GFP_KERNEL);
-	if (!p->scx) {
-		goto lock;
-	}
+	update_curr_scx(rq);
 
-	p->scx->dsq = NULL;
-	INIT_LIST_HEAD(&p->scx->dsq_node.fifo);
-	RB_CLEAR_NODE(&p->scx->dsq_node.priq);
-	INIT_LIST_HEAD(&p->scx->watchdog_node);
-	p->scx->flags = 0;
-	p->scx->weight = 0;
-	p->scx->sticky_cpu = -1;
-	p->scx->holding_cpu = -1;
-	p->scx->kf_mask = 0;
-	atomic64_set(&p->scx->ops_state, 0);
-	p->scx->runnable_at = INITIAL_JIFFIES;
-	p->scx->slice = SCX_SLICE_DFL;
-	p->scx->task = p;
-	p->sched_prop = 0;
+	update_dispatch_dsq_info(rq, p);
 
+	if(test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags))
+		trace_android_vh_hmbird_update_load(p, rq, PUT_PREV_TASK, rq->clock);
+
+	slim_trace_show_cpu_consume_dsq_idx(smp_processor_id(), 0);
 	/*
-	 * BPF scheduler enable/disable paths want to be able to iterate and
-	 * update all tasks which can become complex when racing forks. As
-	 * enable/disable are very cold paths, let's use a percpu_rwsem to
-	 * exclude forks.
+	 * If we're being called from put_prev_task_balance(), balance_scx() may
+	 * have decided that @p should keep running.
 	 */
-lock:
-	percpu_down_read(&scx_fork_rwsem);
-}
+	if (test_bit(ffs(SCX_TASK_BAL_KEEP), (unsigned long*)&p->scx->flags)) {
+		clear_bit(ffs(SCX_TASK_BAL_KEEP), (unsigned long*)&p->scx->flags);
+		watchdog_watch_task(rq, p);
+		/*
+		 * Orig enq_flag is SCX_ENQ_HEAD, when we implement preempt, put
+		 * a higher prio task A to local(assume curr is B), and then
+		 * trigger a preempt event,
+		 * if we use SCX_ENQ_HEAD, it will push curr(B) to the first one
+		 * of local q, A is behind B after enqueue, cause next task will
+		 * still be curr(B), so we set the enq flag to empty.
+		 * for this problem, another way is to set curr->slice = 0, but
+		 * it's unfair to curr task.
+		 */
+		dispatch_enqueue(&rq->scx->local_dsq, p, 0);
+		return;
+	}
 
-int scx_fork(struct task_struct *p)
-{
-	percpu_rwsem_assert_held(&scx_fork_rwsem);
+	if (test_bit(ffs(SCX_TASK_QUEUED), (unsigned long*)&p->scx->flags)) {
+		watchdog_watch_task(rq, p);
 
-	if (scx_enabled())
-		return scx_ops_prepare_task(p, task_group(p));
-	else
-		return 0;
-}
+		if (sched_prop_get_top_thread_id(p)) {
+			do_enqueue_task(rq, p, SCX_ENQ_LOCAL, -1);
+			return;
+		}
 
-void scx_post_fork(struct task_struct *p)
-{
-	if (scx_enabled()) {
-		struct rq_flags rf;
-		struct rq *rq;
+		/*
+		 * If @p has slice left and balance_scx() didn't tag it for
+		 * keeping, @p is getting preempted by a higher priority
+		 * scheduler class or core-sched forcing a different task. Leave
+		 * it at the head of the local DSQ.
+		 */
+		if (p->scx->slice && !scx_ops_disabling()) {
+			dispatch_enqueue(&rq->scx->local_dsq, p, SCX_ENQ_HEAD);
+			return;
+		}
 
-		rq = task_rq_lock(p, &rf);
 		/*
-		 * Set the weight manually before calling ops.enable() so that
-		 * the scheduler doesn't see a stale value if they inspect the
-		 * task struct. We'll invoke ops.set_weight() afterwards, as it
-		 * would be odd to receive a callback on the task before we
-		 * tell the scheduler that it's been fully enabled.
+		 * If we're in the pick_next_task path, balance_scx() should
+		 * have already populated the local DSQ if there are any other
+		 * available tasks. If empty, tell ops.enqueue() that @p is the
+		 * only one available for this cpu. ops.enqueue() should put it
+		 * on the local DSQ so that the subsequent pick_next_task_scx()
+		 * can find the task unless it wants to trigger a separate
+		 * follow-up scheduling event.
 		 */
-		set_task_scx_weight(p);
-		scx_ops_enable_task(p);
-		refresh_scx_weight(p);
-		task_rq_unlock(rq, p, &rf);
+		if (list_empty(&rq->scx->local_dsq.fifo)) {
+			do_enqueue_task(rq, p, SCX_ENQ_LAST | SCX_ENQ_LOCAL, -1);
+		} else
+			do_enqueue_task(rq, p, 0, -1);
 	}
+}
+
+static struct task_struct *first_local_task(struct rq *rq)
+{
+	struct rb_node *rb_node;
+	struct sched_ext_entity *entity;
 
-	spin_lock_irq(&scx_tasks_lock);
-	list_add_tail(&p->scx->tasks_node, &scx_tasks);
-	spin_unlock_irq(&scx_tasks_lock);
+	if (!list_empty(&rq->scx->local_dsq.fifo)) {
+		entity = list_first_entry(&rq->scx->local_dsq.fifo, struct sched_ext_entity, dsq_node.fifo);
+		return entity->task;
+	}
 
-	percpu_up_read(&scx_fork_rwsem);
+	rb_node = rb_first_cached(&rq->scx->local_dsq.priq);
+	if (rb_node) {
+		entity = container_of(rb_node, struct sched_ext_entity, dsq_node.priq);
+		return entity->task;
+	}
+	return NULL;
 }
 
-void scx_cancel_fork(struct task_struct *p)
+static struct task_struct *pick_next_task_scx(struct rq *rq)
 {
-	if (scx_enabled())
-		scx_ops_disable_task(p);
-	percpu_up_read(&scx_fork_rwsem);
+	struct task_struct *p;
+
+	p = first_local_task(rq);
+	if (!p)
+		return NULL;
+
+	if (unlikely(!p->scx->slice)) {
+		if (!scx_ops_disabling() && !scx_warned_zero_slice) {
+			printk_deferred(KERN_WARNING "sched_ext: %s[%d] has zero slice in pick_next_task_scx()\n",
+					p->comm, p->pid);
+			scx_warned_zero_slice = true;
+		}
+		p->scx->slice = SCX_SLICE_DFL;
+	}
+
+	set_next_task_scx(rq, p, true);
+
+	return p;
 }
 
-void sched_ext_free(struct task_struct *p)
+void __scx_notify_pick_next_task(struct rq *rq, struct task_struct *task,
+				 const struct sched_class *active)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&scx_tasks_lock, flags);
-	list_del_init(&p->scx->tasks_node);
-	spin_unlock_irqrestore(&scx_tasks_lock, flags);
+	lockdep_assert_rq_held(rq);
 
 	/*
-	 * @p is off scx_tasks and wholly ours. scx_ops_enable()'s PREPPED ->
-	 * ENABLED transitions can't race us. Disable ops for @p.
+	 * The callback is conceptually meant to convey that the CPU is no
+	 * longer under the control of SCX. Therefore, don't invoke the
+	 * callback if the CPU is is staying on SCX, or going idle (in which
+	 * case the SCX scheduler has actively decided not to schedule any
+	 * tasks on the CPU).
 	 */
-	if (p->scx->flags & (SCX_TASK_OPS_PREPPED | SCX_TASK_OPS_ENABLED)) {
-		struct rq_flags rf;
-		struct rq *rq;
+	if (likely(active >= &ext_sched_class))
+		return;
 
-		rq = task_rq_lock(p, &rf);
-		scx_ops_disable_task(p);
-		task_rq_unlock(rq, p, &rf);
-	}
+	/*
+	 * At this point we know that SCX was preempted by a higher priority
+	 * sched_class, so invoke the ->cpu_release() callback if we have not
+	 * done so already. We only send the callback once between SCX being
+	 * preempted, and it regaining control of the CPU.
+	 *
+	 * ->cpu_release() complements ->cpu_acquire(), which is emitted the
+	 *  next time that balance_scx() is invoked.
+	 */
+	if (!rq->scx->cpu_released)
+		rq->scx->cpu_released = true;
 }
 
-static void prio_changed_scx(struct rq *rq, struct task_struct *p, int oldprio)
+#ifdef CONFIG_SMP
+
+static bool test_and_clear_cpu_idle(int cpu)
 {
+	if (cpumask_test_and_clear_cpu(cpu, idle_masks.cpu)) {
+		if (cpumask_empty(idle_masks.cpu))
+			scx_has_idle_cpus = false;
+		return true;
+	} else {
+		return false;
+	}
 }
 
-static void check_preempt_curr_scx(struct rq *rq, struct task_struct *p,int wake_flags) {}
-static void switched_to_scx(struct rq *rq, struct task_struct *p) {}
-
-int scx_check_setscheduler(struct task_struct *p, int policy)
+static s32 scx_pick_idle_cpu(const struct cpumask *cpus_allowed)
 {
-	lockdep_assert_rq_held(task_rq(p));
+	int cpu;
 
-	/* if disallow, reject transitioning into SCX */
-	if (scx_enabled() && READ_ONCE(p->scx->disallow) &&
-	    p->policy != policy && policy == SCHED_EXT)
-		return -EACCES;
+	do {
+		cpu = cpumask_any_and_distribute(idle_masks.cpu, cpus_allowed);
+		if (cpu >= nr_cpu_ids)
+			return -EBUSY;
+	} while (!test_and_clear_cpu_idle(cpu));
 
-	return 0;
+	return cpu;
 }
 
-#ifdef CONFIG_NO_HZ_FULL
-bool scx_can_stop_tick(struct rq *rq)
-{
-	struct task_struct *p = rq->curr;
 
-	if (scx_ops_disabling())
-		return false;
-
-	if (p->sched_class != &ext_sched_class)
+static bool prev_cpu_misfit(int prev)
+{
+	if (!is_partial_enabled() && is_partial_cpu(prev))
 		return true;
 
-	/*
-	 * @rq can dispatch from different DSQs, so we can't tell whether it
-	 * needs the tick or not by looking at nr_running. Allow stopping ticks
-	 * iff the BPF scheduler indicated so. See set_next_task_scx().
-	 */
-	return rq->scx->flags & SCX_RQ_CAN_STOP_TICK;
+	return false;
 }
-#endif
-
-static inline void scx_cgroup_lock(void) {}
-static inline void scx_cgroup_unlock(void) {}
-
-/*
- * Omitted operations:
- *
- * - check_preempt_curr: NOOP as it isn't useful in the wakeup path because the
- *   task isn't tied to the CPU at that point. Preemption is implemented by
- *   resetting the victim task's slice to 0 and triggering reschedule on the
- *   target CPU.
- *
- * - migrate_task_rq: Unncessary as task to cpu mapping is transient.
- *
- * - task_fork/dead: We need fork/dead notifications for all tasks regardless of
- *   their current sched_class. Call them directly from sched core instead.
- *
- * - task_woken, switched_from: Unnecessary.
- */
-DEFINE_SCHED_CLASS(ext) = {
-	.enqueue_task		= enqueue_task_scx,
-	.dequeue_task		= dequeue_task_scx,
-	.yield_task		= yield_task_scx,
-	.yield_to_task		= yield_to_task_scx,
-
-	.check_preempt_curr	= check_preempt_curr_scx,
 
-	.pick_next_task		= pick_next_task_scx,
+static int heavy_rt_placement(struct task_struct *p, int prev)
+{
+	struct cpumask tmp;
+	int cpu;
+	u16 ds = p->scx->sts.demand_scaled;
+	if (!rt_prio(p->prio))
+		return -EFAULT;
 
-	.put_prev_task		= put_prev_task_scx,
-	.set_next_task          = set_next_task_scx,
+	if ((ds < misfit_ds))
+		return -EFAULT;
 
-#ifdef CONFIG_SMP
-	.balance		= balance_scx,
-	.select_task_rq		= select_task_rq_scx,
-	.set_cpus_allowed	= set_cpus_allowed_scx,
-#endif
+	if (is_partial_enabled())
+		cpumask_or(&tmp, iso_masks.big, iso_masks.partial);
+	else
+		cpumask_copy(&tmp, iso_masks.big);
 
-#ifdef CONFIG_SCHED_CORE
-	.pick_task		= pick_task_scx,
-#endif
+	cpu = scx_pick_idle_cpu(&tmp);
+	if (cpu >= 0)
+                return cpu;
 
-	.task_tick		= task_tick_scx,
+	if (cpumask_test_cpu(prev, iso_masks.big) ||
+		(is_partial_enabled() && is_partial_cpu(prev)))
+		return prev;
 
-	.switched_to		= switched_to_scx,
-	.prio_changed		= prio_changed_scx,
+	return cpumask_first(&tmp);
+}
 
-	.update_curr		= update_curr_scx,
+static int spec_task_before_pick_idle(struct task_struct *p, int prev)
+{
+	int cpu;
 
-#ifdef CONFIG_UCLAMP_TASK
-	.uclamp_enabled		= 0,
-#endif
-};
+	cpu = heavy_rt_placement(p, prev);
+	if (cpu >= 0)
+		return cpu;
+	return -EFAULT;
+}
 
-static void init_dsq(struct scx_dispatch_q *dsq, u64 dsq_id)
+static int repick_fallback_cpu(void)
 {
-	memset(dsq, 0, sizeof(*dsq));
-
-	raw_spin_lock_init(&dsq->lock);
-	INIT_LIST_HEAD(&dsq->fifo);
-	dsq->id = dsq_id;
+	/*
+	 * partial cpu follow big cluster's Scheduling policy,
+	 * simply return first bit cpu.
+	 */
+	return cpumask_first(iso_masks.big);
 }
 
-static struct scx_dispatch_q *create_dsq(u64 dsq_id, int node)
+static s32 scx_select_cpu_dfl(struct task_struct *p, s32 prev_cpu, u64 wake_flags)
 {
-	struct scx_dispatch_q *dsq;
+	s32 cpu = -1;
 
-	if (dsq_id & SCX_DSQ_FLAG_BUILTIN)
-		return ERR_PTR(-EINVAL);
+	trace_android_vh_scx_select_cpu_dfl(p, &cpu);
+	if (cpu >= 0) {
+		set_bit(ffs(SCX_TASK_ENQ_LOCAL), (unsigned long*)&p->scx->flags);
+		return cpu;
+	}
 
-	dsq = kmalloc_node(sizeof(*dsq), GFP_ATOMIC, node);
-	if (!dsq)
-		return ERR_PTR(-ENOMEM);
+	if (sched_prop_get_top_thread_id(p)) {
+		set_bit(ffs(SCX_TASK_ENQ_LOCAL), (unsigned long*)&p->scx->flags);
+		cpu = scx_pick_idle_cpu(iso_masks.big);
+		if (cpu >= 0)
+			return cpu;
+		if (cpumask_test_cpu(prev_cpu, iso_masks.big))
+			return prev_cpu;
+		else
+			return cpumask_first(iso_masks.big);
+	}
 
-	init_dsq(dsq, dsq_id);
+	if (p->nr_cpus_allowed == 1) {
+		cpu = cpumask_any(p->cpus_ptr);
+                return cpu;
+        }
 
-	return dsq;
-}
+	partial_dynamic_ctrl();
 
-static void free_dsq_irq_workfn(struct irq_work *irq_work)
-{
-	struct llist_node *to_free = llist_del_all(&dsqs_to_free);
-	struct scx_dispatch_q *dsq, *tmp_dsq;
+	cpu = spec_task_before_pick_idle(p, prev_cpu);
+	if (cpu >= 0) {
+		scx_info_trace("<hmbird_sched><select_cpu>:heavy task %s pick cpu %d\n", p->comm, cpu);
+		return cpu;
+	}
 
-	llist_for_each_entry_safe(dsq, tmp_dsq, to_free, free_node)
-		kfree_rcu(dsq, rcu);
-}
+	/* if the previous CPU is idle, dispatch directly to it */
+	if (test_and_clear_cpu_idle(prev_cpu))
+		return prev_cpu;
 
-static DEFINE_IRQ_WORK(free_dsq_irq_work, free_dsq_irq_workfn);
+	cpu = scx_pick_idle_cpu(cpu_possible_mask);
+	if (cpu >= 0)
+		return cpu;
 
-static void destroy_dsq(u64 dsq_id)
-{
-}
+	if (prev_cpu_misfit(prev_cpu)) {
+		scx_info_trace("<hmbird_sched><select_cpu>:prev cpu%d is misfit for %s, repick cpu \n", cpu, p->comm);
+		return repick_fallback_cpu();
+	}
 
-static void scx_cgroup_exit(void) {}
-static int scx_cgroup_init(void) { return 0; }
-static void scx_cgroup_config_knobs(void) {}
+	return prev_cpu;
+}
 
-/*
- * Used by sched_fork() and __setscheduler_prio() to pick the matching
- * sched_class. dl/rt are already handled.
- */
-bool task_on_scx(struct task_struct *p)
+static int select_task_rq_scx(struct task_struct *p, int prev_cpu, int wake_flags)
 {
-	if (!scx_enabled() || scx_ops_disabling())
-		return false;
-	if (READ_ONCE(scx_switching_all))
-		return true;
-	return p->policy == SCHED_EXT;
+	return scx_select_cpu_dfl(p, prev_cpu, wake_flags);
 }
 
-static void scx_ops_fallback_enqueue(struct task_struct *p, u64 enq_flags)
+static void set_cpus_allowed_scx(struct task_struct *p, struct affinity_context *ctx)
 {
-	if (enq_flags & SCX_ENQ_LAST)
-		scx_bpf_dispatch(p, SCX_DSQ_LOCAL, SCX_SLICE_DFL, enq_flags);
-	else
-		scx_bpf_dispatch(p, SCX_DSQ_GLOBAL, SCX_SLICE_DFL, enq_flags);
+	set_cpus_allowed_common(p, ctx);
 }
 
-static void scx_ops_fallback_dispatch(s32 cpu, struct task_struct *prev) {}
 
-static void scx_ops_disable_workfn(struct kthread_work *work)
+static void reset_idle_masks(void)
 {
-	struct scx_exit_info *ei = &scx_exit_info;
-	struct scx_task_iter sti;
-	struct task_struct *p;
-	const char *reason;
-	int i, cpu, type;
-
-	type = atomic_read(&scx_exit_type);
-	while (true) {
-		/*
-		 * NONE indicates that a new scx_ops has been registered since
-		 * disable was scheduled - don't kill the new ops. DONE
-		 * indicates that the ops has already been disabled.
-		 */
-		if (type == SCX_EXIT_NONE || type == SCX_EXIT_DONE)
-			return;
-		if (atomic_try_cmpxchg(&scx_exit_type, &type, SCX_EXIT_DONE))
-			break;
-	}
-
-	cancel_delayed_work_sync(&scx_watchdog_work);
-
-	switch (type) {
-	case SCX_EXIT_UNREG:
-		reason = "BPF scheduler unregistered";
-		break;
-	case SCX_EXIT_SYSRQ:
-		reason = "disabled by sysrq-S";
-		break;
-	case SCX_EXIT_ERROR:
-		reason = "runtime error";
-		break;
-	case SCX_EXIT_ERROR_BPF:
-		reason = "scx_bpf_error";
-		break;
-	case SCX_EXIT_ERROR_STALL:
-		reason = "runnable task stall";
-		break;
-	default:
-		reason = "<UNKNOWN>";
-	}
+	cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.little);
+	cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.big);
+	if (is_partial_enabled())
+		cpumask_or(idle_masks.cpu, idle_masks.cpu, iso_masks.partial);
+	scx_has_idle_cpus = true;
+}
 
-	ei->type = type;
-	strlcpy(ei->reason, reason, sizeof(ei->reason));
+void __scx_update_idle(struct rq *rq, bool idle)
+{
+	int cpu = cpu_of(rq);
+	struct cpumask *sib_mask = topology_sibling_cpumask(cpu);
 
-	switch (scx_ops_set_enable_state(SCX_OPS_DISABLING)) {
-	case SCX_OPS_DISABLED:
-		pr_warn("sched_ext: ops error detected without ops (%s)\n",
-			scx_exit_info.msg);
-		WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_DISABLED) !=
-			     SCX_OPS_DISABLING);
+	if (skip_update_idle())
 		return;
-	case SCX_OPS_PREPPING:
-		goto forward_progress_guaranteed;
-	case SCX_OPS_DISABLING:
-		/* shouldn't happen but handle it like ENABLING if it does */
-		WARN_ONCE(true, "sched_ext: duplicate disabling instance?");
-		fallthrough;
-	case SCX_OPS_ENABLING:
-	case SCX_OPS_ENABLED:
-		break;
-	}
 
-	/*
-	 * DISABLING is set and ops was either ENABLING or ENABLED indicating
-	 * that the ops and static branches are set.
-	 *
-	 * We must guarantee that all runnable tasks make forward progress
-	 * without trusting the BPF scheduler. We can't grab any mutexes or
-	 * rwsems as they might be held by tasks that the BPF scheduler is
-	 * forgetting to run, which unfortunately also excludes toggling the
-	 * static branches.
-	 *
-	 * Let's work around by overriding a couple ops and modifying behaviors
-	 * based on the DISABLING state and then cycling the tasks through
-	 * dequeue/enqueue to force global FIFO scheduling.
-	 *
-	 * a. ops.enqueue() and .dispatch() are overridden for simple global
-	 *    FIFO scheduling.
-	 *
-	 * b. balance_scx() never sets %SCX_TASK_BAL_KEEP as the slice value
-	 *    can't be trusted. Whenever a tick triggers, the running task is
-	 *    rotated to the tail of the queue with core_sched_at touched.
-	 *
-	 * c. pick_next_task() suppresses zero slice warning.
-	 *
-	 * d. scx_prio_less() reverts to the default core_sched_at order.
-	 */
-	scx_ops.enqueue = scx_ops_fallback_enqueue;
-	scx_ops.dispatch = scx_ops_fallback_dispatch;
+	if (idle) {
+		cpumask_set_cpu(cpu, idle_masks.cpu);
+		if (!scx_has_idle_cpus)
+			scx_has_idle_cpus = true;
 
-	spin_lock_irq(&scx_tasks_lock);
-	scx_task_iter_init(&sti);
-	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
-		if (READ_ONCE(p->__state) != TASK_DEAD) {
-			SCHED_CHANGE_BLOCK(task_rq(p), p,
-					   DEQUEUE_SAVE | DEQUEUE_MOVE) {
-				/* cycling deq/enq is enough, see above */
-			}
+		/*
+		 * idle_masks.smt handling is racy but that's fine as it's only
+		 * for optimization and self-correcting.
+		 */
+		for_each_cpu(cpu, sib_mask) {
+			if (!cpumask_test_cpu(cpu, idle_masks.cpu))
+				return;
 		}
+		cpumask_or(idle_masks.smt, idle_masks.smt, sib_mask);
+	} else {
+		cpumask_clear_cpu(cpu, idle_masks.cpu);
+		if (scx_has_idle_cpus && cpumask_empty(idle_masks.cpu))
+			scx_has_idle_cpus = false;
+
+		cpumask_andnot(idle_masks.smt, idle_masks.smt, sib_mask);
 	}
-	scx_task_iter_exit(&sti);
-	spin_unlock_irq(&scx_tasks_lock);
+}
 
-	/* kick all CPUs to restore ticks */
-	for_each_possible_cpu(cpu)
-		resched_cpu(cpu);
+#else /* !CONFIG_SMP */
 
-forward_progress_guaranteed:
-	/*
-	 * Here, every runnable task is guaranteed to make forward progress and
-	 * we can safely use blocking synchronization constructs. Actually
-	 * disable ops.
-	 */
-	mutex_lock(&scx_ops_enable_mutex);
+static bool test_and_clear_cpu_idle(int cpu) { return false; }
+static s32 scx_pick_idle_cpu(const struct cpumask *cpus_allowed) { return -EBUSY; }
+static void reset_idle_masks(void) {}
 
-	static_branch_disable(&__scx_switched_all);
-	WRITE_ONCE(scx_switching_all, false);
+#endif /* CONFIG_SMP */
 
-	/* avoid racing against fork and cgroup changes */
-	cpus_read_lock();
-	percpu_down_write(&scx_fork_rwsem);
-	scx_cgroup_lock();
+static bool check_rq_for_timeouts(struct rq *rq)
+{
+	struct sched_ext_entity *entity;
+	struct task_struct *p;
+	struct rq_flags rf;
+	bool timed_out = false;
+	struct task_struct *tp;
+	int total_count = 0;
+	int lvl_cnt[4] = {0};
+	int sum = 0, i;
 
-	spin_lock_irq(&scx_tasks_lock);
-	scx_task_iter_init(&sti);
-	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
-		const struct sched_class *old_class = p->sched_class;
-		struct rq *rq = task_rq(p);
-		bool alive = READ_ONCE(p->__state) != TASK_DEAD;
+	rq_lock_irqsave(rq, &rf);
+	list_for_each_entry(entity, &rq->scx->watchdog_list, watchdog_node) {
+		unsigned long last_runnable;
 
-		update_rq_clock(rq);
+		p = entity->task;
+		last_runnable = p->scx->runnable_at;
 
-		SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
-				   DEQUEUE_NOCLOCK) {
-			p->scx->slice = min_t(u64, p->scx->slice, SCX_SLICE_DFL);
+		if (unlikely(time_after(jiffies,
+					last_runnable + scx_watchdog_timeout))) {
+			u32 dur_ms = jiffies_to_msecs(jiffies - last_runnable);
 
-			__setscheduler_prio(p, p->prio);
+			scx_ops_error_type(SCX_EXIT_ERROR_STALL,
+					   "%s[%d] failed to run for %u.%03us,"
+						"p->scx->dsq->id = %llu,"
+						"p->cpumask = %*pb",
+					   	p->comm, p->pid,
+					   	dur_ms / 1000, dur_ms % 1000,
+						p->scx->dsq ? p->scx->dsq->id : 0,
+						cpumask_pr_args(&p->cpus_mask));
+			timed_out = true;
+			tp = p;
+			break;
 		}
-
-		if (alive)
-			check_class_changed(task_rq(p), p, old_class, p->prio);
-
-		scx_ops_disable_task(p);
 	}
-	scx_task_iter_exit(&sti);
-	spin_unlock_irq(&scx_tasks_lock);
-
-	/* no task is on scx, turn off all the switches and flush in-progress calls */
-	static_branch_disable_cpuslocked(&__scx_ops_enabled);
-	for (i = 0; i < SCX_NR_ONLINE_OPS; i++)
-		static_branch_disable_cpuslocked(&scx_has_op[i]);
-	static_branch_disable_cpuslocked(&scx_ops_enq_last);
-	static_branch_disable_cpuslocked(&scx_ops_enq_exiting);
-	static_branch_disable_cpuslocked(&scx_ops_cpu_preempt);
-	static_branch_disable_cpuslocked(&scx_builtin_idle_enabled);
-	synchronize_rcu();
+	rq_unlock_irqrestore(rq, &rf);
 
-	scx_cgroup_exit();
+	if (timed_out) {
+		rq_lock_irqsave(rq, &rf);
+		list_for_each_entry(entity, &rq->scx->watchdog_list, watchdog_node) {
+			unsigned long last_runnable;
+
+			p = entity->task;
+			last_runnable = p->scx->runnable_at;
+
+			total_count++;
+			if (time_before(jiffies, last_runnable + 5 * HZ)) {
+				lvl_cnt[0]++;
+			} else if (time_before(jiffies, last_runnable + 15 * HZ)) {
+				lvl_cnt[1]++;
+			} else if (time_before(jiffies, last_runnable + 30 * HZ)) {
+				lvl_cnt[2]++;
+			} else {
+				lvl_cnt[3]++;
+			}
+		}
+		pr_err("total watchdog_list count = %d\n", total_count);
+		pr_err("lvl_cnt = %d, %d, %d, %d\n", lvl_cnt[0], lvl_cnt[1],
+							lvl_cnt[2], lvl_cnt[3]);
+		pr_err("task:%s, dsq_id = %llu, mask = %*pb\n",
+				tp->comm, tp->scx->dsq ? tp->scx->dsq->id : 0,
+				cpumask_pr_args(&tp->cpus_mask));
+		pr_err("nr_running = %u\n", rq->scx->nr_running);
+		for_each_online_cpu(i)
+			sum += cpu_rq(i)->nr_running;
+		pr_err("sum = %d\n", sum);
+
+		rq_unlock_irqrestore(rq, &rf);
+	}
+	return timed_out;
+}
 
-	scx_cgroup_unlock();
-	percpu_up_write(&scx_fork_rwsem);
-	cpus_read_unlock();
+static void scx_watchdog_workfn(struct work_struct *work)
+{
+	int cpu;
 
-	if (ei->type >= SCX_EXIT_ERROR) {
-		printk(KERN_ERR "sched_ext: BPF scheduler \"%s\" errored, disabling\n", scx_ops.name);
+	scx_watchdog_timestamp = jiffies;
 
-		if (ei->msg[0] == '\0')
-			printk(KERN_ERR "sched_ext: %s\n", ei->reason);
-		else
-			printk(KERN_ERR "sched_ext: %s (%s)\n", ei->reason, ei->msg);
+	for_each_online_cpu(cpu) {
+		if (unlikely(check_rq_for_timeouts(cpu_rq(cpu))))
+			break;
 
-		stack_trace_print(ei->bt, ei->bt_len, 2);
+		cond_resched();
 	}
+	queue_delayed_work(system_unbound_wq, to_delayed_work(work),
+			   scx_watchdog_timeout / 2);
+}
 
-	if (scx_ops.exit)
-		SCX_CALL_OP(SCX_KF_UNLOCKED, exit, ei);
+static void set_pcp_round(struct rq *rq)
+{
+	int cpu = cpu_of(rq);
 
-	memset(&scx_ops, 0, sizeof(scx_ops));
+	if (atomic64_read(&pcp_dsq_round) != per_cpu(pcp_info, cpu).pcp_seq) {
+		per_cpu(pcp_info, cpu).pcp_seq = atomic64_read(&pcp_dsq_round);
+		per_cpu(pcp_info, cpu).pcp_round = true;
+		scx_info_systrace("C|9999|pcp_%d_round|%d\n", cpu, true);
+		per_cpu(pcp_info, cpu).rtime = 0;
+		systrace_output_rtime_state(&per_cpu(pcp_ldsq, cpu),
+                                        per_cpu(pcp_info, cpu).rtime);
+	}
+}
 
-	free_percpu(scx_dsp_buf);
-	scx_dsp_buf = NULL;
-	scx_dsp_max_batch = 0;
 
-	mutex_unlock(&scx_ops_enable_mutex);
+/*
+ * Just for debug: output ext on/off state per 10s.
+ */
+#define OUTPUT_INTVAL	(msecs_to_jiffies(10 * 1000))
+static void inform_ext_onoff_from_systrace(void)
+{
+	static unsigned long __read_mostly next_print;
 
-	WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_DISABLED) !=
-		     SCX_OPS_DISABLING);
+	if (time_before(jiffies, next_print))
+		return;
 
-	scx_cgroup_config_knobs();
+	next_print = jiffies + OUTPUT_INTVAL;
+	scx_internal_systrace("C|9999|scx_status|%d\n", curr_ss);
 }
 
-static DEFINE_KTHREAD_WORK(scx_ops_disable_work, scx_ops_disable_workfn);
-
-static void schedule_scx_ops_disable_work(void)
+static void task_tick_scx(struct rq *rq, struct task_struct *curr, int queued)
 {
-	struct kthread_worker *helper = READ_ONCE(scx_ops_helper);
+	update_curr_scx(rq);
 
+	set_pcp_round(rq);
+
+	trace_android_vh_hmbird_update_load(curr, rq, TASK_UPDATE, rq->clock);
 	/*
-	 * We may be called spuriously before the first bpf_sched_ext_reg(). If
-	 * scx_ops_helper isn't set up yet, there's nothing to do.
+	 * While disabling, always resched and refresh core-sched timestamp as
+	 * we can't trust the slice management or ops.core_sched_before().
 	 */
-	if (helper)
-		kthread_queue_work(helper, &scx_ops_disable_work);
+	if (scx_ops_disabling())
+		curr->scx->slice = 0;
+
+	if (!curr->scx->slice)
+		resched_curr(rq);
+
+	inform_ext_onoff_from_systrace();
 }
 
-static void scx_ops_disable(enum scx_exit_type type)
+static int scx_ops_prepare_task(struct task_struct *p, struct task_group *tg)
 {
-	int none = SCX_EXIT_NONE;
+	WARN_ON_ONCE(test_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags));
 
-	if (WARN_ON_ONCE(type == SCX_EXIT_NONE || type == SCX_EXIT_DONE))
-		type = SCX_EXIT_ERROR;
+	p->scx->disallow = false;
 
-	atomic_try_cmpxchg(&scx_exit_type, &none, type);
+	trace_android_vh_hmbird_init_task(p);
 
-	schedule_scx_ops_disable_work();
+	set_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags);
+	set_bit(ffs(SCX_TASK_WATCHDOG_RESET), (unsigned long*)&p->scx->flags);
+	return 0;
 }
 
-static void scx_ops_error_irq_workfn(struct irq_work *irq_work)
+static void scx_ops_enable_task(struct task_struct *p)
 {
-	schedule_scx_ops_disable_work();
-}
+	lockdep_assert_rq_held(task_rq(p));
+	WARN_ON_ONCE(!test_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags));
 
-static DEFINE_IRQ_WORK(scx_ops_error_irq_work, scx_ops_error_irq_workfn);
+	clear_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags);
+	set_bit(ffs(SCX_TASK_OPS_ENABLED), (unsigned long*)&p->scx->flags);
+}
 
-__printf(2, 3) void scx_ops_error_type(enum scx_exit_type type,
-				       const char *fmt, ...)
+static void scx_ops_disable_task(struct task_struct *p)
 {
-	struct scx_exit_info *ei = &scx_exit_info;
-	int none = SCX_EXIT_NONE;
-	va_list args;
-
-	if (!atomic_try_cmpxchg(&scx_exit_type, &none, type))
-		return;
-
-	ei->bt_len = stack_trace_save(ei->bt, ARRAY_SIZE(ei->bt), 1);
-
-	va_start(args, fmt);
-	vscnprintf(ei->msg, ARRAY_SIZE(ei->msg), fmt, args);
-	va_end(args);
+	lockdep_assert_rq_held(task_rq(p));
 
-	irq_work_queue(&scx_ops_error_irq_work);
+	if (test_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags)) {
+		clear_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags);
+	} else if (test_bit(ffs(SCX_TASK_OPS_ENABLED), (unsigned long*)&p->scx->flags)) {
+		clear_bit(ffs(SCX_TASK_OPS_ENABLED), (unsigned long*)&p->scx->flags);
+	}
 }
 
-static struct kthread_worker *scx_create_rt_helper(const char *name)
+static void set_task_scx_weight(struct task_struct *p)
 {
-	struct kthread_worker *helper;
+	u32 weight = sched_prio_to_weight[p->static_prio - MAX_RT_PRIO];
 
-	helper = kthread_create_worker(0, name);
-	if (helper)
-		sched_set_fifo(helper->task);
-	return helper;
+	p->scx->weight = sched_weight_to_cgroup(weight);
 }
 
-static int scx_ops_enable(struct sched_ext_ops *ops)
+/**
+ * refresh_scx_weight - Refresh a task's ext weight
+ * @p: task to refresh ext weight for
+ *
+ * @p->scx->weight carries the task's static priority in cgroup weight scale to
+ * enable easy access from the BPF scheduler. To keep it synchronized with the
+ * current task priority, this function should be called when a new task is
+ * created, priority is changed for a task on sched_ext, and a task is switched
+ * to sched_ext from other classes.
+ */
+static void refresh_scx_weight(struct task_struct *p)
 {
-	struct scx_task_iter sti;
-	struct task_struct *p;
-	int i, ret;
-	int tcnt = 0;
-	unsigned long long start = 0;
-	unsigned long  long total_start = sched_clock();
-
-	mutex_lock(&scx_ops_enable_mutex);
+	lockdep_assert_rq_held(task_rq(p));
+	set_task_scx_weight(p);
+}
 
-	if (!scx_ops_helper) {
-		WRITE_ONCE(scx_ops_helper,
-			   scx_create_rt_helper("sched_ext_ops_helper"));
-		if (!scx_ops_helper) {
-			ret = -ENOMEM;
-			goto err_unlock;
-		}
-	}
+int scx_pre_fork(struct task_struct *p)
+{
+	int ret = 0;
 
-	if (scx_ops_enable_state() != SCX_OPS_DISABLED) {
-		ret = -EBUSY;
-		goto err_unlock;
+	p->scx = kmalloc(sizeof(struct sched_ext_entity), GFP_KERNEL);
+	if (!p->scx) {
+		ret = -1;
+		goto lock;
 	}
 
-	//slim_walt_enable(true);
+	p->scx->dsq              = NULL;
+	INIT_LIST_HEAD(&p->scx->dsq_node.fifo);
+	RB_CLEAR_NODE(&p->scx->dsq_node.priq);
+	INIT_LIST_HEAD(&p->scx->watchdog_node);
+	p->scx->flags            = 0;
+	p->scx->weight           = 0;
+	p->scx->sticky_cpu       = -1;
+	p->scx->holding_cpu      = -1;
+	p->scx->kf_mask          = 0;
+	atomic64_set(&p->scx->ops_state, 0);
+	p->scx->runnable_at      = INITIAL_JIFFIES;
+	p->scx->slice            = SCX_SLICE_DFL;
+	p->scx->task             = p;
+	sched_set_sched_prop(p, 0);
 
 	/*
-	 * Set scx_ops, transition to PREPPING and clear exit info to arm the
-	 * disable path. Failure triggers full disabling from here on.
+	 * BPF scheduler enable/disable paths want to be able to iterate and
+	 * update all tasks which can become complex when racing forks. As
+	 * enable/disable are very cold paths, let's use a percpu_rwsem to
+	 * exclude forks.
 	 */
-	scx_ops = *ops;
-
-	WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_PREPPING) !=
-		     SCX_OPS_DISABLED);
+lock:
+	percpu_down_read(&scx_fork_rwsem);
 
-	memset(&scx_exit_info, 0, sizeof(scx_exit_info));
-	atomic_set(&scx_exit_type, SCX_EXIT_NONE);
-	scx_warned_zero_slice = false;
+	return ret;
+}
 
-	atomic64_set(&scx_nr_rejected, 0);
+int scx_fork(struct task_struct *p)
+{
+	percpu_rwsem_assert_held(&scx_fork_rwsem);
 
-	/*
-	 * Keep CPUs stable during enable so that the BPF scheduler can track
-	 * online CPUs by watching ->on/offline_cpu() after ->init().
-	 */
-	cpus_read_lock();
+	if (scx_enabled())
+		return scx_ops_prepare_task(p, task_group(p));
+	else
+		return 0;
+}
 
-	scx_switch_all_req = true;
-	if (scx_ops.init) {
-		ret = SCX_CALL_OP_RET(SCX_KF_INIT, init);
-		if (ret) {
-			ret = ops_sanitize_err("init", ret);
-			goto err_disable;
-		}
+void scx_post_fork(struct task_struct *p)
+{
+	if (scx_enabled()) {
+		struct rq_flags rf;
+		struct rq *rq;
 
+		rq = task_rq_lock(p, &rf);
 		/*
-		 * Exit early if ops.init() triggered scx_bpf_error(). Not
-		 * strictly necessary as we'll fail transitioning into ENABLING
-		 * later but that'd be after calling ops.prep_enable() on all
-		 * tasks and with -EBUSY which isn't very intuitive. Let's exit
-		 * early with success so that the condition is notified through
-		 * ops.exit() like other scx_bpf_error() invocations.
-		 */
-		if (atomic_read(&scx_exit_type) != SCX_EXIT_NONE)
-			goto err_disable;
-	}
-
-	WARN_ON_ONCE(scx_dsp_buf);
-	scx_dsp_max_batch = ops->dispatch_max_batch ?: SCX_DSP_DFL_MAX_BATCH;
-	scx_dsp_buf = __alloc_percpu(sizeof(scx_dsp_buf[0]) * scx_dsp_max_batch,
-				     __alignof__(scx_dsp_buf[0]));
-	if (!scx_dsp_buf) {
-		ret = -ENOMEM;
-		goto err_disable;
-	}
-
-	scx_watchdog_timeout = SCX_WATCHDOG_MAX_TIMEOUT;
-	if (ops->timeout_ms)
-		scx_watchdog_timeout = msecs_to_jiffies(ops->timeout_ms);
-
-	scx_watchdog_timestamp = jiffies;
-	queue_delayed_work(system_unbound_wq, &scx_watchdog_work,
-			   scx_watchdog_timeout / 2);
-
-	/*
-	 * Lock out forks, cgroup on/offlining and moves before opening the
-	 * floodgate so that they don't wander into the operations prematurely.
-	 */
-	percpu_down_write(&scx_fork_rwsem);
-	scx_cgroup_lock();
+		 * Set the weight manually before calling ops.enable() so that
+		 * the scheduler doesn't see a stale value if they inspect the
+		 * task struct. We'll invoke ops.set_weight() afterwards, as it
+		 * would be odd to receive a callback on the task before we
+		 * tell the scheduler that it's been fully enabled.
+		 */
+		set_task_scx_weight(p);
+		scx_ops_enable_task(p);
+		refresh_scx_weight(p);
+		task_rq_unlock(rq, p, &rf);
+	}
 
-	for (i = 0; i < SCX_NR_ONLINE_OPS; i++)
-		if (((void (**)(void))ops)[i])
-			static_branch_enable_cpuslocked(&scx_has_op[i]);
+	spin_lock_irq(&scx_tasks_lock);
+	list_add_tail(&p->scx->tasks_node, &scx_tasks);
+	spin_unlock_irq(&scx_tasks_lock);
 
-	if (ops->flags & SCX_OPS_ENQ_LAST)
-		static_branch_enable_cpuslocked(&scx_ops_enq_last);
+	percpu_up_read(&scx_fork_rwsem);
+}
 
-	if (ops->flags & SCX_OPS_ENQ_EXITING)
-		static_branch_enable_cpuslocked(&scx_ops_enq_exiting);
-	if (scx_ops.cpu_acquire || scx_ops.cpu_release)
-		static_branch_enable_cpuslocked(&scx_ops_cpu_preempt);
+void scx_cancel_fork(struct task_struct *p)
+{
+	if (scx_enabled())
+		scx_ops_disable_task(p);
 
-	if (!ops->update_idle || (ops->flags & SCX_OPS_KEEP_BUILTIN_IDLE)) {
-		reset_idle_masks();
-		static_branch_enable_cpuslocked(&scx_builtin_idle_enabled);
-	} else {
-		static_branch_disable_cpuslocked(&scx_builtin_idle_enabled);
+	if (p->scx) {
+		kfree(p->scx);
+		p->scx = NULL;
 	}
+	percpu_up_read(&scx_fork_rwsem);
+}
 
-	/*
-	 * All cgroups should be initialized before letting in tasks. cgroup
-	 * on/offlining and task migrations are already locked out.
-	 */
-	ret = scx_cgroup_init();
-	if (ret)
-		goto err_disable_unlock;
+void sched_ext_free(struct task_struct *p)
+{
+	unsigned long flags;
 
-	static_branch_enable_cpuslocked(&__scx_ops_enabled);
+	spin_lock_irqsave(&scx_tasks_lock, flags);
+	list_del_init(&p->scx->tasks_node);
+	spin_unlock_irqrestore(&scx_tasks_lock, flags);
 
 	/*
-	 * Enable ops for every task. Fork is excluded by scx_fork_rwsem
-	 * preventing new tasks from being added. No need to exclude tasks
-	 * leaving as sched_ext_free() can handle both prepped and enabled
-	 * tasks. Prep all tasks first and then enable them with preemption
-	 * disabled.
+	 * @p is off scx_tasks and wholly ours. scx_ops_enable()'s PREPPED ->
+	 * ENABLED transitions can't race us. Disable ops for @p.
 	 */
-	spin_lock_irq(&scx_tasks_lock);
-
-	scx_task_iter_init(&sti);
-	while ((p = scx_task_iter_next_filtered(&sti))) {
-		get_task_struct(p);
-		spin_unlock_irq(&scx_tasks_lock);
-
-		ret = scx_ops_prepare_task(p, task_group(p));
-		if (ret) {
-			put_task_struct(p);
-			spin_lock_irq(&scx_tasks_lock);
-			scx_task_iter_exit(&sti);
-			spin_unlock_irq(&scx_tasks_lock);
-			pr_err("sched_ext: ops.prep_enable() failed (%d) for %s[%d] while loading\n",
-			       ret, p->comm, p->pid);
-			goto err_disable_unlock;
-		}
+	if (test_bit(ffs(SCX_TASK_OPS_PREPPED), (unsigned long*)&p->scx->flags) ||
+		test_bit(ffs(SCX_TASK_OPS_ENABLED), (unsigned long*)&p->scx->flags)) {
+		struct rq_flags rf;
+		struct rq *rq;
 
-		put_task_struct(p);
-		spin_lock_irq(&scx_tasks_lock);
+		rq = task_rq_lock(p, &rf);
+		scx_ops_disable_task(p);
+		task_rq_unlock(rq, p, &rf);
 	}
-	scx_task_iter_exit(&sti);
-
-	/*
-	 * All tasks are prepped but are still ops-disabled. Ensure that
-	 * %current can't be scheduled out and switch everyone.
-	 * preempt_disable() is necessary because we can't guarantee that
-	 * %current won't be starved if scheduled out while switching.
-	 */
-	preempt_disable();
-
-	/*
-	 * From here on, the disable path must assume that tasks have ops
-	 * enabled and need to be recovered.
-	 */
-	if (!scx_ops_tryset_enable_state(SCX_OPS_ENABLING, SCX_OPS_PREPPING)) {
-		preempt_enable();
-		spin_unlock_irq(&scx_tasks_lock);
-		ret = -EBUSY;
-		goto err_disable_unlock;
+	if (p->scx) {
+		kfree(p->scx);
+		p->scx = NULL;
 	}
+}
 
-	/*
-	 * We're fully committed and can't fail. The PREPPED -> ENABLED
-	 * transitions here are synchronized against sched_ext_free() through
-	 * scx_tasks_lock.
-	 */
-	WRITE_ONCE(scx_switching_all, scx_switch_all_req);
-	start = sched_clock();
+static void prio_changed_scx(struct rq *rq, struct task_struct *p, int oldprio)
+{
+}
 
-	scx_task_iter_init(&sti);
-	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
-		tcnt++;
-		if (READ_ONCE(p->__state) != TASK_DEAD) {
-			const struct sched_class *old_class = p->sched_class;
-			struct rq *rq = task_rq(p);
 
-			update_rq_clock(rq);
+static void check_preempt_curr_scx(struct rq *rq, struct task_struct *p, int wake_flags)
+{
+	int check_result = -1;
+	enum cpu_type type;
+	int sp_dl;
 
-			SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
-					   DEQUEUE_NOCLOCK) {
-				scx_ops_enable_task(p);
-				__setscheduler_prio(p, p->prio);
-			}
+	trace_android_vh_check_preempt_curr_scx(rq, p, wake_flags, &check_result);
 
-			check_class_changed(task_rq(p), p, old_class, p->prio);
-		} else {
-			scx_ops_disable_task(p);
-		}
+	if (check_result > 0) {
+		goto preempt;
 	}
-	printk("\n\n switch cnt = %d, duration = %llu, current cpu = %d \n\n", tcnt, sched_clock() - start, smp_processor_id());
-	scx_task_iter_exit(&sti);
 
-	spin_unlock_irq(&scx_tasks_lock);
-	preempt_enable();
-	scx_cgroup_unlock();
-	percpu_up_write(&scx_fork_rwsem);
+	sp_dl = p->scx->sched_prop & SCHED_PROP_DEADLINE_MASK;
+	if (!sp_dl || (sp_dl >= SCHED_PROP_DEADLINE_LEVEL3))
+		return;
 
-	if (!scx_ops_tryset_enable_state(SCX_OPS_ENABLED, SCX_OPS_ENABLING)) {
-		ret = -EBUSY;
-		goto err_disable;
-	}
+	type = cpu_cluster(cpu_of(rq));
+	if (type == EXCLUSIVE || ((type == PARTIAL) && !is_partial_enabled()))
+		return;
 
-	if (scx_switch_all_req)
-		static_branch_enable_cpuslocked(&__scx_switched_all);
+	if (rq->curr->prio > p->prio)
+		goto preempt;
 
-	cpus_read_unlock();
-	mutex_unlock(&scx_ops_enable_mutex);
+	return;
+preempt:
+	resched_curr(rq);
+}
+static void switched_to_scx(struct rq *rq, struct task_struct *p) {}
+
+int scx_check_setscheduler(struct task_struct *p, int policy)
+{
+	lockdep_assert_rq_held(task_rq(p));
 
-	scx_cgroup_config_knobs();
-	printk("\n total duration = %llu , current cpu = %d\n",  sched_clock() - total_start, smp_processor_id());
+	/* if disallow, reject transitioning into SCX */
+	if (scx_enabled() && READ_ONCE(p->scx->disallow) &&
+	    p->policy != policy && policy == SCHED_EXT)
+		return -EACCES;
 
 	return 0;
+}
 
-err_unlock:
-	mutex_unlock(&scx_ops_enable_mutex);
-	return ret;
+#ifdef CONFIG_NO_HZ_FULL
+bool scx_can_stop_tick(struct rq *rq)
+{
+	struct task_struct *p = rq->curr;
 
-err_disable_unlock:
-	scx_cgroup_unlock();
-	percpu_up_write(&scx_fork_rwsem);
-err_disable:
-	cpus_read_unlock();
-	mutex_unlock(&scx_ops_enable_mutex);
-	/* must be fully disabled before returning */
-	scx_ops_disable(SCX_EXIT_ERROR);
-	kthread_flush_work(&scx_ops_disable_work);
-	return ret;
-}
+	if (scx_ops_disabling())
+		return false;
 
-#ifdef CONFIG_SCHED_DEBUG
-static const char *scx_ops_enable_state_str[] = {
-	[SCX_OPS_PREPPING]	= "prepping",
-	[SCX_OPS_ENABLING]	= "enabling",
-	[SCX_OPS_ENABLED]	= "enabled",
-	[SCX_OPS_DISABLING]	= "disabling",
-	[SCX_OPS_DISABLED]	= "disabled",
-};
+	if (p->sched_class != &ext_sched_class)
+		return true;
 
-static int scx_debug_show(struct seq_file *m, void *v)
-{
-	mutex_lock(&scx_ops_enable_mutex);
-	seq_printf(m, "%-30s: %s\n", "ops", scx_ops.name);
-	seq_printf(m, "%-30s: %ld\n", "enabled", scx_enabled());
-	seq_printf(m, "%-30s: %d\n", "switching_all",
-		   READ_ONCE(scx_switching_all));
-	seq_printf(m, "%-30s: %ld\n", "switched_all", scx_switched_all());
-	seq_printf(m, "%-30s: %s\n", "enable_state",
-		   scx_ops_enable_state_str[scx_ops_enable_state()]);
-	seq_printf(m, "%-30s: %llu\n", "nr_rejected",
-		   atomic64_read(&scx_nr_rejected));
-	mutex_unlock(&scx_ops_enable_mutex);
-	return 0;
+	/*
+	 * @rq can dispatch from different DSQs, so we can't tell whether it
+	 * needs the tick or not by looking at nr_running. Allow stopping ticks
+	 * iff the BPF scheduler indicated so. See set_next_task_scx().
+	 */
+	return rq->scx->flags & SCX_RQ_CAN_STOP_TICK;
 }
+#endif
 
-static int scx_debug_open(struct inode *inode, struct file *file)
+int scx_tg_online(struct task_group *tg)
 {
-	return single_open(file, scx_debug_show, NULL);
+	tg->scx_deadline_idx = -1;
+	return 0;
 }
 
-const struct file_operations sched_ext_fops = {
-	.open		= scx_debug_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-#endif
-
-/********************************************************************************
- * bpf_struct_ops plumbing.
+/*
+ * Omitted operations:
+ *
+ * - check_preempt_curr: NOOP as it isn't useful in the wakeup path because the
+ *   task isn't tied to the CPU at that point. Preemption is implemented by
+ *   resetting the victim task's slice to 0 and triggering reschedule on the
+ *   target CPU.
+ *
+ * - migrate_task_rq: Unncessary as task to cpu mapping is transient.
+ *
+ * - task_fork/dead: We need fork/dead notifications for all tasks regardless of
+ *   their current sched_class. Call them directly from sched core instead.
+ *
+ * - task_woken, switched_from: Unnecessary.
  */
-#include <linux/bpf_verifier.h>
-#include <linux/bpf.h>
-#include <linux/btf.h>
+DEFINE_SCHED_CLASS(ext) = {
+	.enqueue_task		= enqueue_task_scx,
+	.dequeue_task		= dequeue_task_scx,
+	.yield_task		= yield_task_scx,
+	.yield_to_task		= yield_to_task_scx,
 
-extern struct btf *btf_vmlinux;
-static const struct btf_type *task_struct_type;
+	.check_preempt_curr	= check_preempt_curr_scx,
 
-static bool bpf_scx_is_valid_access(int off, int size,
-				    enum bpf_access_type type,
-				    const struct bpf_prog *prog,
-				    struct bpf_insn_access_aux *info)
-{
-	if (off < 0 || off >= sizeof(__u64) * MAX_BPF_FUNC_ARGS)
-		return false;
-	if (type != BPF_READ)
-		return false;
-	if (off % size != 0)
-		return false;
+	.pick_next_task		= pick_next_task_scx,
 
-	return btf_ctx_access(off, size, type, prog, info);
-}
+	.put_prev_task		= put_prev_task_scx,
+	.set_next_task          = set_next_task_scx,
 
-static int bpf_scx_btf_struct_access(struct bpf_verifier_log *log,
-				 const struct bpf_reg_state *reg,
-				 int off, int size)
-{
-	return 0;
-}
+#ifdef CONFIG_SMP
+	.balance		= balance_scx,
+	.select_task_rq		= select_task_rq_scx,
+	.set_cpus_allowed	= set_cpus_allowed_scx,
+#endif
+	.task_tick		= task_tick_scx,
 
-static const struct bpf_func_proto *
-bpf_scx_get_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
-{
-	switch (func_id) {
-	case BPF_FUNC_task_storage_get:
-		return &bpf_task_storage_get_proto;
-	case BPF_FUNC_task_storage_delete:
-		return &bpf_task_storage_delete_proto;
-	default:
-		return bpf_base_func_proto(func_id);
-	}
-}
+	.switched_to		= switched_to_scx,
+	.prio_changed		= prio_changed_scx,
+
+	.update_curr		= update_curr_scx,
 
-const struct bpf_verifier_ops bpf_scx_verifier_ops = {
-	.get_func_proto = bpf_scx_get_func_proto,
-	.is_valid_access = bpf_scx_is_valid_access,
-	.btf_struct_access = bpf_scx_btf_struct_access,
+#ifdef CONFIG_UCLAMP_TASK
+	.uclamp_enabled		= 0,
+#endif
 };
 
-static int bpf_scx_init_member(const struct btf_type *t,
-			       const struct btf_member *member,
-			       void *kdata, const void *udata)
+/*
+ * Must with rq lock held.
+ */
+bool task_is_scx(struct task_struct *p)
 {
-	const struct sched_ext_ops *uops = udata;
-	struct sched_ext_ops *ops = kdata;
-	u32 moff = __btf_member_bit_offset(t, member) / 8;
-	int ret;
+	return p->sched_class == &ext_sched_class;
+}
+EXPORT_SYMBOL_GPL(task_is_scx);
 
-	switch (moff) {
-	case offsetof(struct sched_ext_ops, dispatch_max_batch):
-		if (*(u32 *)(udata + moff) > INT_MAX)
-			return -E2BIG;
-		ops->dispatch_max_batch = *(u32 *)(udata + moff);
-		return 1;
-	case offsetof(struct sched_ext_ops, flags):
-		if (*(u64 *)(udata + moff) & ~SCX_OPS_ALL_FLAGS)
-			return -EINVAL;
-		ops->flags = *(u64 *)(udata + moff);
-		return 1;
-	case offsetof(struct sched_ext_ops, name):
-		ret = bpf_obj_name_cpy(ops->name, uops->name,
-				       sizeof(ops->name));
-		if (ret < 0)
-			return ret;
-		if (ret == 0)
-			return -EINVAL;
-		return 1;
-	case offsetof(struct sched_ext_ops, timeout_ms):
-		if (*(u32 *)(udata + moff) > SCX_WATCHDOG_MAX_TIMEOUT)
-			return -E2BIG;
-		ops->timeout_ms = *(u32 *)(udata + moff);
-		return 1;
-	}
 
-	return 0;
+void init_dsq(struct scx_dispatch_q *dsq, u64 dsq_id)
+{
+	memset(dsq, 0, sizeof(*dsq));
+
+	raw_spin_lock_init(&dsq->lock);
+	INIT_LIST_HEAD(&dsq->fifo);
+	dsq->id = dsq_id;
 }
 
-static int bpf_scx_check_member(const struct btf_type *t,
-				const struct btf_member *member,
-				const struct bpf_prog *prog)
+static int scx_cgroup_init(void)
 {
-	u32 moff = __btf_member_bit_offset(t, member) / 8;
+	struct cgroup_subsys_state *css;
 
-	switch (moff) {
-	case offsetof(struct sched_ext_ops, prep_enable):
-	case offsetof(struct sched_ext_ops, init):
-	case offsetof(struct sched_ext_ops, exit):
-		break;
-	default:
-		/* check prog->aux->sleepable int 6.2, but no prog param in 6.1 */
-		/* if (prog->aux->sleepable)
-			return -EINVAL; */
-		break;
+	css_for_each_descendant_pre(css, &root_task_group.css) {
+		struct task_group *tg = css_tg(css);
+		cgrp_dsq_idx_init(css->cgroup, tg);
 	}
-
 	return 0;
 }
 
-static int bpf_scx_reg(void *kdata)
-{
-	return scx_ops_enable(kdata);
-}
-
-static void bpf_scx_unreg(void *kdata)
+/*
+ * Used by sched_fork() and __setscheduler_prio() to pick the matching
+ * sched_class. dl/rt are already handled.
+ */
+bool task_on_scx(struct task_struct *p)
 {
-	scx_ops_disable(SCX_EXIT_UNREG);
-	kthread_flush_work(&scx_ops_disable_work);
+	return scx_enabled();
 }
 
-static int bpf_scx_init(struct btf *btf)
+static void update_load_enable(bool enable)
 {
-	u32 type_id;
+	static bool prev = false;
 
-	type_id = btf_find_by_name_kind(btf, "task_struct", BTF_KIND_STRUCT);
-	if (type_id < 0)
-		return -EINVAL;
-	task_struct_type = btf_type_by_id(btf, type_id);
+	if (prev == enable)
+		return;
 
-	return 0;
+	prev = enable;
+	WRITE_ONCE(tick_sched_clock, 0);
+	if (enable)
+		atomic_set_release(&set_sched_clock_prepare, true);
+	trace_android_vh_hmbird_update_load_enable(enable);
 }
 
-/* "extern" to avoid sparse warning, only used in this file */
-extern struct bpf_struct_ops bpf_sched_ext_ops;
-
-struct bpf_struct_ops bpf_sched_ext_ops = {
-	.verifier_ops = &bpf_scx_verifier_ops,
-	.reg = bpf_scx_reg,
-	.unreg = bpf_scx_unreg,
-	.check_member = bpf_scx_check_member,
-	.init_member = bpf_scx_init_member,
-	.init = bpf_scx_init,
-	.name = "sched_ext_ops",
-};
-
-static void sysrq_handle_sched_ext_reset(u8 key)
+static void scx_switch_log(enum switch_stat ss, bool finish, bool enable)
 {
-	if (scx_ops_helper)
-		scx_ops_disable(SCX_EXIT_SYSRQ);
-	else
-		pr_info("sched_ext: BPF scheduler not yet used\n");
-}
+	char *s1 = finish ? "finished" : "failed";
+	char *s2 = enable ? "enabled" : "disabled";
+	scx_internal_systrace("C|9999|scx_status|%d\n", ss);
 
-static const struct sysrq_key_op sysrq_sched_ext_reset_op = {
-	.handler	= sysrq_handle_sched_ext_reset,
-	.help_msg	= "reset-sched-ext(S)",
-	.action_msg	= "Disable sched_ext and revert all tasks to CFS",
-	.enable_mask	= SYSRQ_ENABLE_RTNICE,
-};
+	if (ss == SCX_DISABLED || ss == SCX_ENABLED)
+		scx_debug("<hmbird_sched><switch>: ext %s %s at "
+				"jiffies = %lu, clock = %lu\n",
+				s2, s1, jiffies, (unsigned long)sched_clock());
+	curr_ss = ss;
+}
 
-static void kick_cpus_irq_workfn(struct irq_work *irq_work)
+static void scx_ops_disable_workfn(struct kthread_work *work)
 {
-	struct rq *this_rq = this_rq();
-	u64 *pseqs = this_cpu_ptr(scx_kick_cpus_pnt_seqs);
-	int this_cpu = cpu_of(this_rq);
+	struct scx_task_iter sti;
+	struct task_struct *p;
 	int cpu;
 
-	for_each_cpu(cpu, this_rq->scx->cpus_to_kick) {
-		struct rq *rq = cpu_rq(cpu);
-		unsigned long flags;
-
-		raw_spin_rq_lock_irqsave(rq, flags);
-
-		if (cpu_online(cpu) || cpu == this_cpu) {
-			if (cpumask_test_cpu(cpu, this_rq->scx->cpus_to_preempt) &&
-			    rq->curr->sched_class == &ext_sched_class)
-				rq->curr->scx->slice = 0;
-			pseqs[cpu] = rq->scx->pnt_seq;
-			resched_curr(rq);
-		} else {
-			cpumask_clear_cpu(cpu, this_rq->scx->cpus_to_wait);
-		}
+	scx_switch_log(SCX_SWITCH_PREP, 0, 0);
+	cancel_delayed_work_sync(&scx_watchdog_work);
 
-		raw_spin_rq_unlock_irqrestore(rq, flags);
+	switch (scx_ops_set_enable_state(SCX_OPS_DISABLING)) {
+	case SCX_OPS_DISABLED:
+		WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_DISABLED) !=
+			     SCX_OPS_DISABLING);
+		scx_switch_log(SCX_ENABLED, 0, 0);
+		return;
+	case SCX_OPS_PREPPING:
+		goto forward_progress_guaranteed;
+	case SCX_OPS_DISABLING:
+		/* shouldn't happen but handle it like ENABLING if it does */
+		WARN_ONCE(true, "sched_ext: duplicate disabling instance?");
+		fallthrough;
+	case SCX_OPS_ENABLING:
+	case SCX_OPS_ENABLED:
+		break;
 	}
 
-	for_each_cpu_andnot(cpu, this_rq->scx->cpus_to_wait,
-			    cpumask_of(this_cpu)) {
-		/*
-		 * Pairs with smp_store_release() issued by this CPU in
-		 * scx_notify_pick_next_task() on the resched path.
-		 *
-		 * We busy-wait here to guarantee that no other task can be
-		 * scheduled on our core before the target CPU has entered the
-		 * resched path.
-		 */
-		while (smp_load_acquire(&cpu_rq(cpu)->scx->pnt_seq) == pseqs[cpu])
-			cpu_relax();
+/*
+	spin_lock_irq(&scx_tasks_lock);
+	scx_task_iter_init(&sti);
+	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
+		if (READ_ONCE(p->__state) != TASK_DEAD) {
+			SCHED_CHANGE_BLOCK(task_rq(p), p,
+					   DEQUEUE_SAVE | DEQUEUE_MOVE) {
+			}
+		}
 	}
+	scx_task_iter_exit(&sti);
+	spin_unlock_irq(&scx_tasks_lock);
+*/
 
-	cpumask_clear(this_rq->scx->cpus_to_kick);
-	cpumask_clear(this_rq->scx->cpus_to_preempt);
-	cpumask_clear(this_rq->scx->cpus_to_wait);
-}
-
-void __init init_sched_ext_class(void)
-{
-	int cpu;
-	u32 v;
+	/* kick all CPUs to restore ticks */
+	for_each_possible_cpu(cpu)
+		resched_cpu(cpu);
 
+forward_progress_guaranteed:
 	/*
-	 * The following is to prevent the compiler from optimizing out the enum
-	 * definitions so that BPF scheduler implementations can use them
-	 * through the generated vmlinux.h.
+	 * Here, every runnable task is guaranteed to make forward progress and
+	 * we can safely use blocking synchronization constructs. Actually
+	 * disable ops.
 	 */
-	WRITE_ONCE(v, SCX_WAKE_EXEC | SCX_ENQ_WAKEUP | SCX_DEQ_SLEEP |
-		   SCX_TG_ONLINE | SCX_KICK_PREEMPT);
-
-	init_dsq(&scx_dsq_global, SCX_DSQ_GLOBAL);
-#ifdef CONFIG_SMP
-	BUG_ON(!alloc_cpumask_var(&idle_masks.cpu, GFP_KERNEL));
-	BUG_ON(!alloc_cpumask_var(&idle_masks.smt, GFP_KERNEL));
-#endif
-	scx_kick_cpus_pnt_seqs =
-		__alloc_percpu(sizeof(scx_kick_cpus_pnt_seqs[0]) *
-			       num_possible_cpus(),
-			       __alignof__(scx_kick_cpus_pnt_seqs[0]));
-	BUG_ON(!scx_kick_cpus_pnt_seqs);
-
-	for_each_possible_cpu(cpu) {
-		struct rq *rq = cpu_rq(cpu);
+	mutex_lock(&scx_ops_enable_mutex);
 
-		rq->scx = kmalloc(sizeof(struct scx_rq), GFP_KERNEL);
-		if (rq->scx)
-			rq->scx->rq = rq;
-		else
-			pr_err("fatal error : alloc rq->scx failed!!!\n");
 
-		init_dsq(&rq->scx->local_dsq, SCX_DSQ_LOCAL);
-		INIT_LIST_HEAD(&rq->scx->watchdog_list);
+	/* avoid racing against fork and cgroup changes */
+	cpus_read_lock();
+	percpu_down_write(&scx_fork_rwsem);
 
-		BUG_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_kick, GFP_KERNEL));
-		BUG_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_preempt, GFP_KERNEL));
-		BUG_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_wait, GFP_KERNEL));
-		init_irq_work(&rq->scx->kick_cpus_irq_work, kick_cpus_irq_workfn);
-	}
+	scx_switch_log(SCX_RQ_SWITCH_BEGIN, 0, 0);
+	spin_lock_irq(&scx_tasks_lock);
+	atomic_set(&__scx_ops_enabled, false);
+	scx_task_iter_init(&sti);
+	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
+		const struct sched_class *old_class = p->sched_class;
+		struct rq *rq = task_rq(p);
+		bool alive = READ_ONCE(p->__state) != TASK_DEAD;
 
-	register_sysrq_key('S', &sysrq_sched_ext_reset_op);
-	INIT_DELAYED_WORK(&scx_watchdog_work, scx_watchdog_workfn);
-	scx_cgroup_config_knobs();
-}
+		update_rq_clock(rq);
 
+		SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
+				   DEQUEUE_NOCLOCK) {
+			p->scx->slice = min_t(u64, p->scx->slice, SCX_SLICE_DFL);
 
-/********************************************************************************
- * Helpers that can be called from the BPF scheduler.
- */
-#include <linux/btf_ids.h>
+			__setscheduler_prio(p, p->prio);
+		}
 
-/* Disables missing prototype warnings for kfuncs */
-__diag_push();
-__diag_ignore_all("-Wmissing-prototypes",
-		  "Global functions as their definitions will be in vmlinux BTF");
+		if (alive)
+			check_class_changed(task_rq(p), p, old_class, p->prio);
 
-/**
- * scx_bpf_switch_all - Switch all tasks into SCX
- * @into_scx: switch direction
- *
- * If @into_scx is %true, all existing and future non-dl/rt tasks are switched
- * to SCX. If %false, only tasks which have %SCHED_EXT explicitly set are put on
- * SCX. The actual switching is asynchronous. Can be called from ops.init().
- */
-void scx_bpf_switch_all(void)
-{
-	if (!scx_kf_allowed(SCX_KF_INIT))
-		return;
+		scx_ops_disable_task(p);
+	}
+	scx_task_iter_exit(&sti);
+	spin_unlock_irq(&scx_tasks_lock);
+	scx_switch_log(SCX_RQ_SWITCH_DONE, 0, 0);
 
-	scx_switch_all_req = true;
-}
+	atomic_set(&non_ext_task, true);
+	/* no task is on scx, turn off all the switches and flush in-progress calls */
+	static_branch_disable_cpuslocked(&scx_ops_cpu_preempt);
+	synchronize_rcu();
 
-BTF_SET8_START(scx_kfunc_ids_init)
-BTF_ID_FLAGS(func, scx_bpf_switch_all)
-BTF_SET8_END(scx_kfunc_ids_init)
+	percpu_up_write(&scx_fork_rwsem);
+	cpus_read_unlock();
 
-static const struct btf_kfunc_id_set scx_kfunc_set_init = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_init,
-};
+	update_load_enable(false);
 
-/**
- * scx_bpf_create_dsq - Create a custom DSQ
- * @dsq_id: DSQ to create
- * @node: NUMA node to allocate from
- *
- * Create a custom DSQ identified by @dsq_id. Can be called from ops.init(),
- * ops.prep_enable(), ops.cgroup_init() and ops.cgroup_prep_move().
- */
-s32 scx_bpf_create_dsq(u64 dsq_id, s32 node)
-{
-	if (!scx_kf_allowed(SCX_KF_INIT))
-		return -EINVAL;
+	mutex_unlock(&scx_ops_enable_mutex);
 
-	if (unlikely(node >= (int)nr_node_ids ||
-		     (node < 0 && node != NUMA_NO_NODE)))
-		return -EINVAL;
-	return PTR_ERR_OR_ZERO(create_dsq(dsq_id, node));
+	WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_DISABLED) !=
+		     SCX_OPS_DISABLING);
+	scx_switch_log(SCX_DISABLED, 1, 0);
 }
 
-BTF_SET8_START(scx_kfunc_ids_sleepable)
-BTF_ID_FLAGS(func, scx_bpf_create_dsq)
-BTF_SET8_END(scx_kfunc_ids_sleepable)
-
-static const struct btf_kfunc_id_set scx_kfunc_set_sleepable = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_sleepable,
-};
+static DEFINE_KTHREAD_WORK(scx_ops_disable_work, scx_ops_disable_workfn);
 
-static bool scx_dispatch_preamble(struct task_struct *p, u64 enq_flags)
+static void schedule_scx_ops_disable_work(void)
 {
-	if (!scx_kf_allowed(SCX_KF_ENQUEUE | SCX_KF_DISPATCH))
-		return false;
-
-	lockdep_assert_irqs_disabled();
-
-	if (unlikely(!p)) {
-		scx_ops_error("called with NULL task");
-		return false;
-	}
-
-	if (unlikely(enq_flags & __SCX_ENQ_INTERNAL_MASK)) {
-		scx_ops_error("invalid enq_flags 0x%llx", enq_flags);
-		return false;
-	}
+	struct kthread_worker *helper = READ_ONCE(scx_ops_helper);
 
-	return true;
+	/*
+	 * We may be called spuriously before the first bpf_sched_ext_reg(). If
+	 * scx_ops_helper isn't set up yet, there's nothing to do.
+	 */
+	if (helper)
+		kthread_queue_work(helper, &scx_ops_disable_work);
 }
 
-static void scx_dispatch_commit(struct task_struct *p, u64 dsq_id, u64 enq_flags)
+static void scx_ops_disable(enum scx_exit_type type)
 {
-	struct task_struct *ddsp_task;
-	int idx;
-
-	ddsp_task = __this_cpu_read(direct_dispatch_task);
-	if (ddsp_task) {
-		direct_dispatch(ddsp_task, p, dsq_id, enq_flags);
-		return;
-	}
-
-	idx = __this_cpu_read(scx_dsp_ctx.buf_cursor);
-	if (unlikely(idx >= scx_dsp_max_batch)) {
-		scx_ops_error("dispatch buffer overflow");
-		return;
-	}
+	if (WARN_ON_ONCE(type == SCX_EXIT_NONE || type == SCX_EXIT_DONE))
+		type = SCX_EXIT_ERROR;
 
-	this_cpu_ptr(scx_dsp_buf)[idx] = (struct scx_dsp_buf_ent){
-		.task = p,
-		.qseq = atomic64_read(&p->scx->ops_state) & SCX_OPSS_QSEQ_MASK,
-		.dsq_id = dsq_id,
-		.enq_flags = enq_flags,
-	};
-	__this_cpu_inc(scx_dsp_ctx.buf_cursor);
+	schedule_scx_ops_disable_work();
 }
 
-/**
- * scx_bpf_dispatch - Dispatch a task into the FIFO queue of a DSQ
- * @p: task_struct to dispatch
- * @dsq_id: DSQ to dispatch to
- * @slice: duration @p can run for in nsecs
- * @enq_flags: SCX_ENQ_*
- *
- * Dispatch @p into the FIFO queue of the DSQ identified by @dsq_id. It is safe
- * to call this function spuriously. Can be called from ops.enqueue() and
- * ops.dispatch().
- *
- * When called from ops.enqueue(), it's for direct dispatch and @p must match
- * the task being enqueued. Also, %SCX_DSQ_LOCAL_ON can't be used to target the
- * local DSQ of a CPU other than the enqueueing one. Use ops.select_cpu() to be
- * on the target CPU in the first place.
- *
- * When called from ops.dispatch(), there are no restrictions on @p or @dsq_id
- * and this function can be called upto ops.dispatch_max_batch times to dispatch
- * multiple tasks. scx_bpf_dispatch_nr_slots() returns the number of the
- * remaining slots. scx_bpf_consume() flushes the batch and resets the counter.
- *
- * This function doesn't have any locking restrictions and may be called under
- * BPF locks (in the future when BPF introduces more flexible locking).
- *
- * @p is allowed to run for @slice. The scheduling path is triggered on slice
- * exhaustion. If zero, the current residual slice is maintained. If
- * %SCX_SLICE_INF, @p never expires and the BPF scheduler must kick the CPU with
- * scx_bpf_kick_cpu() to trigger scheduling.
- */
-void scx_bpf_dispatch(struct task_struct *p, u64 dsq_id, u64 slice,
-		      u64 enq_flags)
+static void scx_ops_error_irq_workfn(struct irq_work *irq_work)
 {
-	if (!scx_dispatch_preamble(p, enq_flags))
-		return;
+	schedule_scx_ops_disable_work();
+}
 
-	if (slice)
-		p->scx->slice = slice;
-	else
-		p->scx->slice = p->scx->slice ?: 1;
+static DEFINE_IRQ_WORK(scx_ops_error_irq_work, scx_ops_error_irq_workfn);
 
-	scx_dispatch_commit(p, dsq_id, enq_flags);
+__printf(2, 3) void scx_ops_error_type(enum scx_exit_type type,
+				       const char *fmt, ...)
+{
+	irq_work_queue(&scx_ops_error_irq_work);
 }
 
-/**
- * scx_bpf_dispatch_vtime - Dispatch a task into the vtime priority queue of a DSQ
- * @p: task_struct to dispatch
- * @dsq_id: DSQ to dispatch to
- * @slice: duration @p can run for in nsecs
- * @vtime: @p's ordering inside the vtime-sorted queue of the target DSQ
- * @enq_flags: SCX_ENQ_*
- *
- * Dispatch @p into the vtime priority queue of the DSQ identified by @dsq_id.
- * Tasks queued into the priority queue are ordered by @vtime and always
- * consumed after the tasks in the FIFO queue. All other aspects are identical
- * to scx_bpf_dispatch().
- *
- * @vtime ordering is according to time_before64() which considers wrapping. A
- * numerically larger vtime may indicate an earlier position in the ordering and
- * vice-versa.
- */
-void scx_bpf_dispatch_vtime(struct task_struct *p, u64 dsq_id, u64 slice,
-			    u64 vtime, u64 enq_flags)
+static struct kthread_worker *scx_create_rt_helper(const char *name)
 {
-	if (!scx_dispatch_preamble(p, enq_flags))
-		return;
-
-	if (slice)
-		p->scx->slice = slice;
-	else
-		p->scx->slice = p->scx->slice ?: 1;
-
-	p->scx->dsq_vtime = vtime;
+	struct kthread_worker *helper;
 
-	scx_dispatch_commit(p, dsq_id, enq_flags | SCX_ENQ_DSQ_PRIQ);
+	helper = kthread_create_worker(0, name);
+	if (helper)
+		sched_set_fifo(helper->task);
+	return helper;
 }
 
-BTF_SET8_START(scx_kfunc_ids_enqueue_dispatch)
-BTF_ID_FLAGS(func, scx_bpf_dispatch)
-BTF_ID_FLAGS(func, scx_bpf_dispatch_vtime)
-BTF_SET8_END(scx_kfunc_ids_enqueue_dispatch)
+static inline void set_audio_thread_sched_prop(struct task_struct *p)
+{
+	struct cgroup_subsys_state *css;
 
-static const struct btf_kfunc_id_set scx_kfunc_set_enqueue_dispatch = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_enqueue_dispatch,
-};
+	if (likely(p->prio >= MAX_RT_PRIO))
+		return;
 
-/**
- * scx_bpf_dispatch_nr_slots - Return the number of remaining dispatch slots
- *
- * Can only be called from ops.dispatch().
- */
-u32 scx_bpf_dispatch_nr_slots(void)
-{
-	if (!scx_kf_allowed(SCX_KF_DISPATCH))
-		return 0;
+	rcu_read_lock();
+	css = task_css(p, cpuset_cgrp_id);
+	if (!css) {
+		rcu_read_unlock();
+		return;
+	}
+	rcu_read_unlock();
 
-	return scx_dsp_max_batch - __this_cpu_read(scx_dsp_ctx.buf_cursor);
+	if (!strcmp(css->cgroup->kn->name, "audio-app"))
+		sched_set_sched_prop(p, SCHED_PROP_DEADLINE_LEVEL1);
+
+	return;
 }
 
-/**
- * scx_bpf_consume - Transfer a task from a DSQ to the current CPU's local DSQ
- * @dsq_id: DSQ to consume
- *
- * Consume a task from the non-local DSQ identified by @dsq_id and transfer it
- * to the current CPU's local DSQ for execution. Can only be called from
- * ops.dispatch().
- *
- * This function flushes the in-flight dispatches from scx_bpf_dispatch() before
- * trying to consume the specified DSQ. It may also grab rq locks and thus can't
- * be called under any BPF locks.
- *
- * Returns %true if a task has been consumed, %false if there isn't any task to
- * consume.
- */
-bool scx_bpf_consume(u64 dsq_id)
+static int scx_ops_enable(void *unused)
 {
-	struct scx_dsp_ctx *dspc = this_cpu_ptr(&scx_dsp_ctx);
-	struct scx_dispatch_q *dsq;
-
-	if (!scx_kf_allowed(SCX_KF_DISPATCH))
-		return false;
+	struct scx_task_iter sti;
+	struct task_struct *p;
+	int ret;
+	int tcnt = 0;
+	unsigned long long start = 0;
 
-	flush_dispatch_buf(dspc->rq, dspc->rf);
+	scx_switch_log(SCX_SWITCH_PREP, 0, 0);
+	mutex_lock(&scx_ops_enable_mutex);
 
-	dsq = find_non_local_dsq(dsq_id);
-	if (unlikely(!dsq)) {
-		scx_ops_error("invalid DSQ ID 0x%016llx", dsq_id);
-		return false;
+	if (!scx_ops_helper) {
+		WRITE_ONCE(scx_ops_helper,
+			   scx_create_rt_helper("sched_ext_ops_helper"));
+		if (!scx_ops_helper) {
+			ret = -ENOMEM;
+			goto err_unlock;
+		}
 	}
 
-	if (consume_dispatch_q(dspc->rq, dspc->rf, dsq)) {
-		/*
-		 * A successfully consumed task can be dequeued before it starts
-		 * running while the CPU is trying to migrate other dispatched
-		 * tasks. Bump nr_tasks to tell balance_scx() to retry on empty
-		 * local DSQ.
-		 */
-		dspc->nr_tasks++;
-		return true;
-	} else {
-		return false;
+	if (scx_ops_enable_state() != SCX_OPS_DISABLED) {
+		ret = -EBUSY;
+		goto err_unlock;
 	}
-}
 
-BTF_SET8_START(scx_kfunc_ids_dispatch)
-BTF_ID_FLAGS(func, scx_bpf_dispatch_nr_slots)
-BTF_ID_FLAGS(func, scx_bpf_consume)
-BTF_SET8_END(scx_kfunc_ids_dispatch)
+	update_load_enable(true);
 
-static const struct btf_kfunc_id_set scx_kfunc_set_dispatch = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_dispatch,
-};
+	WARN_ON_ONCE(scx_ops_set_enable_state(SCX_OPS_PREPPING) !=
+		     SCX_OPS_DISABLED);
 
-/**
- * scx_bpf_reenqueue_local - Re-enqueue tasks on a local DSQ
- *
- * Iterate over all of the tasks currently enqueued on the local DSQ of the
- * caller's CPU, and re-enqueue them in the BPF scheduler. Returns the number of
- * processed tasks. Can only be called from ops.cpu_release().
- */
-u32 scx_bpf_reenqueue_local(void)
-{
-	u32 nr_enqueued, i;
-	struct rq *rq;
-	struct scx_rq *scx_rq;
+	scx_warned_zero_slice = false;
+
+	atomic64_set(&scx_nr_rejected, 0);
+
+	/*
+	 * Keep CPUs stable during enable so that the BPF scheduler can track
+	 * online CPUs by watching ->on/offline_cpu() after ->init().
+	 */
+	cpus_read_lock();
 
-	if (!scx_kf_allowed(SCX_KF_CPU_RELEASE))
-		return 0;
+	scx_watchdog_timeout = SCX_WATCHDOG_MAX_TIMEOUT;
 
-	rq = cpu_rq(smp_processor_id());
-	lockdep_assert_rq_held(rq);
-	scx_rq = rq->scx;
+	scx_watchdog_timestamp = jiffies;
+	queue_delayed_work(system_unbound_wq, &scx_watchdog_work,
+			   scx_watchdog_timeout / 2);
 
 	/*
-	 * Get the number of tasks on the local DSQ before iterating over it to
-	 * pull off tasks. The enqueue callback below can signal that it wants
-	 * the task to stay on the local DSQ, and we want to prevent the BPF
-	 * scheduler from causing us to loop indefinitely.
+	 * Lock out forks, cgroup on/offlining and moves before opening the
+	 * floodgate so that they don't wander into the operations prematurely.
 	 */
-	nr_enqueued = scx_rq->local_dsq.nr;
-	for (i = 0; i < nr_enqueued; i++) {
-		struct task_struct *p;
+	percpu_down_write(&scx_fork_rwsem);
 
-		p = first_local_task(rq);
-		WARN_ON_ONCE(atomic64_read(&p->scx->ops_state) != SCX_OPSS_NONE);
-		WARN_ON_ONCE(!(p->scx->flags & SCX_TASK_QUEUED));
-		WARN_ON_ONCE(p->scx->holding_cpu != -1);
-		dispatch_dequeue(scx_rq, p);
-		do_enqueue_task(rq, p, SCX_ENQ_REENQ, -1);
-	}
+	reset_idle_masks();
 
-	return nr_enqueued;
-}
+	/*
+	 * All cgroups should be initialized before letting in tasks. cgroup
+	 * on/offlining and task migrations are already locked out.
+	 */
+	ret = scx_cgroup_init();
+	if (ret)
+		goto err_disable_unlock;
 
-BTF_SET8_START(scx_kfunc_ids_cpu_release)
-BTF_ID_FLAGS(func, scx_bpf_reenqueue_local)
-BTF_SET8_END(scx_kfunc_ids_cpu_release)
 
-static const struct btf_kfunc_id_set scx_kfunc_set_cpu_release = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_cpu_release,
-};
+	wait_for_completion_interruptible(&tick_sched_clock_completion);
+	atomic64_set(&scx_irq_work_lastq_ws, tick_sched_clock);
 
-/**
- * scx_bpf_kick_cpu - Trigger reschedule on a CPU
- * @cpu: cpu to kick
- * @flags: SCX_KICK_* flags
- *
- * Kick @cpu into rescheduling. This can be used to wake up an idle CPU or
- * trigger rescheduling on a busy CPU. This can be called from any online
- * scx_ops operation and the actual kicking is performed asynchronously through
- * an irq work.
- */
-void scx_bpf_kick_cpu(s32 cpu, u64 flags)
-{
-	struct rq *rq;
+	/*
+	 * Enable ops for every task. Fork is excluded by scx_fork_rwsem
+	 * preventing new tasks from being added. No need to exclude tasks
+	 * leaving as sched_ext_free() can handle both prepped and enabled
+	 * tasks. Prep all tasks first and then enable them with preemption
+	 * disabled.
+	 */
+	spin_lock_irq(&scx_tasks_lock);
 
-	if (!ops_cpu_valid(cpu)) {
-		scx_ops_error("invalid cpu %d", cpu);
-		return;
+	atomic_set(&non_ext_task, false);
+	atomic_set(&__scx_ops_enabled, true);
+
+	scx_task_iter_init(&sti);
+	while ((p = scx_task_iter_next_filtered(&sti))) {
+		scx_ops_prepare_task(p, task_group(p));
 	}
+	scx_task_iter_exit(&sti);
 
+	/*
+	 * All tasks are prepped but are still ops-disabled. Ensure that
+	 * %current can't be scheduled out and switch everyone.
+	 * preempt_disable() is necessary because we can't guarantee that
+	 * %current won't be starved if scheduled out while switching.
+	 */
 	preempt_disable();
-	rq = this_rq();
 
 	/*
-	 * Actual kicking is bounced to kick_cpus_irq_workfn() to avoid nesting
-	 * rq locks. We can probably be smarter and avoid bouncing if called
-	 * from ops which don't hold a rq lock.
+	 * From here on, the disable path must assume that tasks have ops
+	 * enabled and need to be recovered.
 	 */
-	cpumask_set_cpu(cpu, rq->scx->cpus_to_kick);
-	if (flags & SCX_KICK_PREEMPT)
-		cpumask_set_cpu(cpu, rq->scx->cpus_to_preempt);
-	if (flags & SCX_KICK_WAIT)
-		cpumask_set_cpu(cpu, rq->scx->cpus_to_wait);
-
-	irq_work_queue(&rq->scx->kick_cpus_irq_work);
-	preempt_enable();
-}
+	if (!scx_ops_tryset_enable_state(SCX_OPS_ENABLING, SCX_OPS_PREPPING)) {
+		preempt_enable();
+		spin_unlock_irq(&scx_tasks_lock);
+		ret = -EBUSY;
+		goto err_disable_unlock;
+	}
 
-/**
- * scx_bpf_dsq_nr_queued - Return the number of queued tasks
- * @dsq_id: id of the DSQ
- *
- * Return the number of tasks in the DSQ matching @dsq_id. If not found,
- * -%ENOENT is returned. Can be called from any non-sleepable online scx_ops
- * operations.
- */
-s32 scx_bpf_dsq_nr_queued(u64 dsq_id)
-{
-	struct scx_dispatch_q *dsq;
+	/*
+	 * We're fully committed and can't fail. The PREPPED -> ENABLED
+	 * transitions here are synchronized against sched_ext_free() through
+	 * scx_tasks_lock.
+	 */
+	start = sched_clock();
+	scx_switch_log(SCX_RQ_SWITCH_BEGIN, 0, 0);
+	scx_task_iter_init(&sti);
+	while ((p = scx_task_iter_next_filtered_locked(&sti))) {
+		if (reject_change_to_scx(p, p->prio))
+			continue;
 
-	lockdep_assert(rcu_read_lock_any_held());
+		tcnt++;
+		if (READ_ONCE(p->__state) != TASK_DEAD) {
+			const struct sched_class *old_class = p->sched_class;
+			struct rq *rq = task_rq(p);
 
-	if (dsq_id == SCX_DSQ_LOCAL) {
-		return this_rq()->scx->local_dsq.nr;
-	} else if ((dsq_id & SCX_DSQ_LOCAL_ON) == SCX_DSQ_LOCAL_ON) {
-		s32 cpu = dsq_id & SCX_DSQ_LOCAL_CPU_MASK;
+			set_audio_thread_sched_prop(p);
+			update_rq_clock(rq);
 
-		if (ops_cpu_valid(cpu))
-			return cpu_rq(cpu)->scx->local_dsq.nr;
-	} else {
-		dsq = find_non_local_dsq(dsq_id);
-		if (dsq)
-			return dsq->nr;
-	}
-	return -ENOENT;
-}
+			SCHED_CHANGE_BLOCK(rq, p, DEQUEUE_SAVE | DEQUEUE_MOVE |
+					   DEQUEUE_NOCLOCK) {
+				scx_ops_enable_task(p);
+				__setscheduler_prio(p, p->prio);
+			}
 
-/**
- * scx_bpf_test_and_clear_cpu_idle - Test and clear @cpu's idle state
- * @cpu: cpu to test and clear idle for
- *
- * Returns %true if @cpu was idle and its idle state was successfully cleared.
- * %false otherwise.
- *
- * Unavailable if ops.update_idle() is implemented and
- * %SCX_OPS_KEEP_BUILTIN_IDLE is not set.
- */
-bool scx_bpf_test_and_clear_cpu_idle(s32 cpu)
-{
-	if (!static_branch_likely(&scx_builtin_idle_enabled)) {
-		scx_ops_error("built-in idle tracking is disabled");
-		return false;
+			check_class_changed(task_rq(p), p, old_class, p->prio);
+		} else {
+			scx_ops_disable_task(p);
+		}
 	}
+	scx_task_iter_exit(&sti);
 
-	if (ops_cpu_valid(cpu))
-		return test_and_clear_cpu_idle(cpu);
-	else
-		return false;
-}
+	spin_unlock_irq(&scx_tasks_lock);
+	scx_switch_log(SCX_RQ_SWITCH_DONE, 0, 0);
+	preempt_enable();
+	percpu_up_write(&scx_fork_rwsem);
 
-/**
- * scx_bpf_pick_idle_cpu - Pick and claim an idle cpu
- * @cpus_allowed: Allowed cpumask
- *
- * Pick and claim an idle cpu which is also in @cpus_allowed. Returns the picked
- * idle cpu number on success. -%EBUSY if no matching cpu was found.
- *
- * Unavailable if ops.update_idle() is implemented and
- * %SCX_OPS_KEEP_BUILTIN_IDLE is not set.
- */
-s32 scx_bpf_pick_idle_cpu(const struct cpumask *cpus_allowed)
-{
-	if (!static_branch_likely(&scx_builtin_idle_enabled)) {
-		scx_ops_error("built-in idle tracking is disabled");
-		return -EBUSY;
+	if (!scx_ops_tryset_enable_state(SCX_OPS_ENABLED, SCX_OPS_ENABLING)) {
+		ret = -EBUSY;
+		goto err_disable;
 	}
 
-	return scx_pick_idle_cpu(cpus_allowed);
-}
+	cpus_read_unlock();
+	mutex_unlock(&scx_ops_enable_mutex);
+	scx_switch_log(SCX_ENABLED, 1, 1);
 
-/**
- * scx_bpf_get_idle_cpumask - Get a referenced kptr to the idle-tracking
- * per-CPU cpumask.
- *
- * Returns NULL if idle tracking is not enabled, or running on a UP kernel.
- */
-const struct cpumask *scx_bpf_get_idle_cpumask(void)
-{
-	if (!static_branch_likely(&scx_builtin_idle_enabled)) {
-		scx_ops_error("built-in idle tracking is disabled");
-		return cpu_none_mask;
-	}
+	return 0;
 
-#ifdef CONFIG_SMP
-	return idle_masks.cpu;
-#else
-	return cpu_none_mask;
-#endif
+err_unlock:
+	mutex_unlock(&scx_ops_enable_mutex);
+	return ret;
+
+err_disable_unlock:
+	percpu_up_write(&scx_fork_rwsem);
+err_disable:
+	cpus_read_unlock();
+	mutex_unlock(&scx_ops_enable_mutex);
+	/* must be fully disabled before returning */
+	scx_ops_disable(SCX_EXIT_ERROR);
+	kthread_flush_work(&scx_ops_disable_work);
+	scx_switch_log(SCX_DISABLED, 0, 1);
+	return ret;
 }
 
-/**
- * scx_bpf_get_idle_smtmask - Get a referenced kptr to the idle-tracking,
- * per-physical-core cpumask. Can be used to determine if an entire physical
- * core is free.
- *
- * Returns NULL if idle tracking is not enabled, or running on a UP kernel.
- */
-const struct cpumask *scx_bpf_get_idle_smtmask(void)
-{
-	if (!static_branch_likely(&scx_builtin_idle_enabled)) {
-		scx_ops_error("built-in idle tracking is disabled");
-		return cpu_none_mask;
-	}
+#ifdef CONFIG_SCHED_DEBUG
+static const char *scx_ops_enable_state_str[] = {
+	[SCX_OPS_PREPPING]	= "prepping",
+	[SCX_OPS_ENABLING]	= "enabling",
+	[SCX_OPS_ENABLED]	= "enabled",
+	[SCX_OPS_DISABLING]	= "disabling",
+	[SCX_OPS_DISABLED]	= "disabled",
+};
 
-#ifdef CONFIG_SMP
-	return idle_masks.smt;
-#else
-	return cpu_none_mask;
-#endif
+static int scx_debug_show(struct seq_file *m, void *v)
+{
+	mutex_lock(&scx_ops_enable_mutex);
+	seq_printf(m, "%-30s: %d\n", "enabled", scx_enabled());
+	seq_printf(m, "%-30s: %s\n", "enable_state",
+		   scx_ops_enable_state_str[scx_ops_enable_state()]);
+	seq_printf(m, "%-30s: %llu\n", "nr_rejected",
+		   atomic64_read(&scx_nr_rejected));
+	mutex_unlock(&scx_ops_enable_mutex);
+	return 0;
 }
 
-/**
- * scx_bpf_put_idle_cpumask - Release a previously acquired referenced kptr to
- * either the percpu, or SMT idle-tracking cpumask.
- */
-void scx_bpf_put_idle_cpumask(const struct cpumask *idle_mask)
+static int scx_debug_open(struct inode *inode, struct file *file)
 {
-	/*
-	 * Empty function body because we aren't actually acquiring or
-	 * releasing a reference to a global idle cpumask, which is read-only
-	 * in the caller and is never released. The acquire / release semantics
-	 * here are just used to make the cpumask is a trusted pointer in the
-	 * caller.
-	 */
+	return single_open(file, scx_debug_show, NULL);
 }
 
-struct scx_bpf_error_bstr_bufs {
-	u64			data[MAX_BPRINTF_VARARGS];
-	char			msg[SCX_EXIT_MSG_LEN];
+const struct file_operations sched_ext_fops = {
+	.open		= scx_debug_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
 };
+#endif
 
-static DEFINE_PER_CPU(struct scx_bpf_error_bstr_bufs, scx_bpf_error_bstr_bufs);
 
-/**
- * scx_bpf_error_bstr - Indicate fatal error
- * @fmt: error message format string
- * @data: format string parameters packaged using ___bpf_fill() macro
- * @data__sz: @data len, must end in '__sz' for the verifier
- *
- * Indicate that the BPF scheduler encountered a fatal error and initiate ops
- * disabling.
- */
-void scx_bpf_error_bstr(char *fmt, unsigned long long *data, u32 data__sz)
+static int bpf_scx_reg(void *kdata)
 {
-	struct scx_bpf_error_bstr_bufs *bufs;
-	unsigned long flags;
-	struct bpf_bprintf_data args = {};
-	int ret;
+	return scx_ops_enable(kdata);
+}
 
-	local_irq_save(flags);
-	bufs = this_cpu_ptr(&scx_bpf_error_bstr_bufs);
+static void bpf_scx_unreg(void *kdata)
+{
+	scx_ops_disable(SCX_EXIT_UNREG);
+	kthread_flush_work(&scx_ops_disable_work);
+}
 
-	if (data__sz % 8 || data__sz > MAX_BPRINTF_VARARGS * 8 ||
-	    (data__sz && !data)) {
-		scx_ops_error("invalid data=%p and data__sz=%u",
-			      (void *)data, data__sz);
-		goto out_restore;
-	}
+/*
+ * MUST load ext module before enable ext scheduler
+ * load track & ext gover implemented in ext module
+ */
+void ext_ctrl(bool enable)
+{
+	static bool prev_state;
 
-	ret = copy_from_kernel_nofault(bufs->data, data, data__sz);
-	if (ret) {
-		scx_ops_error("failed to read data fields (%d)", ret);
-		goto out_restore;
+	if (!atomic_read(&ext_module_loaded)) {
+		pr_err("hmbird_sched : ext module not loaded, failed to enable ext!\n");
+		return;
 	}
 
-	ret = bpf_bprintf_prepare(fmt, UINT_MAX, bufs->data, data__sz / 8, &args);
-	if (ret < 0) {
-		scx_ops_error("failed to format prepration (%d)", ret);
-		goto out_restore;
-	}
+	if (prev_state == enable)
+		return;
 
-	ret = bstr_printf(bufs->msg, sizeof(bufs->msg), fmt,
-			  args.bin_args);
-	bpf_bprintf_cleanup(&args);
-	if (ret < 0) {
-		scx_ops_error("scx_ops_error(\"%s\", %p, %u) failed to format",
-			      fmt, data, data__sz);
-		goto out_restore;
-	}
+	if (enable)
+		bpf_scx_reg(NULL);
+	else
+		bpf_scx_unreg(NULL);
 
-	scx_ops_error_type(SCX_EXIT_ERROR_BPF, "%s", bufs->msg);
-out_restore:
-	local_irq_restore(flags);
+	prev_state = enable;
 }
 
-/**
- * scx_bpf_destroy_dsq - Destroy a custom DSQ
- * @dsq_id: DSQ to destroy
- *
- * Destroy the custom DSQ identified by @dsq_id. Only DSQs created with
- * scx_bpf_create_dsq() can be destroyed. The caller must ensure that the DSQ is
- * empty and no further tasks are dispatched to it. Ignored if called on a DSQ
- * which doesn't exist. Can be called from any online scx_ops operations.
- */
-void scx_bpf_destroy_dsq(u64 dsq_id)
+static void sysrq_handle_sched_ext_reset(u8 key)
 {
-	destroy_dsq(dsq_id);
+	if (scx_ops_helper)
+		scx_ops_disable(SCX_EXIT_SYSRQ);
+	else
+		pr_info("sched_ext: BPF scheduler not yet used\n");
 }
 
-/**
- * scx_bpf_task_running - Is task currently running?
- * @p: task of interest
- */
-bool scx_bpf_task_running(const struct task_struct *p)
-{
-	return task_rq(p)->curr == p;
-}
+static const struct sysrq_key_op sysrq_sched_ext_reset_op = {
+	.handler	= sysrq_handle_sched_ext_reset,
+	.help_msg	= "reset-sched-ext(S)",
+	.action_msg	= "Disable sched_ext and revert all tasks to CFS",
+	.enable_mask	= SYSRQ_ENABLE_RTNICE,
+};
 
-/**
- * scx_bpf_task_cpu - CPU a task is currently associated with
- * @p: task of interest
- */
-s32 scx_bpf_task_cpu(const struct task_struct *p)
+void __init init_sched_ext_class(void)
 {
-	return task_cpu(p);
-}
+	int cpu;
+	u32 v;
 
-/**
- * scx_bpf_task_cgroup - Return the sched cgroup of a task
- * @p: task of interest
- *
- * @p->sched_task_group->css.cgroup represents the cgroup @p is associated with
- * from the scheduler's POV. SCX operations should use this function to
- * determine @p's current cgroup as, unlike following @p->cgroups,
- * @p->sched_task_group is protected by @p's rq lock and thus atomic w.r.t. all
- * rq-locked operations. Can be called on the parameter tasks of rq-locked
- * operations. The restriction guarantees that @p's rq is locked by the caller.
- */
-struct cgroup *scx_bpf_task_cgroup(struct task_struct *p)
-{
-	struct task_group *tg = p->sched_task_group;
-	struct cgroup *cgrp = &cgrp_dfl_root.cgrp;
+	/*
+	 * The following is to prevent the compiler from optimizing out the enum
+	 * definitions so that BPF scheduler implementations can use them
+	 * through the generated vmlinux.h.
+	 */
+	WRITE_ONCE(v, SCX_WAKE_EXEC | SCX_ENQ_WAKEUP | SCX_DEQ_SLEEP |
+		   SCX_KICK_PREEMPT);
 
-	if (!scx_kf_allowed_on_arg_tasks(__SCX_KF_RQ_LOCKED, p))
-		goto out;
+	init_dsq(&scx_dsq_global, SCX_DSQ_GLOBAL);
+	init_dsq_at_boot();
+	init_isolate_cpus();
+#ifdef CONFIG_SMP
+	WARN_ON(!alloc_cpumask_var(&idle_masks.cpu, GFP_KERNEL));
+	WARN_ON(!alloc_cpumask_var(&idle_masks.smt, GFP_KERNEL));
+#endif
 
 	/*
-	 * A task_group may either be a cgroup or an autogroup. In the latter
-	 * case, @tg->css.cgroup is %NULL. A task_group can't become the other
-	 * kind once created.
+	 * we can't static init init_task's scx struct, init here.
+	 * init_task->scx would not use during boot.
 	 */
-	if (tg && tg->css.cgroup)
-		cgrp = tg->css.cgroup;
-	else
-		cgrp = &cgrp_dfl_root.cgrp;
-out:
-	cgroup_get(cgrp);
-	return cgrp;
-}
-
-BTF_SET8_START(scx_kfunc_ids_any)
-BTF_ID_FLAGS(func, scx_bpf_kick_cpu)
-BTF_ID_FLAGS(func, scx_bpf_dsq_nr_queued)
-BTF_ID_FLAGS(func, scx_bpf_test_and_clear_cpu_idle)
-BTF_ID_FLAGS(func, scx_bpf_pick_idle_cpu)
-BTF_ID_FLAGS(func, scx_bpf_get_idle_cpumask, KF_ACQUIRE)
-BTF_ID_FLAGS(func, scx_bpf_get_idle_smtmask, KF_ACQUIRE)
-BTF_ID_FLAGS(func, scx_bpf_put_idle_cpumask, KF_RELEASE)
-BTF_ID_FLAGS(func, scx_bpf_error_bstr, KF_TRUSTED_ARGS)
-BTF_ID_FLAGS(func, scx_bpf_destroy_dsq)
-BTF_ID_FLAGS(func, scx_bpf_task_running)
-BTF_ID_FLAGS(func, scx_bpf_task_cpu)
-BTF_ID_FLAGS(func, scx_bpf_task_cgroup, KF_ACQUIRE)
-BTF_SET8_END(scx_kfunc_ids_any)
-
-static const struct btf_kfunc_id_set scx_kfunc_set_any = {
-	.owner			= THIS_MODULE,
-	.set			= &scx_kfunc_ids_any,
-};
+	init_task.scx = kmalloc(sizeof(struct sched_ext_entity), GFP_KERNEL);
+	if (init_task.scx) {
+		INIT_LIST_HEAD(&init_task.scx->dsq_node.fifo);
+		INIT_LIST_HEAD(&init_task.scx->watchdog_node);
+		init_task.scx->sticky_cpu = -1;
+		init_task.scx->holding_cpu = -1;
+		atomic64_set(&init_task.scx->ops_state, 0);
+		init_task.scx->runnable_at = jiffies;
+		init_task.scx->slice = SCX_SLICE_DFL;
+		init_task.scx->task = &init_task;
+		sched_set_sched_prop(&init_task, 0);
+	} else {
+		pr_err("fatal error : alloc init_task.scx failed!!!\n");
+	}
 
-__diag_pop();
+	for_each_possible_cpu(cpu) {
+		struct rq *rq = cpu_rq(cpu);
 
-/*
- * This can't be done from init_sched_ext_class() as register_btf_kfunc_id_set()
- * needs most of the system to be up.
- */
-static int __init register_ext_kfuncs(void)
-{
-	int ret;
+		/*
+		 * exec during boot phase, no need to care about alloc faild.
+		 * lifecycle same to rq, no need to free.
+		 */
+		rq->scx = kmalloc(sizeof(struct scx_rq), GFP_KERNEL);
+		if (rq->scx)
+			rq->scx->rq = rq;
+		else
+			pr_err("fatal error : alloc rq->scx failed!!!\n");
 
-	/*
-	 * Some kfuncs are context-sensitive and can only be called from
-	 * specific SCX ops. They are grouped into BTF sets accordingly.
-	 * Unfortunately, BPF currently doesn't have a way of enforcing such
-	 * restrictions. Eventually, the verifier should be able to enforce
-	 * them. For now, register them the same and make each kfunc explicitly
-	 * check using scx_kf_allowed().
-	 */
-	if ((ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_init)) ||
-	    (ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_sleepable)) ||
-	    (ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_enqueue_dispatch)) ||
-	    (ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_dispatch)) ||
-	    (ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_cpu_release)) ||
-	    (ret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS,
-					     &scx_kfunc_set_any))) {
-		pr_err("sched_ext: failed to register kfunc sets (%d)\n", ret);
-		return ret;
+
+		init_dsq(&rq->scx->local_dsq, SCX_DSQ_LOCAL);
+		INIT_LIST_HEAD(&rq->scx->watchdog_list);
+
+		WARN_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_kick, GFP_KERNEL));
+		WARN_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_preempt, GFP_KERNEL));
+		WARN_ON(!zalloc_cpumask_var(&rq->scx->cpus_to_wait, GFP_KERNEL));
 	}
 
-	return 0;
+	register_sysrq_key('S', &sysrq_sched_ext_reset_op);
+	INIT_DELAYED_WORK(&scx_watchdog_work, scx_watchdog_workfn);
 }
-__initcall(register_ext_kfuncs);
+
diff --git a/kernel/sched/ext.h b/kernel/sched/ext.h
index fba8ed845f99f..d36383d19df8a 100755
--- a/kernel/sched/ext.h
+++ b/kernel/sched/ext.h
@@ -7,6 +7,8 @@
  * Copyright (c) 2022 David Vernet <dvernet@meta.com>
  */
 
+#ifndef _EXT_H_
+#define _EXT_H_
 
 /*
  * Tag marking a kernel function as a kfunc. This is meant to minimize the
@@ -14,7 +16,51 @@
  * as to avoid issues such as the compiler inlining or eliding either a static
  * kfunc, or a global kfunc in an LTO build.
  */
-#define __bpf_kfunc __used noinline
+
+#define DEBUG_INTERNAL		(1 << 0)
+#define	DEBUG_INFO_TRACE	(1 << 1)
+#define DEBUG_INFO_SYSTRACE	(1 << 2)
+
+#define debug_enabled()	\
+	(unlikely(hmbirdcore_debug & DEBUG_INFO_TRACE | DEBUG_INFO_SYSTRACE))
+
+#define scx_debug(fmt, ...) \
+	pr_info("<hmbird_sched><ext>:"fmt, ##__VA_ARGS__);
+
+#define scx_err(fmt, ...) \
+	pr_err("<hmbird_sched><ext>:"fmt, ##__VA_ARGS__);
+
+#define scx_info_trace(fmt, ...)			\
+do {						\
+	if (unlikely(hmbirdcore_debug & DEBUG_INFO_TRACE))		\
+		trace_printk("<hmbird_sched><ext>:"fmt, ##__VA_ARGS__); \
+} while (0)
+
+
+#define scx_info_systrace(fmt, ...)	\
+do {					\
+	if (unlikely(hmbirdcore_debug & DEBUG_INFO_SYSTRACE)) {	\
+		char buf[256];		\
+		snprintf(buf, sizeof(buf), fmt, ##__VA_ARGS__);	\
+		tracing_mark_write(buf);			\
+	}				\
+} while (0)
+
+
+#define scx_internal_trace(fmt, ...)			\
+do {						\
+	if (unlikely(hmbirdcore_debug & DEBUG_INTERNAL))		\
+		trace_printk("<hmbird_sched><ext>:"fmt, ##__VA_ARGS__); \
+} while (0)
+
+#define scx_internal_systrace(fmt, ...)	\
+do {					\
+	if (unlikely(hmbirdcore_debug & DEBUG_INTERNAL)) {	\
+		char buf[256];		\
+		snprintf(buf, sizeof(buf), fmt, ##__VA_ARGS__);	\
+		tracing_mark_write(buf);			\
+	}				\
+} while (0)
 
 enum scx_wake_flags {
 	/* expose select WF_* flags as enums */
@@ -91,33 +137,21 @@ enum scx_deq_flags {
 	SCX_DEQ_CORE_SCHED_EXEC	= 1LLU << 32,
 };
 
-enum scx_tg_flags {
-	SCX_TG_ONLINE		= 1U << 0,
-	SCX_TG_INITED		= 1U << 1,
-};
-
 enum scx_kick_flags {
 	SCX_KICK_PREEMPT	= 1LLU << 0,	/* force scheduling on the CPU */
 	SCX_KICK_WAIT		= 1LLU << 1,	/* wait for the CPU to be rescheduled */
 };
 
-#ifdef CONFIG_SCHED_CLASS_EXT
-
 extern const struct sched_class ext_sched_class;
 extern const struct bpf_verifier_ops bpf_sched_ext_verifier_ops;
 extern const struct file_operations sched_ext_fops;
 extern unsigned long scx_watchdog_timeout;
 extern unsigned long scx_watchdog_timestamp;
 
-DECLARE_STATIC_KEY_FALSE(__scx_ops_enabled);
-DECLARE_STATIC_KEY_FALSE(__scx_switched_all);
-#define scx_enabled()		static_branch_unlikely(&__scx_ops_enabled)
-#define scx_switched_all()	static_branch_unlikely(&__scx_switched_all)
-
 DECLARE_STATIC_KEY_FALSE(scx_ops_cpu_preempt);
 
 bool task_on_scx(struct task_struct *p);
-void scx_pre_fork(struct task_struct *p);
+int scx_pre_fork(struct task_struct *p);
 int scx_fork(struct task_struct *p);
 void scx_post_fork(struct task_struct *p);
 void scx_cancel_fork(struct task_struct *p);
@@ -153,14 +187,18 @@ static inline void scx_notify_pick_next_task(struct rq *rq,
 	__scx_notify_pick_next_task(rq, p, active);
 }
 
-//extern void scx_scheduler_tick(void);
+extern void scx_scheduler_tick(void);
+void scan_timeout(struct rq *rq);
 static inline void scx_notify_sched_tick(void)
 {
 	unsigned long last_check;
+	int cpu = smp_processor_id();
+	struct rq *rq = cpu_rq(cpu);
+
+	scx_scheduler_tick();
 
 	if (!scx_enabled())
 		return;
-	//scx_scheduler_tick();
 
 	last_check = scx_watchdog_timestamp;
 	if (unlikely(time_after(jiffies, last_check + scx_watchdog_timeout))) {
@@ -170,12 +208,13 @@ static inline void scx_notify_sched_tick(void)
 				   "watchdog failed to check in for %u.%03us",
 				   dur_ms / 1000, dur_ms % 1000);
 	}
+	scan_timeout(rq);
 }
 
 static inline const struct sched_class *next_active_class(const struct sched_class *class)
 {
 	class++;
-	if (scx_switched_all() && class == &fair_sched_class)
+	if (scx_enabled() && class == &fair_sched_class)
 		class++;
 	if (!scx_enabled() && class == &ext_sched_class)
 		class++;
@@ -196,35 +235,12 @@ static inline const struct sched_class *next_active_class(const struct sched_cla
 	for_active_class_range(class, (prev_class) > &ext_sched_class ?		\
 			       &ext_sched_class : (prev_class), (end_class))
 
-#ifdef CONFIG_SCHED_CORE
-bool scx_prio_less(const struct task_struct *a, const struct task_struct *b,
-		   bool in_fi);
-#endif
-
-#else	/* CONFIG_SCHED_CLASS_EXT */
-
-#define scx_enabled()		false
-#define scx_switched_all()	false
-
-static inline void scx_pre_fork(struct task_struct *p) {}
-static inline int scx_fork(struct task_struct *p) { return 0; }
-static inline void scx_post_fork(struct task_struct *p) {}
-static inline void scx_cancel_fork(struct task_struct *p) {}
-static inline int scx_check_setscheduler(struct task_struct *p,
-					 int policy) { return 0; }
-static inline bool scx_can_stop_tick(struct rq *rq) { return true; }
-static inline void init_sched_ext_class(void) {}
-static inline void scx_notify_pick_next_task(struct rq *rq,
-					     const struct task_struct *p,
-					     const struct sched_class *active) {}
-static inline void scx_notify_sched_tick(void) {}
-
-#define for_each_active_class		for_each_class
-#define for_balance_class_range		for_class_range
+#define MAX_GLOBAL_DSQS (10)
+#define MIN_CGROUP_DL_IDX (5)      /* 8ms */
+#define DEFAULT_CGROUP_DL_IDX (8)  /* 64ms */
+extern u32 SCX_BPF_DSQS_DEADLINE[MAX_GLOBAL_DSQS];
 
-#endif	/* CONFIG_SCHED_CLASS_EXT */
 
-#if defined(CONFIG_SCHED_CLASS_EXT) && defined(CONFIG_SMP)
 void __scx_update_idle(struct rq *rq, bool idle);
 
 static inline void scx_update_idle(struct rq *rq, bool idle)
@@ -232,26 +248,16 @@ static inline void scx_update_idle(struct rq *rq, bool idle)
 	if (scx_enabled())
 		__scx_update_idle(rq, idle);
 }
-#else
-static inline void scx_update_idle(struct rq *rq, bool idle) {}
-#endif
 
-#ifdef CONFIG_CGROUP_SCHED
-#ifdef CONFIG_EXT_GROUP_SCHED
+void ext_ctrl(bool enable);
+
 int scx_tg_online(struct task_group *tg);
-void scx_tg_offline(struct task_group *tg);
-int scx_cgroup_can_attach(struct cgroup_taskset *tset);
-void scx_move_task(struct task_struct *p);
-void scx_cgroup_finish_attach(void);
-void scx_cgroup_cancel_attach(struct cgroup_taskset *tset);
-void scx_group_set_weight(struct task_group *tg, unsigned long cgrp_weight);
-#else	/* CONFIG_EXT_GROUP_SCHED */
-static inline int scx_tg_online(struct task_group *tg) { return 0; }
-static inline void scx_tg_offline(struct task_group *tg) {}
-static inline int scx_cgroup_can_attach(struct cgroup_taskset *tset) { return 0; }
-static inline void scx_move_task(struct task_struct *p) {}
-static inline void scx_cgroup_finish_attach(void) {}
-static inline void scx_cgroup_cancel_attach(struct cgroup_taskset *tset) {}
-static inline void scx_group_set_weight(struct task_group *tg, unsigned long cgrp_weight) {}
-#endif	/* CONFIG_EXT_GROUP_SCHED */
-#endif	/* CONFIG_CGROUP_SCHED */
+
+
+static inline u16 scx_task_util(struct task_struct *p)
+{
+	return (p->sched_class == &ext_sched_class) ? p->scx->sts.demand_scaled : 0;
+}
+u16 scx_cpu_util(int cpu);
+
+#endif /*_EXT_H_*/
diff --git a/kernel/sched/hmbird_export.c b/kernel/sched/hmbird_export.c
new file mode 100644
index 0000000000000..820a8e2bbb516
--- /dev/null
+++ b/kernel/sched/hmbird_export.c
@@ -0,0 +1,40 @@
+/*
+ * Some variables need to export, if CONFIG_HMBIRD_SCHED not configed,
+ * error will be reported by compiler, These variables must be defined
+ * outside of CONFIG_HMBIRD_SCHED MICRO.
+ */
+int slim_for_app;
+EXPORT_SYMBOL_GPL(slim_for_app);
+
+struct scx_sched_rq_stats {
+	u64             window_start;
+	u64             latest_clock;
+	u32             prev_window_size;
+	u64             task_exec_scale;
+	u64             prev_runnable_sum;
+	u64             curr_runnable_sum;
+};
+
+DEFINE_PER_CPU(struct scx_sched_rq_stats, scx_sched_rq_stats);
+EXPORT_SYMBOL_GPL(scx_sched_rq_stats);
+
+atomic64_t scx_irq_work_lastq_ws;
+EXPORT_SYMBOL_GPL(scx_irq_work_lastq_ws);
+
+atomic_t ext_module_loaded = ATOMIC_INIT(0);
+EXPORT_SYMBOL_GPL(ext_module_loaded);
+
+struct proc_dir_entry *hmbird_dir;
+EXPORT_SYMBOL_GPL(hmbird_dir);
+
+atomic_t non_ext_task = ATOMIC_INIT(true);
+EXPORT_SYMBOL_GPL(non_ext_task);
+
+atomic_t __scx_ops_enabled;
+EXPORT_SYMBOL_GPL(__scx_ops_enabled);
+
+#ifndef CONFIG_HMBIRD_SCHED
+bool task_is_scx(struct task_struct *p) {return false;}
+EXPORT_SYMBOL_GPL(task_is_scx);
+#endif
+
diff --git a/kernel/sched/hmbird_sched_proc_main.c b/kernel/sched/hmbird_sched_proc_main.c
index 80ff030823009..57437fd8ed8fe 100644
--- a/kernel/sched/hmbird_sched_proc_main.c
+++ b/kernel/sched/hmbird_sched_proc_main.c
@@ -185,6 +185,32 @@ HMBIRD_PROC_OPS(slim_walt_ctrl, hmbird_common_open,
                         slim_walt_ctrl_write);
 /* slim_walt_ctrl ops end */
 
+/*  hmbird_stats fops begin */
+#define HMBIRD_STATS	"hmbird_stats"
+#define MAX_STATS_BUF	(2000)
+static int hmbird_stats_show(struct seq_file *m, void *v)
+{
+	char buf[MAX_STATS_BUF] = {0};
+
+	stats_print(buf, MAX_STATS_BUF);
+
+	seq_printf(m, "%s\n", buf);
+	return 0;
+}
+
+static int hmbird_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, hmbird_stats_show, inode);
+}
+
+static const struct proc_ops hmbird_stat_fops = {
+	.proc_open		= hmbird_stats_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+};
+/*  hmbird_stats fops end */
+
 static int hmbird_proc_init(void)
 {
 	struct proc_dir_entry *hmbird_dir;
@@ -319,9 +345,7 @@ static int hmbird_proc_init(void)
 					&hmbird_common_proc_ops,
 					&parctrl_low_ratio_l);
 
-	HMBIRD_CREATE_PROC_ENTRY("hmbird_stats", HMBIRD_PROC_PERMISSION,
-					hmbird_dir,
-					&hmbird_stats_proc_ops);
+	proc_create(HMBIRD_STATS, S_IRUGO | S_IWUGO, hmbird_dir, &hmbird_stat_fops);
 	/* /proc/hmbird_sched--end */
 
 	/* mkdir /proc/hmbird_sched/slim_walt */
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
old mode 100755
new mode 100644
index b33cefeb4188a..4d445f5fc9bde
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -408,13 +408,17 @@ static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int fl
 
 static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)
 {
+#ifdef CONFIG_HMBIRD_SCHED
 	scx_update_idle(rq, false);
+#endif
 }
 
 static void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)
 {
 	update_idle_core(rq);
+#ifdef CONFIG_HMBIRD_SCHED
 	scx_update_idle(rq, true);
+#endif
 	schedstat_inc(rq->sched_goidle);
 }
 
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
old mode 100755
new mode 100644
index 509e8dc616ab1..e51c1fc7cc19c
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -188,18 +188,22 @@ static inline int idle_policy(int policy)
 	return policy == SCHED_IDLE;
 }
 
+#ifdef CONFIG_HMBIRD_SCHED
 static inline int normal_policy(int policy)
 {
-#ifdef CONFIG_SCHED_CLASS_EXT
 	if (policy == SCHED_EXT)
 		return true;
-#endif
 	return policy == SCHED_NORMAL;
 }
+#endif
 
 static inline int fair_policy(int policy)
 {
+#ifdef CONFIG_HMBIRD_SCHED
 	return normal_policy(policy) || policy == SCHED_BATCH;
+#else
+	return policy == SCHED_NORMAL || policy == SCHED_BATCH;
+#endif
 }
 
 static inline int rt_policy(int policy)
@@ -247,6 +251,7 @@ static inline void update_avg(u64 *avg, u64 sample)
 #define shr_bound(val, shift)							\
 	(val >> min_t(typeof(shift), shift, BITS_PER_TYPE(typeof(val)) - 1))
 
+#ifdef CONFIG_HMBIRD_SCHED
 /*
  * cgroup weight knobs should use the common MIN, DFL and MAX values which are
  * 1, 100 and 10000 respectively. While it loses a bit of range on both ends, it
@@ -264,6 +269,7 @@ static inline unsigned long sched_weight_to_cgroup(unsigned long weight)
 		       DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, 1024),
 		       CGROUP_WEIGHT_MIN, CGROUP_WEIGHT_MAX);
 }
+#endif
 
 /*
  * !! For sched_setattr_nocheck() (kernel) only !!
@@ -449,7 +455,11 @@ struct task_group {
 	ANDROID_VENDOR_DATA_ARRAY(1, 4);
 #endif
 
+#if defined(CONFIG_HMBIRD_SCHED) || defined(CONFIG_HMBIRD_SCHED_GKI)
+	ANDROID_KABI_USE(1, int scx_deadline_idx);
+#else
 	ANDROID_KABI_RESERVE(1);
+#endif
 	ANDROID_KABI_RESERVE(2);
 	ANDROID_KABI_RESERVE(3);
 	ANDROID_KABI_RESERVE(4);
@@ -532,10 +542,12 @@ static inline void set_task_rq_fair(struct sched_entity *se,
 			     struct cfs_rq *prev, struct cfs_rq *next) { }
 #endif /* CONFIG_SMP */
 #else /* CONFIG_FAIR_GROUP_SCHED */
+#ifdef CONFIG_HMBIRD_SCHED
 static inline int sched_group_set_shares(struct task_group *tg, unsigned long shares)
 {
 	return 0;
 }
+#endif
 #endif /* CONFIG_FAIR_GROUP_SCHED */
 
 #else /* CONFIG_CGROUP_SCHED */
@@ -700,7 +712,7 @@ struct cfs_rq {
 #endif /* CONFIG_FAIR_GROUP_SCHED */
 };
 
-#ifdef CONFIG_SCHED_CLASS_EXT
+#ifdef CONFIG_HMBIRD_SCHED
 /* scx_rq->flags, protected by the rq lock */
 enum scx_rq_flags {
 	SCX_RQ_CAN_STOP_TICK	= 1 << 0,
@@ -721,7 +733,7 @@ struct scx_rq {
 	struct irq_work		kick_cpus_irq_work;
 	struct rq               *rq;
 };
-#endif /* CONFIG_SCHED_CLASS_EXT */
+#endif /* CONFIG_HMBIRD_SCHED */
 
 static inline int rt_bandwidth_enabled(void)
 {
@@ -1258,8 +1270,8 @@ struct rq {
 
 	ANDROID_OEM_DATA_ARRAY(1, 16);
 
-#ifdef CONFIG_SLIM_SCHED
-	ANDROID_KABI_USE(1, struct scx_rq *scx);
+#ifdef CONFIG_HMBIRD_SCHED
+	ANDROID_KABI_USE(1, struct scx_rq	*scx);
 #else
 	ANDROID_KABI_RESERVE(1);
 #endif
@@ -2632,6 +2644,7 @@ static inline void sub_nr_running(struct rq *rq, unsigned count)
 extern void activate_task(struct rq *rq, struct task_struct *p, int flags);
 extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);
 
+#ifdef CONFIG_HMBIRD_SCHED
 struct sched_change_guard {
 	struct task_struct	*p;
 	struct rq		*rq;
@@ -2679,6 +2692,7 @@ extern void check_class_changed(struct rq *rq, struct task_struct *p,
 				const struct sched_class *prev_class,
 				int oldprio);
 
+#endif
 extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);
 
 #ifdef CONFIG_PREEMPT_RT
@@ -3712,4 +3726,8 @@ static inline bool cpu_busy_with_softirqs(int cpu)
 
 #include "ext.h"
 
+#ifdef CONFIG_HMBIRD_SCHED
+#include "ext.h"
+#endif
+
 #endif /* _KERNEL_SCHED_SCHED_H */
diff --git a/kernel/sched/slim.h b/kernel/sched/slim.h
old mode 100644
new mode 100755
index da24b6ee5e4c6..ea1619a7c2619
--- a/kernel/sched/slim.h
+++ b/kernel/sched/slim.h
@@ -1,10 +1,31 @@
 #ifndef __SLIM_H
 #define __SLIM_H
 
+extern int scx_enable;
+
+extern int cpuctrl_high_ratio;
+extern int cpuctrl_low_ratio;
+extern int partial_enable;
+extern int slim_stats;
+extern int misfit_ds;
+
+extern int slim_walt_ctrl;
+extern int slim_walt_dump;
+extern int slim_walt_policy;
+extern int slim_gov_debug;
+extern int hmbirdcore_debug;
+extern int sched_ravg_window_frame_per_sec;
+
 extern unsigned int highres_tick_ctrl;
 extern unsigned int highres_tick_ctrl_dbg;
 
+extern atomic_t __scx_ops_enabled;
+extern atomic_t non_ext_task;
+
 extern noinline int tracing_mark_write(const char *buf);
+int task_top_id(struct task_struct *p);
+void stats_print(char *buf, int len);
+extern spinlock_t scx_tasks_lock;
 
 
 #endif
diff --git a/kernel/sched/slim_sysctl.c b/kernel/sched/slim_sysctl.c
old mode 100644
new mode 100755
index 64205106cd2ab..c66d83517a39a
--- a/kernel/sched/slim_sysctl.c
+++ b/kernel/sched/slim_sysctl.c
@@ -9,7 +9,7 @@ unsigned int highres_tick_ctrl_dbg;
 #define HIGHRES_TICK_CTRL_DBG	"highres_tick_ctrl_dbg"
 
 #define SLIM_SCHED_DIR		"slim_sched"
-
+#define SCHED_EXT_DIR		"hmbird_sched"
 
 noinline int tracing_mark_write(const char *buf)
 {
@@ -53,21 +53,21 @@ static ssize_t slim_common_write(struct file *file, const char __user *buf,
 
 static int slim_common_show(struct seq_file *m, void *v)
 {
-        seq_printf(m, "%d\n", *(int*) m->private);
-        return 0;
+	seq_printf(m, "%d\n", *(int*) m->private);
+	return 0;
 }
 
 static int slim_common_open(struct inode *inode, struct file *file)
 {
-        return single_open(file, slim_common_show, pde_data(inode));
+	return single_open(file, slim_common_show, pde_data(inode));
 }
 
 static const struct proc_ops common_proc_ops = {
-        .proc_open              = slim_common_open,
-        .proc_write             = slim_common_write,
-        .proc_read              = seq_read,
-        .proc_lseek             = seq_lseek,
-        .proc_release           = single_release,
+	.proc_open              = slim_common_open,
+	.proc_write             = slim_common_write,
+	.proc_read              = seq_read,
+	.proc_lseek             = seq_lseek,
+	.proc_release           = single_release,
 };
 
 struct proc_dir_entry *slim_dir;
@@ -82,9 +82,9 @@ static int __init slim_sysfs_init(void)
 			proc_create_data(files_name[i], S_IRUGO | S_IWUGO,
 					slim_dir, &common_proc_ops, file_data[i]);
 		}
+
 	}
 	return 0;
 }
 
 __initcall(slim_sysfs_init);
-
diff --git a/kernel/sched/vendor_hooks.c b/kernel/sched/vendor_hooks.c
index 7a6a17f0d9a1c..2e9d32a692253 100755
--- a/kernel/sched/vendor_hooks.c
+++ b/kernel/sched/vendor_hooks.c
@@ -110,6 +110,10 @@ EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_cpu_cgroup_css_alloc);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_cpu_cgroup_css_free);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_reweight_entity);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_rvh_context_switch);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_hmbird_update_load);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_hmbird_init_task);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_hmbird_update_load_enable);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_get_util);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_mmput);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_rvh_attach_entity_load_avg);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_rvh_detach_entity_load_avg);
@@ -123,3 +127,9 @@ EXPORT_TRACEPOINT_SYMBOL_GPL(android_rvh_set_iowait);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_prio_inheritance);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_prio_restore);
 EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_set_task_comm);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_scx_select_cpu_dfl);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_scx_update_task_scale_time);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_check_preempt_curr_scx);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_task_fits_cpu_scx);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_scx_cpu_exclusive);
+EXPORT_TRACEPOINT_SYMBOL_GPL(android_vh_scx_consume_dsq_allowed);
